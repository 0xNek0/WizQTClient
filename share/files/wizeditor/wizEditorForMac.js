(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
"use strict";

require("core-js/shim");

require("regenerator-runtime/runtime");

require("core-js/fn/regexp/escape");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"core-js/fn/regexp/escape":5,"core-js/shim":328,"regenerator-runtime/runtime":2}],2:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],3:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],4:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":3,"ieee754":334}],5:[function(require,module,exports){
require('../../modules/core.regexp.escape');
module.exports = require('../../modules/_core').RegExp.escape;

},{"../../modules/_core":26,"../../modules/core.regexp.escape":131}],6:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],7:[function(require,module,exports){
var cof = require('./_cof');
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

},{"./_cof":21}],8:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_hide":45,"./_wks":129}],9:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],10:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":54}],11:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"./_to-absolute-index":114,"./_to-length":118,"./_to-object":119}],12:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"./_to-absolute-index":114,"./_to-length":118,"./_to-object":119}],13:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":42}],14:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":114,"./_to-iobject":117,"./_to-length":118}],15:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":18,"./_ctx":28,"./_iobject":50,"./_to-length":118,"./_to-object":119}],16:[function(require,module,exports){
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var toLength = require('./_to-length');

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

},{"./_a-function":6,"./_iobject":50,"./_to-length":118,"./_to-object":119}],17:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":52,"./_is-object":54,"./_wks":129}],18:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":17}],19:[function(require,module,exports){
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"./_a-function":6,"./_invoke":49,"./_is-object":54}],20:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":21,"./_wks":129}],21:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],22:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":9,"./_ctx":28,"./_descriptors":32,"./_for-of":42,"./_iter-define":58,"./_iter-step":60,"./_meta":68,"./_object-create":73,"./_object-dp":74,"./_redefine-all":93,"./_set-species":100,"./_validate-collection":126}],23:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_array-from-iterable":13,"./_classof":20}],24:[function(require,module,exports){
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_an-instance":9,"./_an-object":10,"./_array-methods":15,"./_for-of":42,"./_has":44,"./_is-object":54,"./_meta":68,"./_redefine-all":93,"./_validate-collection":126}],25:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":9,"./_export":36,"./_fails":38,"./_for-of":42,"./_global":43,"./_inherit-if-required":48,"./_is-object":54,"./_iter-detect":59,"./_meta":68,"./_redefine":94,"./_redefine-all":93,"./_set-to-string-tag":101}],26:[function(require,module,exports){
var core = module.exports = { version: '2.5.7' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],27:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":74,"./_property-desc":92}],28:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":6}],29:[function(require,module,exports){
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = require('./_fails');
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

},{"./_fails":38}],30:[function(require,module,exports){
'use strict';
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

},{"./_an-object":10,"./_to-primitive":120}],31:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],32:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":38}],33:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":43,"./_is-object":54}],34:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],35:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":80,"./_object-keys":83,"./_object-pie":84}],36:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":26,"./_ctx":28,"./_global":43,"./_hide":45,"./_redefine":94}],37:[function(require,module,exports){
var MATCH = require('./_wks')('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

},{"./_wks":129}],38:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],39:[function(require,module,exports){
'use strict';
var hide = require('./_hide');
var redefine = require('./_redefine');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"./_defined":31,"./_fails":38,"./_hide":45,"./_redefine":94,"./_wks":129}],40:[function(require,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"./_an-object":10}],41:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = require('./_is-array');
var isObject = require('./_is-object');
var toLength = require('./_to-length');
var ctx = require('./_ctx');
var IS_CONCAT_SPREADABLE = require('./_wks')('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

},{"./_ctx":28,"./_is-array":52,"./_is-object":54,"./_to-length":118,"./_wks":129}],42:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":10,"./_ctx":28,"./_is-array-iter":51,"./_iter-call":56,"./_to-length":118,"./core.get-iterator-method":130}],43:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],44:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],45:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":32,"./_object-dp":74,"./_property-desc":92}],46:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":43}],47:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":32,"./_dom-create":33,"./_fails":38}],48:[function(require,module,exports){
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":54,"./_set-proto":99}],49:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],50:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":21}],51:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":61,"./_wks":129}],52:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":21}],53:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object');
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"./_is-object":54}],54:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],55:[function(require,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_cof":21,"./_is-object":54,"./_wks":129}],56:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":10}],57:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":45,"./_object-create":73,"./_property-desc":92,"./_set-to-string-tag":101,"./_wks":129}],58:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":36,"./_hide":45,"./_iter-create":57,"./_iterators":61,"./_library":62,"./_object-gpo":81,"./_redefine":94,"./_set-to-string-tag":101,"./_wks":129}],59:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":129}],60:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],61:[function(require,module,exports){
module.exports = {};

},{}],62:[function(require,module,exports){
module.exports = false;

},{}],63:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],64:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var sign = require('./_math-sign');
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"./_math-sign":67}],65:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],66:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

},{}],67:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],68:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":38,"./_has":44,"./_is-object":54,"./_object-dp":74,"./_uid":124}],69:[function(require,module,exports){
var Map = require('./es6.map');
var $export = require('./_export');
var shared = require('./_shared')('metadata');
var store = shared.store || (shared.store = new (require('./es6.weak-map'))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

},{"./_export":36,"./_shared":103,"./es6.map":161,"./es6.weak-map":267}],70:[function(require,module,exports){
var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_cof":21,"./_global":43,"./_task":113}],71:[function(require,module,exports){
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":6}],72:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":38,"./_iobject":50,"./_object-gops":80,"./_object-keys":83,"./_object-pie":84,"./_to-object":119}],73:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":10,"./_dom-create":33,"./_enum-bug-keys":34,"./_html":46,"./_object-dps":75,"./_shared-key":102}],74:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":10,"./_descriptors":32,"./_ie8-dom-define":47,"./_to-primitive":120}],75:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":10,"./_descriptors":32,"./_object-dp":74,"./_object-keys":83}],76:[function(require,module,exports){
'use strict';
// Forced replacement prototype accessors methods
module.exports = require('./_library') || !require('./_fails')(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete require('./_global')[K];
});

},{"./_fails":38,"./_global":43,"./_library":62}],77:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":32,"./_has":44,"./_ie8-dom-define":47,"./_object-pie":84,"./_property-desc":92,"./_to-iobject":117,"./_to-primitive":120}],78:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":79,"./_to-iobject":117}],79:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":34,"./_object-keys-internal":82}],80:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],81:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":44,"./_shared-key":102,"./_to-object":119}],82:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":14,"./_has":44,"./_shared-key":102,"./_to-iobject":117}],83:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":34,"./_object-keys-internal":82}],84:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],85:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":26,"./_export":36,"./_fails":38}],86:[function(require,module,exports){
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
var isEnum = require('./_object-pie').f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};

},{"./_object-keys":83,"./_object-pie":84,"./_to-iobject":117}],87:[function(require,module,exports){
// all object keys, includes non-enumerable and symbols
var gOPN = require('./_object-gopn');
var gOPS = require('./_object-gops');
var anObject = require('./_an-object');
var Reflect = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"./_an-object":10,"./_global":43,"./_object-gopn":79,"./_object-gops":80}],88:[function(require,module,exports){
var $parseFloat = require('./_global').parseFloat;
var $trim = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"./_global":43,"./_string-trim":111,"./_string-ws":112}],89:[function(require,module,exports){
var $parseInt = require('./_global').parseInt;
var $trim = require('./_string-trim').trim;
var ws = require('./_string-ws');
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

},{"./_global":43,"./_string-trim":111,"./_string-ws":112}],90:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],91:[function(require,module,exports){
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":10,"./_is-object":54,"./_new-promise-capability":71}],92:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],93:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":94}],94:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_core":26,"./_global":43,"./_has":44,"./_hide":45,"./_uid":124}],95:[function(require,module,exports){
module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};

},{}],96:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],97:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_a-function":6,"./_ctx":28,"./_export":36,"./_for-of":42}],98:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":36}],99:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":10,"./_ctx":28,"./_is-object":54,"./_object-gopd":77}],100:[function(require,module,exports){
'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_descriptors":32,"./_global":43,"./_object-dp":74,"./_wks":129}],101:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":44,"./_object-dp":74,"./_wks":129}],102:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":103,"./_uid":124}],103:[function(require,module,exports){
var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":26,"./_global":43,"./_library":62}],104:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_a-function":6,"./_an-object":10,"./_wks":129}],105:[function(require,module,exports){
'use strict';
var fails = require('./_fails');

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

},{"./_fails":38}],106:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":31,"./_to-integer":116}],107:[function(require,module,exports){
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp');
var defined = require('./_defined');

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

},{"./_defined":31,"./_is-regexp":55}],108:[function(require,module,exports){
var $export = require('./_export');
var fails = require('./_fails');
var defined = require('./_defined');
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

},{"./_defined":31,"./_export":36,"./_fails":38}],109:[function(require,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length');
var repeat = require('./_string-repeat');
var defined = require('./_defined');

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_defined":31,"./_string-repeat":110,"./_to-length":118}],110:[function(require,module,exports){
'use strict';
var toInteger = require('./_to-integer');
var defined = require('./_defined');

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

},{"./_defined":31,"./_to-integer":116}],111:[function(require,module,exports){
var $export = require('./_export');
var defined = require('./_defined');
var fails = require('./_fails');
var spaces = require('./_string-ws');
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

},{"./_defined":31,"./_export":36,"./_fails":38,"./_string-ws":112}],112:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],113:[function(require,module,exports){
var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":21,"./_ctx":28,"./_dom-create":33,"./_global":43,"./_html":46,"./_invoke":49}],114:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":116}],115:[function(require,module,exports){
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"./_to-integer":116,"./_to-length":118}],116:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],117:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":31,"./_iobject":50}],118:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":116}],119:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":31}],120:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":54}],121:[function(require,module,exports){
'use strict';
if (require('./_descriptors')) {
  var LIBRARY = require('./_library');
  var global = require('./_global');
  var fails = require('./_fails');
  var $export = require('./_export');
  var $typed = require('./_typed');
  var $buffer = require('./_typed-buffer');
  var ctx = require('./_ctx');
  var anInstance = require('./_an-instance');
  var propertyDesc = require('./_property-desc');
  var hide = require('./_hide');
  var redefineAll = require('./_redefine-all');
  var toInteger = require('./_to-integer');
  var toLength = require('./_to-length');
  var toIndex = require('./_to-index');
  var toAbsoluteIndex = require('./_to-absolute-index');
  var toPrimitive = require('./_to-primitive');
  var has = require('./_has');
  var classof = require('./_classof');
  var isObject = require('./_is-object');
  var toObject = require('./_to-object');
  var isArrayIter = require('./_is-array-iter');
  var create = require('./_object-create');
  var getPrototypeOf = require('./_object-gpo');
  var gOPN = require('./_object-gopn').f;
  var getIterFn = require('./core.get-iterator-method');
  var uid = require('./_uid');
  var wks = require('./_wks');
  var createArrayMethod = require('./_array-methods');
  var createArrayIncludes = require('./_array-includes');
  var speciesConstructor = require('./_species-constructor');
  var ArrayIterators = require('./es6.array.iterator');
  var Iterators = require('./_iterators');
  var $iterDetect = require('./_iter-detect');
  var setSpecies = require('./_set-species');
  var arrayFill = require('./_array-fill');
  var arrayCopyWithin = require('./_array-copy-within');
  var $DP = require('./_object-dp');
  var $GOPD = require('./_object-gopd');
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"./_an-instance":9,"./_array-copy-within":11,"./_array-fill":12,"./_array-includes":14,"./_array-methods":15,"./_classof":20,"./_ctx":28,"./_descriptors":32,"./_export":36,"./_fails":38,"./_global":43,"./_has":44,"./_hide":45,"./_is-array-iter":51,"./_is-object":54,"./_iter-detect":59,"./_iterators":61,"./_library":62,"./_object-create":73,"./_object-dp":74,"./_object-gopd":77,"./_object-gopn":79,"./_object-gpo":81,"./_property-desc":92,"./_redefine-all":93,"./_set-species":100,"./_species-constructor":104,"./_to-absolute-index":114,"./_to-index":115,"./_to-integer":116,"./_to-length":118,"./_to-object":119,"./_to-primitive":120,"./_typed":123,"./_typed-buffer":122,"./_uid":124,"./_wks":129,"./core.get-iterator-method":130,"./es6.array.iterator":142}],122:[function(require,module,exports){
'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_an-instance":9,"./_array-fill":12,"./_descriptors":32,"./_fails":38,"./_global":43,"./_hide":45,"./_library":62,"./_object-dp":74,"./_object-gopn":79,"./_redefine-all":93,"./_set-to-string-tag":101,"./_to-index":115,"./_to-integer":116,"./_to-length":118,"./_typed":123}],123:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"./_global":43,"./_hide":45,"./_uid":124}],124:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],125:[function(require,module,exports){
var global = require('./_global');
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';

},{"./_global":43}],126:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":54}],127:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":26,"./_global":43,"./_library":62,"./_object-dp":74,"./_wks-ext":128}],128:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":129}],129:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":43,"./_shared":103,"./_uid":124}],130:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":20,"./_core":26,"./_iterators":61,"./_wks":129}],131:[function(require,module,exports){
// https://github.com/benjamingr/RexExp.escape
var $export = require('./_export');
var $re = require('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });

},{"./_export":36,"./_replacer":95}],132:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });

require('./_add-to-unscopables')('copyWithin');

},{"./_add-to-unscopables":8,"./_array-copy-within":11,"./_export":36}],133:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $every = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":15,"./_export":36,"./_strict-method":105}],134:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { fill: require('./_array-fill') });

require('./_add-to-unscopables')('fill');

},{"./_add-to-unscopables":8,"./_array-fill":12,"./_export":36}],135:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":15,"./_export":36,"./_strict-method":105}],136:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":8,"./_array-methods":15,"./_export":36}],137:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":8,"./_array-methods":15,"./_export":36}],138:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $forEach = require('./_array-methods')(0);
var STRICT = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":15,"./_export":36,"./_strict-method":105}],139:[function(require,module,exports){
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":27,"./_ctx":28,"./_export":36,"./_is-array-iter":51,"./_iter-call":56,"./_iter-detect":59,"./_to-length":118,"./_to-object":119,"./core.get-iterator-method":130}],140:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $indexOf = require('./_array-includes')(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

},{"./_array-includes":14,"./_export":36,"./_strict-method":105}],141:[function(require,module,exports){
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', { isArray: require('./_is-array') });

},{"./_export":36,"./_is-array":52}],142:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":8,"./_iter-define":58,"./_iter-step":60,"./_iterators":61,"./_to-iobject":117}],143:[function(require,module,exports){
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

},{"./_export":36,"./_iobject":50,"./_strict-method":105,"./_to-iobject":117}],144:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});

},{"./_export":36,"./_strict-method":105,"./_to-integer":116,"./_to-iobject":117,"./_to-length":118}],145:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $map = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":15,"./_export":36,"./_strict-method":105}],146:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

},{"./_create-property":27,"./_export":36,"./_fails":38}],147:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

},{"./_array-reduce":16,"./_export":36,"./_strict-method":105}],148:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

},{"./_array-reduce":16,"./_export":36,"./_strict-method":105}],149:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var html = require('./_html');
var cof = require('./_cof');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

},{"./_cof":21,"./_export":36,"./_fails":38,"./_html":46,"./_to-absolute-index":114,"./_to-length":118}],150:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $some = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":15,"./_export":36,"./_strict-method":105}],151:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var fails = require('./_fails');
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

},{"./_a-function":6,"./_export":36,"./_fails":38,"./_strict-method":105,"./_to-object":119}],152:[function(require,module,exports){
require('./_set-species')('Array');

},{"./_set-species":100}],153:[function(require,module,exports){
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });

},{"./_export":36}],154:[function(require,module,exports){
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export');
var toISOString = require('./_date-to-iso-string');

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

},{"./_date-to-iso-string":29,"./_export":36}],155:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

},{"./_export":36,"./_fails":38,"./_to-object":119,"./_to-primitive":120}],156:[function(require,module,exports){
var TO_PRIMITIVE = require('./_wks')('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));

},{"./_date-to-primitive":30,"./_hide":45,"./_wks":129}],157:[function(require,module,exports){
var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  require('./_redefine')(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

},{"./_redefine":94}],158:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', { bind: require('./_bind') });

},{"./_bind":19,"./_export":36}],159:[function(require,module,exports){
'use strict';
var isObject = require('./_is-object');
var getPrototypeOf = require('./_object-gpo');
var HAS_INSTANCE = require('./_wks')('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });

},{"./_is-object":54,"./_object-dp":74,"./_object-gpo":81,"./_wks":129}],160:[function(require,module,exports){
var dP = require('./_object-dp').f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

},{"./_descriptors":32,"./_object-dp":74}],161:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection":25,"./_collection-strong":22,"./_validate-collection":126}],162:[function(require,module,exports){
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export');
var log1p = require('./_math-log1p');
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"./_export":36,"./_math-log1p":65}],163:[function(require,module,exports){
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export');
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

},{"./_export":36}],164:[function(require,module,exports){
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export');
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

},{"./_export":36}],165:[function(require,module,exports){
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export');
var sign = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

},{"./_export":36,"./_math-sign":67}],166:[function(require,module,exports){
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

},{"./_export":36}],167:[function(require,module,exports){
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export');
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

},{"./_export":36}],168:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export');
var $expm1 = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

},{"./_export":36,"./_math-expm1":63}],169:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var $export = require('./_export');

$export($export.S, 'Math', { fround: require('./_math-fround') });

},{"./_export":36,"./_math-fround":64}],170:[function(require,module,exports){
// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = require('./_export');
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

},{"./_export":36}],171:[function(require,module,exports){
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export');
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"./_export":36,"./_fails":38}],172:[function(require,module,exports){
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"./_export":36}],173:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', { log1p: require('./_math-log1p') });

},{"./_export":36,"./_math-log1p":65}],174:[function(require,module,exports){
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

},{"./_export":36}],175:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":36,"./_math-sign":67}],176:[function(require,module,exports){
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

},{"./_export":36,"./_fails":38,"./_math-expm1":63}],177:[function(require,module,exports){
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"./_export":36,"./_math-expm1":63}],178:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":36}],179:[function(require,module,exports){
'use strict';
var global = require('./_global');
var has = require('./_has');
var cof = require('./_cof');
var inheritIfRequired = require('./_inherit-if-required');
var toPrimitive = require('./_to-primitive');
var fails = require('./_fails');
var gOPN = require('./_object-gopn').f;
var gOPD = require('./_object-gopd').f;
var dP = require('./_object-dp').f;
var $trim = require('./_string-trim').trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}

},{"./_cof":21,"./_descriptors":32,"./_fails":38,"./_global":43,"./_has":44,"./_inherit-if-required":48,"./_object-create":73,"./_object-dp":74,"./_object-gopd":77,"./_object-gopn":79,"./_redefine":94,"./_string-trim":111,"./_to-primitive":120}],180:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":36}],181:[function(require,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"./_export":36,"./_global":43}],182:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', { isInteger: require('./_is-integer') });

},{"./_export":36,"./_is-integer":53}],183:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":36}],184:[function(require,module,exports){
// 20.1.2.5 Number.isSafeInteger(number)
var $export = require('./_export');
var isInteger = require('./_is-integer');
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

},{"./_export":36,"./_is-integer":53}],185:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":36}],186:[function(require,module,exports){
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

},{"./_export":36}],187:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

},{"./_export":36,"./_parse-float":88}],188:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

},{"./_export":36,"./_parse-int":89}],189:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toInteger = require('./_to-integer');
var aNumberValue = require('./_a-number-value');
var repeat = require('./_string-repeat');
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});

},{"./_a-number-value":7,"./_export":36,"./_fails":38,"./_string-repeat":110,"./_to-integer":116}],190:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $fails = require('./_fails');
var aNumberValue = require('./_a-number-value');
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

},{"./_a-number-value":7,"./_export":36,"./_fails":38}],191:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":36,"./_object-assign":72}],192:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":36,"./_object-create":73}],193:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_descriptors":32,"./_export":36,"./_object-dps":75}],194:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":32,"./_export":36,"./_object-dp":74}],195:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":54,"./_meta":68,"./_object-sap":85}],196:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":77,"./_object-sap":85,"./_to-iobject":117}],197:[function(require,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function () {
  return require('./_object-gopn-ext').f;
});

},{"./_object-gopn-ext":78,"./_object-sap":85}],198:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_object-gpo":81,"./_object-sap":85,"./_to-object":119}],199:[function(require,module,exports){
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

},{"./_is-object":54,"./_object-sap":85}],200:[function(require,module,exports){
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

},{"./_is-object":54,"./_object-sap":85}],201:[function(require,module,exports){
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

},{"./_is-object":54,"./_object-sap":85}],202:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', { is: require('./_same-value') });

},{"./_export":36,"./_same-value":96}],203:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_object-keys":83,"./_object-sap":85,"./_to-object":119}],204:[function(require,module,exports){
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

},{"./_is-object":54,"./_meta":68,"./_object-sap":85}],205:[function(require,module,exports){
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

},{"./_is-object":54,"./_meta":68,"./_object-sap":85}],206:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":36,"./_set-proto":99}],207:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof');
var test = {};
test[require('./_wks')('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  require('./_redefine')(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

},{"./_classof":20,"./_redefine":94,"./_wks":129}],208:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

},{"./_export":36,"./_parse-float":88}],209:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

},{"./_export":36,"./_parse-int":89}],210:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var userAgent = require('./_user-agent');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_a-function":6,"./_an-instance":9,"./_classof":20,"./_core":26,"./_ctx":28,"./_export":36,"./_for-of":42,"./_global":43,"./_is-object":54,"./_iter-detect":59,"./_library":62,"./_microtask":70,"./_new-promise-capability":71,"./_perform":90,"./_promise-resolve":91,"./_redefine-all":93,"./_set-species":100,"./_set-to-string-tag":101,"./_species-constructor":104,"./_task":113,"./_user-agent":125,"./_wks":129}],211:[function(require,module,exports){
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = require('./_export');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var rApply = (require('./_global').Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

},{"./_a-function":6,"./_an-object":10,"./_export":36,"./_fails":38,"./_global":43}],212:[function(require,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"./_a-function":6,"./_an-object":10,"./_bind":19,"./_export":36,"./_fails":38,"./_global":43,"./_is-object":54,"./_object-create":73}],213:[function(require,module,exports){
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = require('./_object-dp');
var $export = require('./_export');
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":10,"./_export":36,"./_fails":38,"./_object-dp":74,"./_to-primitive":120}],214:[function(require,module,exports){
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = require('./_export');
var gOPD = require('./_object-gopd').f;
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

},{"./_an-object":10,"./_export":36,"./_object-gopd":77}],215:[function(require,module,exports){
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

},{"./_an-object":10,"./_export":36,"./_iter-create":57}],216:[function(require,module,exports){
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = require('./_object-gopd');
var $export = require('./_export');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

},{"./_an-object":10,"./_export":36,"./_object-gopd":77}],217:[function(require,module,exports){
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = require('./_export');
var getProto = require('./_object-gpo');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

},{"./_an-object":10,"./_export":36,"./_object-gpo":81}],218:[function(require,module,exports){
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var isObject = require('./_is-object');
var anObject = require('./_an-object');

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

},{"./_an-object":10,"./_export":36,"./_has":44,"./_is-object":54,"./_object-gopd":77,"./_object-gpo":81}],219:[function(require,module,exports){
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"./_export":36}],220:[function(require,module,exports){
// 26.1.10 Reflect.isExtensible(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

},{"./_an-object":10,"./_export":36}],221:[function(require,module,exports){
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });

},{"./_export":36,"./_own-keys":87}],222:[function(require,module,exports){
// 26.1.12 Reflect.preventExtensions(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":10,"./_export":36}],223:[function(require,module,exports){
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = require('./_export');
var setProto = require('./_set-proto');

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":36,"./_set-proto":99}],224:[function(require,module,exports){
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = require('./_object-dp');
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var createDesc = require('./_property-desc');
var anObject = require('./_an-object');
var isObject = require('./_is-object');

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

},{"./_an-object":10,"./_export":36,"./_has":44,"./_is-object":54,"./_object-dp":74,"./_object-gopd":77,"./_object-gpo":81,"./_property-desc":92}],225:[function(require,module,exports){
var global = require('./_global');
var inheritIfRequired = require('./_inherit-if-required');
var dP = require('./_object-dp').f;
var gOPN = require('./_object-gopn').f;
var isRegExp = require('./_is-regexp');
var $flags = require('./_flags');
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function () {
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');

},{"./_descriptors":32,"./_fails":38,"./_flags":40,"./_global":43,"./_inherit-if-required":48,"./_is-regexp":55,"./_object-dp":74,"./_object-gopn":79,"./_redefine":94,"./_set-species":100,"./_wks":129}],226:[function(require,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});

},{"./_descriptors":32,"./_flags":40,"./_object-dp":74}],227:[function(require,module,exports){
// @@match logic
require('./_fix-re-wks')('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});

},{"./_fix-re-wks":39}],228:[function(require,module,exports){
// @@replace logic
require('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});

},{"./_fix-re-wks":39}],229:[function(require,module,exports){
// @@search logic
require('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});

},{"./_fix-re-wks":39}],230:[function(require,module,exports){
// @@split logic
require('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split) {
  'use strict';
  var isRegExp = require('./_is-regexp');
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});

},{"./_fix-re-wks":39,"./_is-regexp":55}],231:[function(require,module,exports){
'use strict';
require('./es6.regexp.flags');
var anObject = require('./_an-object');
var $flags = require('./_flags');
var DESCRIPTORS = require('./_descriptors');
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (require('./_fails')(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

},{"./_an-object":10,"./_descriptors":32,"./_fails":38,"./_flags":40,"./_redefine":94,"./es6.regexp.flags":226}],232:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection":25,"./_collection-strong":22,"./_validate-collection":126}],233:[function(require,module,exports){
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

},{"./_string-html":108}],234:[function(require,module,exports){
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

},{"./_string-html":108}],235:[function(require,module,exports){
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

},{"./_string-html":108}],236:[function(require,module,exports){
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

},{"./_string-html":108}],237:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $at = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

},{"./_export":36,"./_string-at":106}],238:[function(require,module,exports){
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"./_export":36,"./_fails-is-regexp":37,"./_string-context":107,"./_to-length":118}],239:[function(require,module,exports){
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

},{"./_string-html":108}],240:[function(require,module,exports){
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

},{"./_string-html":108}],241:[function(require,module,exports){
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

},{"./_string-html":108}],242:[function(require,module,exports){
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":36,"./_to-absolute-index":114}],243:[function(require,module,exports){
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = require('./_export');
var context = require('./_string-context');
var INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"./_export":36,"./_fails-is-regexp":37,"./_string-context":107}],244:[function(require,module,exports){
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

},{"./_string-html":108}],245:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":58,"./_string-at":106}],246:[function(require,module,exports){
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

},{"./_string-html":108}],247:[function(require,module,exports){
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});

},{"./_export":36,"./_to-iobject":117,"./_to-length":118}],248:[function(require,module,exports){
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});

},{"./_export":36,"./_string-repeat":110}],249:[function(require,module,exports){
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

},{"./_string-html":108}],250:[function(require,module,exports){
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"./_export":36,"./_fails-is-regexp":37,"./_string-context":107,"./_to-length":118}],251:[function(require,module,exports){
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

},{"./_string-html":108}],252:[function(require,module,exports){
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

},{"./_string-html":108}],253:[function(require,module,exports){
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

},{"./_string-html":108}],254:[function(require,module,exports){
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

},{"./_string-trim":111}],255:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":10,"./_descriptors":32,"./_enum-keys":35,"./_export":36,"./_fails":38,"./_global":43,"./_has":44,"./_hide":45,"./_is-array":52,"./_is-object":54,"./_library":62,"./_meta":68,"./_object-create":73,"./_object-dp":74,"./_object-gopd":77,"./_object-gopn":79,"./_object-gopn-ext":78,"./_object-gops":80,"./_object-keys":83,"./_object-pie":84,"./_property-desc":92,"./_redefine":94,"./_set-to-string-tag":101,"./_shared":103,"./_to-iobject":117,"./_to-primitive":120,"./_uid":124,"./_wks":129,"./_wks-define":127,"./_wks-ext":128}],256:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $typed = require('./_typed');
var buffer = require('./_typed-buffer');
var anObject = require('./_an-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var isObject = require('./_is-object');
var ArrayBuffer = require('./_global').ArrayBuffer;
var speciesConstructor = require('./_species-constructor');
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);

},{"./_an-object":10,"./_export":36,"./_fails":38,"./_global":43,"./_is-object":54,"./_set-species":100,"./_species-constructor":104,"./_to-absolute-index":114,"./_to-length":118,"./_typed":123,"./_typed-buffer":122}],257:[function(require,module,exports){
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});

},{"./_export":36,"./_typed":123,"./_typed-buffer":122}],258:[function(require,module,exports){
require('./_typed-array')('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":121}],259:[function(require,module,exports){
require('./_typed-array')('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":121}],260:[function(require,module,exports){
require('./_typed-array')('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":121}],261:[function(require,module,exports){
require('./_typed-array')('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":121}],262:[function(require,module,exports){
require('./_typed-array')('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":121}],263:[function(require,module,exports){
require('./_typed-array')('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":121}],264:[function(require,module,exports){
require('./_typed-array')('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":121}],265:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":121}],266:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"./_typed-array":121}],267:[function(require,module,exports){
'use strict';
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var fails = require('./_fails');
var validate = require('./_validate-collection');
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_array-methods":15,"./_collection":25,"./_collection-weak":24,"./_fails":38,"./_is-object":54,"./_meta":68,"./_object-assign":72,"./_redefine":94,"./_validate-collection":126}],268:[function(require,module,exports){
'use strict';
var weak = require('./_collection-weak');
var validate = require('./_validate-collection');
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
require('./_collection')(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

},{"./_collection":25,"./_collection-weak":24,"./_validate-collection":126}],269:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var aFunction = require('./_a-function');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

require('./_add-to-unscopables')('flatMap');

},{"./_a-function":6,"./_add-to-unscopables":8,"./_array-species-create":18,"./_export":36,"./_flatten-into-array":41,"./_to-length":118,"./_to-object":119}],270:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

require('./_add-to-unscopables')('flatten');

},{"./_add-to-unscopables":8,"./_array-species-create":18,"./_export":36,"./_flatten-into-array":41,"./_to-integer":116,"./_to-length":118,"./_to-object":119}],271:[function(require,module,exports){
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = require('./_export');
var $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');

},{"./_add-to-unscopables":8,"./_array-includes":14,"./_export":36}],272:[function(require,module,exports){
// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = require('./_export');
var microtask = require('./_microtask')();
var process = require('./_global').process;
var isNode = require('./_cof')(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

},{"./_cof":21,"./_export":36,"./_global":43,"./_microtask":70}],273:[function(require,module,exports){
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export');
var cof = require('./_cof');

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

},{"./_cof":21,"./_export":36}],274:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.G, { global: require('./_global') });

},{"./_export":36,"./_global":43}],275:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
require('./_set-collection-from')('Map');

},{"./_set-collection-from":97}],276:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
require('./_set-collection-of')('Map');

},{"./_set-collection-of":98}],277:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });

},{"./_collection-to-json":23,"./_export":36}],278:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

},{"./_export":36}],279:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });

},{"./_export":36}],280:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

},{"./_export":36}],281:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var scale = require('./_math-scale');
var fround = require('./_math-fround');

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

},{"./_export":36,"./_math-fround":64,"./_math-scale":66}],282:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

},{"./_export":36}],283:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

},{"./_export":36}],284:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

},{"./_export":36}],285:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });

},{"./_export":36}],286:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

},{"./_export":36}],287:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { scale: require('./_math-scale') });

},{"./_export":36,"./_math-scale":66}],288:[function(require,module,exports){
// http://jfbastien.github.io/papers/Math.signbit.html
var $export = require('./_export');

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });

},{"./_export":36}],289:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

},{"./_export":36}],290:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":6,"./_descriptors":32,"./_export":36,"./_object-dp":74,"./_object-forced-pam":76,"./_to-object":119}],291:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":6,"./_descriptors":32,"./_export":36,"./_object-dp":74,"./_object-forced-pam":76,"./_to-object":119}],292:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

},{"./_export":36,"./_object-to-array":86}],293:[function(require,module,exports){
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = require('./_export');
var ownKeys = require('./_own-keys');
var toIObject = require('./_to-iobject');
var gOPD = require('./_object-gopd');
var createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

},{"./_create-property":27,"./_export":36,"./_object-gopd":77,"./_own-keys":87,"./_to-iobject":117}],294:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":32,"./_export":36,"./_object-forced-pam":76,"./_object-gopd":77,"./_object-gpo":81,"./_to-object":119,"./_to-primitive":120}],295:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":32,"./_export":36,"./_object-forced-pam":76,"./_object-gopd":77,"./_object-gpo":81,"./_to-object":119,"./_to-primitive":120}],296:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"./_export":36,"./_object-to-array":86}],297:[function(require,module,exports){
'use strict';
// https://github.com/zenparsing/es-observable
var $export = require('./_export');
var global = require('./_global');
var core = require('./_core');
var microtask = require('./_microtask')();
var OBSERVABLE = require('./_wks')('observable');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var anInstance = require('./_an-instance');
var redefineAll = require('./_redefine-all');
var hide = require('./_hide');
var forOf = require('./_for-of');
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

require('./_set-species')('Observable');

},{"./_a-function":6,"./_an-instance":9,"./_an-object":10,"./_core":26,"./_export":36,"./_for-of":42,"./_global":43,"./_hide":45,"./_microtask":70,"./_redefine-all":93,"./_set-species":100,"./_wks":129}],298:[function(require,module,exports){
// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_core":26,"./_export":36,"./_global":43,"./_promise-resolve":91,"./_species-constructor":104}],299:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

},{"./_export":36,"./_new-promise-capability":71,"./_perform":90}],300:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });

},{"./_an-object":10,"./_metadata":69}],301:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });

},{"./_an-object":10,"./_metadata":69}],302:[function(require,module,exports){
var Set = require('./es6.set');
var from = require('./_array-from-iterable');
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":10,"./_array-from-iterable":13,"./_metadata":69,"./_object-gpo":81,"./es6.set":232}],303:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":10,"./_metadata":69,"./_object-gpo":81}],304:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":10,"./_metadata":69}],305:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":10,"./_metadata":69}],306:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":10,"./_metadata":69,"./_object-gpo":81}],307:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":10,"./_metadata":69}],308:[function(require,module,exports){
var $metadata = require('./_metadata');
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });

},{"./_a-function":6,"./_an-object":10,"./_metadata":69}],309:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":97}],310:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":98}],311:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_collection-to-json":23,"./_export":36}],312:[function(require,module,exports){
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export');
var $at = require('./_string-at')(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

},{"./_export":36,"./_string-at":106}],313:[function(require,module,exports){
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export = require('./_export');
var defined = require('./_defined');
var toLength = require('./_to-length');
var isRegExp = require('./_is-regexp');
var getFlags = require('./_flags');
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

},{"./_defined":31,"./_export":36,"./_flags":40,"./_is-regexp":55,"./_iter-create":57,"./_to-length":118}],314:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

},{"./_export":36,"./_string-pad":109,"./_user-agent":125}],315:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

},{"./_export":36,"./_string-pad":109,"./_user-agent":125}],316:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

},{"./_string-trim":111}],317:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

},{"./_string-trim":111}],318:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":127}],319:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":127}],320:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.S, 'System', { global: require('./_global') });

},{"./_export":36,"./_global":43}],321:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":97}],322:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":98}],323:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
require('./_set-collection-from')('WeakSet');

},{"./_set-collection-from":97}],324:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
require('./_set-collection-of')('WeakSet');

},{"./_set-collection-of":98}],325:[function(require,module,exports){
var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./_global":43,"./_hide":45,"./_iterators":61,"./_object-keys":83,"./_redefine":94,"./_wks":129,"./es6.array.iterator":142}],326:[function(require,module,exports){
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":36,"./_task":113}],327:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var global = require('./_global');
var $export = require('./_export');
var userAgent = require('./_user-agent');
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

},{"./_export":36,"./_global":43,"./_user-agent":125}],328:[function(require,module,exports){
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.array.flat-map');
require('./modules/es7.array.flatten');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.map.of');
require('./modules/es7.set.of');
require('./modules/es7.weak-map.of');
require('./modules/es7.weak-set.of');
require('./modules/es7.map.from');
require('./modules/es7.set.from');
require('./modules/es7.weak-map.from');
require('./modules/es7.weak-set.from');
require('./modules/es7.global');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.clamp');
require('./modules/es7.math.deg-per-rad');
require('./modules/es7.math.degrees');
require('./modules/es7.math.fscale');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.rad-per-deg');
require('./modules/es7.math.radians');
require('./modules/es7.math.scale');
require('./modules/es7.math.umulh');
require('./modules/es7.math.signbit');
require('./modules/es7.promise.finally');
require('./modules/es7.promise.try');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');

},{"./modules/_core":26,"./modules/es6.array.copy-within":132,"./modules/es6.array.every":133,"./modules/es6.array.fill":134,"./modules/es6.array.filter":135,"./modules/es6.array.find":137,"./modules/es6.array.find-index":136,"./modules/es6.array.for-each":138,"./modules/es6.array.from":139,"./modules/es6.array.index-of":140,"./modules/es6.array.is-array":141,"./modules/es6.array.iterator":142,"./modules/es6.array.join":143,"./modules/es6.array.last-index-of":144,"./modules/es6.array.map":145,"./modules/es6.array.of":146,"./modules/es6.array.reduce":148,"./modules/es6.array.reduce-right":147,"./modules/es6.array.slice":149,"./modules/es6.array.some":150,"./modules/es6.array.sort":151,"./modules/es6.array.species":152,"./modules/es6.date.now":153,"./modules/es6.date.to-iso-string":154,"./modules/es6.date.to-json":155,"./modules/es6.date.to-primitive":156,"./modules/es6.date.to-string":157,"./modules/es6.function.bind":158,"./modules/es6.function.has-instance":159,"./modules/es6.function.name":160,"./modules/es6.map":161,"./modules/es6.math.acosh":162,"./modules/es6.math.asinh":163,"./modules/es6.math.atanh":164,"./modules/es6.math.cbrt":165,"./modules/es6.math.clz32":166,"./modules/es6.math.cosh":167,"./modules/es6.math.expm1":168,"./modules/es6.math.fround":169,"./modules/es6.math.hypot":170,"./modules/es6.math.imul":171,"./modules/es6.math.log10":172,"./modules/es6.math.log1p":173,"./modules/es6.math.log2":174,"./modules/es6.math.sign":175,"./modules/es6.math.sinh":176,"./modules/es6.math.tanh":177,"./modules/es6.math.trunc":178,"./modules/es6.number.constructor":179,"./modules/es6.number.epsilon":180,"./modules/es6.number.is-finite":181,"./modules/es6.number.is-integer":182,"./modules/es6.number.is-nan":183,"./modules/es6.number.is-safe-integer":184,"./modules/es6.number.max-safe-integer":185,"./modules/es6.number.min-safe-integer":186,"./modules/es6.number.parse-float":187,"./modules/es6.number.parse-int":188,"./modules/es6.number.to-fixed":189,"./modules/es6.number.to-precision":190,"./modules/es6.object.assign":191,"./modules/es6.object.create":192,"./modules/es6.object.define-properties":193,"./modules/es6.object.define-property":194,"./modules/es6.object.freeze":195,"./modules/es6.object.get-own-property-descriptor":196,"./modules/es6.object.get-own-property-names":197,"./modules/es6.object.get-prototype-of":198,"./modules/es6.object.is":202,"./modules/es6.object.is-extensible":199,"./modules/es6.object.is-frozen":200,"./modules/es6.object.is-sealed":201,"./modules/es6.object.keys":203,"./modules/es6.object.prevent-extensions":204,"./modules/es6.object.seal":205,"./modules/es6.object.set-prototype-of":206,"./modules/es6.object.to-string":207,"./modules/es6.parse-float":208,"./modules/es6.parse-int":209,"./modules/es6.promise":210,"./modules/es6.reflect.apply":211,"./modules/es6.reflect.construct":212,"./modules/es6.reflect.define-property":213,"./modules/es6.reflect.delete-property":214,"./modules/es6.reflect.enumerate":215,"./modules/es6.reflect.get":218,"./modules/es6.reflect.get-own-property-descriptor":216,"./modules/es6.reflect.get-prototype-of":217,"./modules/es6.reflect.has":219,"./modules/es6.reflect.is-extensible":220,"./modules/es6.reflect.own-keys":221,"./modules/es6.reflect.prevent-extensions":222,"./modules/es6.reflect.set":224,"./modules/es6.reflect.set-prototype-of":223,"./modules/es6.regexp.constructor":225,"./modules/es6.regexp.flags":226,"./modules/es6.regexp.match":227,"./modules/es6.regexp.replace":228,"./modules/es6.regexp.search":229,"./modules/es6.regexp.split":230,"./modules/es6.regexp.to-string":231,"./modules/es6.set":232,"./modules/es6.string.anchor":233,"./modules/es6.string.big":234,"./modules/es6.string.blink":235,"./modules/es6.string.bold":236,"./modules/es6.string.code-point-at":237,"./modules/es6.string.ends-with":238,"./modules/es6.string.fixed":239,"./modules/es6.string.fontcolor":240,"./modules/es6.string.fontsize":241,"./modules/es6.string.from-code-point":242,"./modules/es6.string.includes":243,"./modules/es6.string.italics":244,"./modules/es6.string.iterator":245,"./modules/es6.string.link":246,"./modules/es6.string.raw":247,"./modules/es6.string.repeat":248,"./modules/es6.string.small":249,"./modules/es6.string.starts-with":250,"./modules/es6.string.strike":251,"./modules/es6.string.sub":252,"./modules/es6.string.sup":253,"./modules/es6.string.trim":254,"./modules/es6.symbol":255,"./modules/es6.typed.array-buffer":256,"./modules/es6.typed.data-view":257,"./modules/es6.typed.float32-array":258,"./modules/es6.typed.float64-array":259,"./modules/es6.typed.int16-array":260,"./modules/es6.typed.int32-array":261,"./modules/es6.typed.int8-array":262,"./modules/es6.typed.uint16-array":263,"./modules/es6.typed.uint32-array":264,"./modules/es6.typed.uint8-array":265,"./modules/es6.typed.uint8-clamped-array":266,"./modules/es6.weak-map":267,"./modules/es6.weak-set":268,"./modules/es7.array.flat-map":269,"./modules/es7.array.flatten":270,"./modules/es7.array.includes":271,"./modules/es7.asap":272,"./modules/es7.error.is-error":273,"./modules/es7.global":274,"./modules/es7.map.from":275,"./modules/es7.map.of":276,"./modules/es7.map.to-json":277,"./modules/es7.math.clamp":278,"./modules/es7.math.deg-per-rad":279,"./modules/es7.math.degrees":280,"./modules/es7.math.fscale":281,"./modules/es7.math.iaddh":282,"./modules/es7.math.imulh":283,"./modules/es7.math.isubh":284,"./modules/es7.math.rad-per-deg":285,"./modules/es7.math.radians":286,"./modules/es7.math.scale":287,"./modules/es7.math.signbit":288,"./modules/es7.math.umulh":289,"./modules/es7.object.define-getter":290,"./modules/es7.object.define-setter":291,"./modules/es7.object.entries":292,"./modules/es7.object.get-own-property-descriptors":293,"./modules/es7.object.lookup-getter":294,"./modules/es7.object.lookup-setter":295,"./modules/es7.object.values":296,"./modules/es7.observable":297,"./modules/es7.promise.finally":298,"./modules/es7.promise.try":299,"./modules/es7.reflect.define-metadata":300,"./modules/es7.reflect.delete-metadata":301,"./modules/es7.reflect.get-metadata":303,"./modules/es7.reflect.get-metadata-keys":302,"./modules/es7.reflect.get-own-metadata":305,"./modules/es7.reflect.get-own-metadata-keys":304,"./modules/es7.reflect.has-metadata":306,"./modules/es7.reflect.has-own-metadata":307,"./modules/es7.reflect.metadata":308,"./modules/es7.set.from":309,"./modules/es7.set.of":310,"./modules/es7.set.to-json":311,"./modules/es7.string.at":312,"./modules/es7.string.match-all":313,"./modules/es7.string.pad-end":314,"./modules/es7.string.pad-start":315,"./modules/es7.string.trim-left":316,"./modules/es7.string.trim-right":317,"./modules/es7.symbol.async-iterator":318,"./modules/es7.symbol.observable":319,"./modules/es7.system.global":320,"./modules/es7.weak-map.from":321,"./modules/es7.weak-map.of":322,"./modules/es7.weak-set.from":323,"./modules/es7.weak-set.of":324,"./modules/web.dom.iterable":325,"./modules/web.immediate":326,"./modules/web.timers":327}],329:[function(require,module,exports){
/**
 * cssfilter
 *
 * @author 老雷<leizongmin@gmail.com>
 */

var DEFAULT = require('./default');
var parseStyle = require('./parser');
var _ = require('./util');


/**
 * 返回值是否为空
 *
 * @param {Object} obj
 * @return {Boolean}
 */
function isNull (obj) {
  return (obj === undefined || obj === null);
}

/**
 * 浅拷贝对象
 *
 * @param {Object} obj
 * @return {Object}
 */
function shallowCopyObject (obj) {
  var ret = {};
  for (var i in obj) {
    ret[i] = obj[i];
  }
  return ret;
}

/**
 * 创建CSS过滤器
 *
 * @param {Object} options
 *   - {Object} whiteList
 *   - {Function} onAttr
 *   - {Function} onIgnoreAttr
 *   - {Function} safeAttrValue
 */
function FilterCSS (options) {
  options = shallowCopyObject(options || {});
  options.whiteList = options.whiteList || DEFAULT.whiteList;
  options.onAttr = options.onAttr || DEFAULT.onAttr;
  options.onIgnoreAttr = options.onIgnoreAttr || DEFAULT.onIgnoreAttr;
  options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
  this.options = options;
}

FilterCSS.prototype.process = function (css) {
  // 兼容各种奇葩输入
  css = css || '';
  css = css.toString();
  if (!css) return '';

  var me = this;
  var options = me.options;
  var whiteList = options.whiteList;
  var onAttr = options.onAttr;
  var onIgnoreAttr = options.onIgnoreAttr;
  var safeAttrValue = options.safeAttrValue;

  var retCSS = parseStyle(css, function (sourcePosition, position, name, value, source) {

    var check = whiteList[name];
    var isWhite = false;
    if (check === true) isWhite = check;
    else if (typeof check === 'function') isWhite = check(value);
    else if (check instanceof RegExp) isWhite = check.test(value);
    if (isWhite !== true) isWhite = false;

    // 如果过滤后 value 为空则直接忽略
    value = safeAttrValue(name, value);
    if (!value) return;

    var opts = {
      position: position,
      sourcePosition: sourcePosition,
      source: source,
      isWhite: isWhite
    };

    if (isWhite) {

      var ret = onAttr(name, value, opts);
      if (isNull(ret)) {
        return name + ':' + value;
      } else {
        return ret;
      }

    } else {

      var ret = onIgnoreAttr(name, value, opts);
      if (!isNull(ret)) {
        return ret;
      }

    }
  });

  return retCSS;
};


module.exports = FilterCSS;

},{"./default":330,"./parser":332,"./util":333}],330:[function(require,module,exports){
/**
 * cssfilter
 *
 * @author 老雷<leizongmin@gmail.com>
 */

function getDefaultWhiteList () {
  // 白名单值说明：
  // true: 允许该属性
  // Function: function (val) { } 返回true表示允许该属性，其他值均表示不允许
  // RegExp: regexp.test(val) 返回true表示允许该属性，其他值均表示不允许
  // 除上面列出的值外均表示不允许
  var whiteList = {};

  whiteList['align-content'] = false; // default: auto
  whiteList['align-items'] = false; // default: auto
  whiteList['align-self'] = false; // default: auto
  whiteList['alignment-adjust'] = false; // default: auto
  whiteList['alignment-baseline'] = false; // default: baseline
  whiteList['all'] = false; // default: depending on individual properties
  whiteList['anchor-point'] = false; // default: none
  whiteList['animation'] = false; // default: depending on individual properties
  whiteList['animation-delay'] = false; // default: 0
  whiteList['animation-direction'] = false; // default: normal
  whiteList['animation-duration'] = false; // default: 0
  whiteList['animation-fill-mode'] = false; // default: none
  whiteList['animation-iteration-count'] = false; // default: 1
  whiteList['animation-name'] = false; // default: none
  whiteList['animation-play-state'] = false; // default: running
  whiteList['animation-timing-function'] = false; // default: ease
  whiteList['azimuth'] = false; // default: center
  whiteList['backface-visibility'] = false; // default: visible
  whiteList['background'] = true; // default: depending on individual properties
  whiteList['background-attachment'] = true; // default: scroll
  whiteList['background-clip'] = true; // default: border-box
  whiteList['background-color'] = true; // default: transparent
  whiteList['background-image'] = true; // default: none
  whiteList['background-origin'] = true; // default: padding-box
  whiteList['background-position'] = true; // default: 0% 0%
  whiteList['background-repeat'] = true; // default: repeat
  whiteList['background-size'] = true; // default: auto
  whiteList['baseline-shift'] = false; // default: baseline
  whiteList['binding'] = false; // default: none
  whiteList['bleed'] = false; // default: 6pt
  whiteList['bookmark-label'] = false; // default: content()
  whiteList['bookmark-level'] = false; // default: none
  whiteList['bookmark-state'] = false; // default: open
  whiteList['border'] = true; // default: depending on individual properties
  whiteList['border-bottom'] = true; // default: depending on individual properties
  whiteList['border-bottom-color'] = true; // default: current color
  whiteList['border-bottom-left-radius'] = true; // default: 0
  whiteList['border-bottom-right-radius'] = true; // default: 0
  whiteList['border-bottom-style'] = true; // default: none
  whiteList['border-bottom-width'] = true; // default: medium
  whiteList['border-collapse'] = true; // default: separate
  whiteList['border-color'] = true; // default: depending on individual properties
  whiteList['border-image'] = true; // default: none
  whiteList['border-image-outset'] = true; // default: 0
  whiteList['border-image-repeat'] = true; // default: stretch
  whiteList['border-image-slice'] = true; // default: 100%
  whiteList['border-image-source'] = true; // default: none
  whiteList['border-image-width'] = true; // default: 1
  whiteList['border-left'] = true; // default: depending on individual properties
  whiteList['border-left-color'] = true; // default: current color
  whiteList['border-left-style'] = true; // default: none
  whiteList['border-left-width'] = true; // default: medium
  whiteList['border-radius'] = true; // default: 0
  whiteList['border-right'] = true; // default: depending on individual properties
  whiteList['border-right-color'] = true; // default: current color
  whiteList['border-right-style'] = true; // default: none
  whiteList['border-right-width'] = true; // default: medium
  whiteList['border-spacing'] = true; // default: 0
  whiteList['border-style'] = true; // default: depending on individual properties
  whiteList['border-top'] = true; // default: depending on individual properties
  whiteList['border-top-color'] = true; // default: current color
  whiteList['border-top-left-radius'] = true; // default: 0
  whiteList['border-top-right-radius'] = true; // default: 0
  whiteList['border-top-style'] = true; // default: none
  whiteList['border-top-width'] = true; // default: medium
  whiteList['border-width'] = true; // default: depending on individual properties
  whiteList['bottom'] = false; // default: auto
  whiteList['box-decoration-break'] = true; // default: slice
  whiteList['box-shadow'] = true; // default: none
  whiteList['box-sizing'] = true; // default: content-box
  whiteList['box-snap'] = true; // default: none
  whiteList['box-suppress'] = true; // default: show
  whiteList['break-after'] = true; // default: auto
  whiteList['break-before'] = true; // default: auto
  whiteList['break-inside'] = true; // default: auto
  whiteList['caption-side'] = false; // default: top
  whiteList['chains'] = false; // default: none
  whiteList['clear'] = true; // default: none
  whiteList['clip'] = false; // default: auto
  whiteList['clip-path'] = false; // default: none
  whiteList['clip-rule'] = false; // default: nonzero
  whiteList['color'] = true; // default: implementation dependent
  whiteList['color-interpolation-filters'] = true; // default: auto
  whiteList['column-count'] = false; // default: auto
  whiteList['column-fill'] = false; // default: balance
  whiteList['column-gap'] = false; // default: normal
  whiteList['column-rule'] = false; // default: depending on individual properties
  whiteList['column-rule-color'] = false; // default: current color
  whiteList['column-rule-style'] = false; // default: medium
  whiteList['column-rule-width'] = false; // default: medium
  whiteList['column-span'] = false; // default: none
  whiteList['column-width'] = false; // default: auto
  whiteList['columns'] = false; // default: depending on individual properties
  whiteList['contain'] = false; // default: none
  whiteList['content'] = false; // default: normal
  whiteList['counter-increment'] = false; // default: none
  whiteList['counter-reset'] = false; // default: none
  whiteList['counter-set'] = false; // default: none
  whiteList['crop'] = false; // default: auto
  whiteList['cue'] = false; // default: depending on individual properties
  whiteList['cue-after'] = false; // default: none
  whiteList['cue-before'] = false; // default: none
  whiteList['cursor'] = false; // default: auto
  whiteList['direction'] = false; // default: ltr
  whiteList['display'] = true; // default: depending on individual properties
  whiteList['display-inside'] = true; // default: auto
  whiteList['display-list'] = true; // default: none
  whiteList['display-outside'] = true; // default: inline-level
  whiteList['dominant-baseline'] = false; // default: auto
  whiteList['elevation'] = false; // default: level
  whiteList['empty-cells'] = false; // default: show
  whiteList['filter'] = false; // default: none
  whiteList['flex'] = false; // default: depending on individual properties
  whiteList['flex-basis'] = false; // default: auto
  whiteList['flex-direction'] = false; // default: row
  whiteList['flex-flow'] = false; // default: depending on individual properties
  whiteList['flex-grow'] = false; // default: 0
  whiteList['flex-shrink'] = false; // default: 1
  whiteList['flex-wrap'] = false; // default: nowrap
  whiteList['float'] = false; // default: none
  whiteList['float-offset'] = false; // default: 0 0
  whiteList['flood-color'] = false; // default: black
  whiteList['flood-opacity'] = false; // default: 1
  whiteList['flow-from'] = false; // default: none
  whiteList['flow-into'] = false; // default: none
  whiteList['font'] = true; // default: depending on individual properties
  whiteList['font-family'] = true; // default: implementation dependent
  whiteList['font-feature-settings'] = true; // default: normal
  whiteList['font-kerning'] = true; // default: auto
  whiteList['font-language-override'] = true; // default: normal
  whiteList['font-size'] = true; // default: medium
  whiteList['font-size-adjust'] = true; // default: none
  whiteList['font-stretch'] = true; // default: normal
  whiteList['font-style'] = true; // default: normal
  whiteList['font-synthesis'] = true; // default: weight style
  whiteList['font-variant'] = true; // default: normal
  whiteList['font-variant-alternates'] = true; // default: normal
  whiteList['font-variant-caps'] = true; // default: normal
  whiteList['font-variant-east-asian'] = true; // default: normal
  whiteList['font-variant-ligatures'] = true; // default: normal
  whiteList['font-variant-numeric'] = true; // default: normal
  whiteList['font-variant-position'] = true; // default: normal
  whiteList['font-weight'] = true; // default: normal
  whiteList['grid'] = false; // default: depending on individual properties
  whiteList['grid-area'] = false; // default: depending on individual properties
  whiteList['grid-auto-columns'] = false; // default: auto
  whiteList['grid-auto-flow'] = false; // default: none
  whiteList['grid-auto-rows'] = false; // default: auto
  whiteList['grid-column'] = false; // default: depending on individual properties
  whiteList['grid-column-end'] = false; // default: auto
  whiteList['grid-column-start'] = false; // default: auto
  whiteList['grid-row'] = false; // default: depending on individual properties
  whiteList['grid-row-end'] = false; // default: auto
  whiteList['grid-row-start'] = false; // default: auto
  whiteList['grid-template'] = false; // default: depending on individual properties
  whiteList['grid-template-areas'] = false; // default: none
  whiteList['grid-template-columns'] = false; // default: none
  whiteList['grid-template-rows'] = false; // default: none
  whiteList['hanging-punctuation'] = false; // default: none
  whiteList['height'] = true; // default: auto
  whiteList['hyphens'] = false; // default: manual
  whiteList['icon'] = false; // default: auto
  whiteList['image-orientation'] = false; // default: auto
  whiteList['image-resolution'] = false; // default: normal
  whiteList['ime-mode'] = false; // default: auto
  whiteList['initial-letters'] = false; // default: normal
  whiteList['inline-box-align'] = false; // default: last
  whiteList['justify-content'] = false; // default: auto
  whiteList['justify-items'] = false; // default: auto
  whiteList['justify-self'] = false; // default: auto
  whiteList['left'] = false; // default: auto
  whiteList['letter-spacing'] = true; // default: normal
  whiteList['lighting-color'] = true; // default: white
  whiteList['line-box-contain'] = false; // default: block inline replaced
  whiteList['line-break'] = false; // default: auto
  whiteList['line-grid'] = false; // default: match-parent
  whiteList['line-height'] = false; // default: normal
  whiteList['line-snap'] = false; // default: none
  whiteList['line-stacking'] = false; // default: depending on individual properties
  whiteList['line-stacking-ruby'] = false; // default: exclude-ruby
  whiteList['line-stacking-shift'] = false; // default: consider-shifts
  whiteList['line-stacking-strategy'] = false; // default: inline-line-height
  whiteList['list-style'] = true; // default: depending on individual properties
  whiteList['list-style-image'] = true; // default: none
  whiteList['list-style-position'] = true; // default: outside
  whiteList['list-style-type'] = true; // default: disc
  whiteList['margin'] = true; // default: depending on individual properties
  whiteList['margin-bottom'] = true; // default: 0
  whiteList['margin-left'] = true; // default: 0
  whiteList['margin-right'] = true; // default: 0
  whiteList['margin-top'] = true; // default: 0
  whiteList['marker-offset'] = false; // default: auto
  whiteList['marker-side'] = false; // default: list-item
  whiteList['marks'] = false; // default: none
  whiteList['mask'] = false; // default: border-box
  whiteList['mask-box'] = false; // default: see individual properties
  whiteList['mask-box-outset'] = false; // default: 0
  whiteList['mask-box-repeat'] = false; // default: stretch
  whiteList['mask-box-slice'] = false; // default: 0 fill
  whiteList['mask-box-source'] = false; // default: none
  whiteList['mask-box-width'] = false; // default: auto
  whiteList['mask-clip'] = false; // default: border-box
  whiteList['mask-image'] = false; // default: none
  whiteList['mask-origin'] = false; // default: border-box
  whiteList['mask-position'] = false; // default: center
  whiteList['mask-repeat'] = false; // default: no-repeat
  whiteList['mask-size'] = false; // default: border-box
  whiteList['mask-source-type'] = false; // default: auto
  whiteList['mask-type'] = false; // default: luminance
  whiteList['max-height'] = true; // default: none
  whiteList['max-lines'] = false; // default: none
  whiteList['max-width'] = true; // default: none
  whiteList['min-height'] = true; // default: 0
  whiteList['min-width'] = true; // default: 0
  whiteList['move-to'] = false; // default: normal
  whiteList['nav-down'] = false; // default: auto
  whiteList['nav-index'] = false; // default: auto
  whiteList['nav-left'] = false; // default: auto
  whiteList['nav-right'] = false; // default: auto
  whiteList['nav-up'] = false; // default: auto
  whiteList['object-fit'] = false; // default: fill
  whiteList['object-position'] = false; // default: 50% 50%
  whiteList['opacity'] = false; // default: 1
  whiteList['order'] = false; // default: 0
  whiteList['orphans'] = false; // default: 2
  whiteList['outline'] = false; // default: depending on individual properties
  whiteList['outline-color'] = false; // default: invert
  whiteList['outline-offset'] = false; // default: 0
  whiteList['outline-style'] = false; // default: none
  whiteList['outline-width'] = false; // default: medium
  whiteList['overflow'] = false; // default: depending on individual properties
  whiteList['overflow-wrap'] = false; // default: normal
  whiteList['overflow-x'] = false; // default: visible
  whiteList['overflow-y'] = false; // default: visible
  whiteList['padding'] = true; // default: depending on individual properties
  whiteList['padding-bottom'] = true; // default: 0
  whiteList['padding-left'] = true; // default: 0
  whiteList['padding-right'] = true; // default: 0
  whiteList['padding-top'] = true; // default: 0
  whiteList['page'] = false; // default: auto
  whiteList['page-break-after'] = false; // default: auto
  whiteList['page-break-before'] = false; // default: auto
  whiteList['page-break-inside'] = false; // default: auto
  whiteList['page-policy'] = false; // default: start
  whiteList['pause'] = false; // default: implementation dependent
  whiteList['pause-after'] = false; // default: implementation dependent
  whiteList['pause-before'] = false; // default: implementation dependent
  whiteList['perspective'] = false; // default: none
  whiteList['perspective-origin'] = false; // default: 50% 50%
  whiteList['pitch'] = false; // default: medium
  whiteList['pitch-range'] = false; // default: 50
  whiteList['play-during'] = false; // default: auto
  whiteList['position'] = false; // default: static
  whiteList['presentation-level'] = false; // default: 0
  whiteList['quotes'] = false; // default: text
  whiteList['region-fragment'] = false; // default: auto
  whiteList['resize'] = false; // default: none
  whiteList['rest'] = false; // default: depending on individual properties
  whiteList['rest-after'] = false; // default: none
  whiteList['rest-before'] = false; // default: none
  whiteList['richness'] = false; // default: 50
  whiteList['right'] = false; // default: auto
  whiteList['rotation'] = false; // default: 0
  whiteList['rotation-point'] = false; // default: 50% 50%
  whiteList['ruby-align'] = false; // default: auto
  whiteList['ruby-merge'] = false; // default: separate
  whiteList['ruby-position'] = false; // default: before
  whiteList['shape-image-threshold'] = false; // default: 0.0
  whiteList['shape-outside'] = false; // default: none
  whiteList['shape-margin'] = false; // default: 0
  whiteList['size'] = false; // default: auto
  whiteList['speak'] = false; // default: auto
  whiteList['speak-as'] = false; // default: normal
  whiteList['speak-header'] = false; // default: once
  whiteList['speak-numeral'] = false; // default: continuous
  whiteList['speak-punctuation'] = false; // default: none
  whiteList['speech-rate'] = false; // default: medium
  whiteList['stress'] = false; // default: 50
  whiteList['string-set'] = false; // default: none
  whiteList['tab-size'] = false; // default: 8
  whiteList['table-layout'] = false; // default: auto
  whiteList['text-align'] = true; // default: start
  whiteList['text-align-last'] = true; // default: auto
  whiteList['text-combine-upright'] = true; // default: none
  whiteList['text-decoration'] = true; // default: none
  whiteList['text-decoration-color'] = true; // default: currentColor
  whiteList['text-decoration-line'] = true; // default: none
  whiteList['text-decoration-skip'] = true; // default: objects
  whiteList['text-decoration-style'] = true; // default: solid
  whiteList['text-emphasis'] = true; // default: depending on individual properties
  whiteList['text-emphasis-color'] = true; // default: currentColor
  whiteList['text-emphasis-position'] = true; // default: over right
  whiteList['text-emphasis-style'] = true; // default: none
  whiteList['text-height'] = true; // default: auto
  whiteList['text-indent'] = true; // default: 0
  whiteList['text-justify'] = true; // default: auto
  whiteList['text-orientation'] = true; // default: mixed
  whiteList['text-overflow'] = true; // default: clip
  whiteList['text-shadow'] = true; // default: none
  whiteList['text-space-collapse'] = true; // default: collapse
  whiteList['text-transform'] = true; // default: none
  whiteList['text-underline-position'] = true; // default: auto
  whiteList['text-wrap'] = true; // default: normal
  whiteList['top'] = false; // default: auto
  whiteList['transform'] = false; // default: none
  whiteList['transform-origin'] = false; // default: 50% 50% 0
  whiteList['transform-style'] = false; // default: flat
  whiteList['transition'] = false; // default: depending on individual properties
  whiteList['transition-delay'] = false; // default: 0s
  whiteList['transition-duration'] = false; // default: 0s
  whiteList['transition-property'] = false; // default: all
  whiteList['transition-timing-function'] = false; // default: ease
  whiteList['unicode-bidi'] = false; // default: normal
  whiteList['vertical-align'] = false; // default: baseline
  whiteList['visibility'] = false; // default: visible
  whiteList['voice-balance'] = false; // default: center
  whiteList['voice-duration'] = false; // default: auto
  whiteList['voice-family'] = false; // default: implementation dependent
  whiteList['voice-pitch'] = false; // default: medium
  whiteList['voice-range'] = false; // default: medium
  whiteList['voice-rate'] = false; // default: normal
  whiteList['voice-stress'] = false; // default: normal
  whiteList['voice-volume'] = false; // default: medium
  whiteList['volume'] = false; // default: medium
  whiteList['white-space'] = false; // default: normal
  whiteList['widows'] = false; // default: 2
  whiteList['width'] = true; // default: auto
  whiteList['will-change'] = false; // default: auto
  whiteList['word-break'] = true; // default: normal
  whiteList['word-spacing'] = true; // default: normal
  whiteList['word-wrap'] = true; // default: normal
  whiteList['wrap-flow'] = false; // default: auto
  whiteList['wrap-through'] = false; // default: wrap
  whiteList['writing-mode'] = false; // default: horizontal-tb
  whiteList['z-index'] = false; // default: auto

  return whiteList;
}


/**
 * 匹配到白名单上的一个属性时
 *
 * @param {String} name
 * @param {String} value
 * @param {Object} options
 * @return {String}
 */
function onAttr (name, value, options) {
  // do nothing
}

/**
 * 匹配到不在白名单上的一个属性时
 *
 * @param {String} name
 * @param {String} value
 * @param {Object} options
 * @return {String}
 */
function onIgnoreAttr (name, value, options) {
  // do nothing
}

var REGEXP_URL_JAVASCRIPT = /javascript\s*\:/img;

/**
 * 过滤属性值
 *
 * @param {String} name
 * @param {String} value
 * @return {String}
 */
function safeAttrValue(name, value) {
  if (REGEXP_URL_JAVASCRIPT.test(value)) return '';
  return value;
}


exports.whiteList = getDefaultWhiteList();
exports.getDefaultWhiteList = getDefaultWhiteList;
exports.onAttr = onAttr;
exports.onIgnoreAttr = onIgnoreAttr;
exports.safeAttrValue = safeAttrValue;

},{}],331:[function(require,module,exports){
/**
 * cssfilter
 *
 * @author 老雷<leizongmin@gmail.com>
 */

var DEFAULT = require('./default');
var FilterCSS = require('./css');


/**
 * XSS过滤
 *
 * @param {String} css 要过滤的CSS代码
 * @param {Object} options 选项：whiteList, onAttr, onIgnoreAttr
 * @return {String}
 */
function filterCSS (html, options) {
  var xss = new FilterCSS(options);
  return xss.process(html);
}


// 输出
exports = module.exports = filterCSS;
exports.FilterCSS = FilterCSS;
for (var i in DEFAULT) exports[i] = DEFAULT[i];

// 在浏览器端使用
if (typeof window !== 'undefined') {
  window.filterCSS = module.exports;
}

},{"./css":329,"./default":330}],332:[function(require,module,exports){
/**
 * cssfilter
 *
 * @author 老雷<leizongmin@gmail.com>
 */

var _ = require('./util');


/**
 * 解析style
 *
 * @param {String} css
 * @param {Function} onAttr 处理属性的函数
 *   参数格式： function (sourcePosition, position, name, value, source)
 * @return {String}
 */
function parseStyle (css, onAttr) {
  css = _.trimRight(css);
  if (css[css.length - 1] !== ';') css += ';';
  var cssLength = css.length;
  var isParenthesisOpen = false;
  var lastPos = 0;
  var i = 0;
  var retCSS = '';

  function addNewAttr () {
    // 如果没有正常的闭合圆括号，则直接忽略当前属性
    if (!isParenthesisOpen) {
      var source = _.trim(css.slice(lastPos, i));
      var j = source.indexOf(':');
      if (j !== -1) {
        var name = _.trim(source.slice(0, j));
        var value = _.trim(source.slice(j + 1));
        // 必须有属性名称
        if (name) {
          var ret = onAttr(lastPos, retCSS.length, name, value, source);
          if (ret) retCSS += ret + '; ';
        }
      }
    }
    lastPos = i + 1;
  }

  for (; i < cssLength; i++) {
    var c = css[i];
    if (c === '/' && css[i + 1] === '*') {
      // 备注开始
      var j = css.indexOf('*/', i + 2);
      // 如果没有正常的备注结束，则后面的部分全部跳过
      if (j === -1) break;
      // 直接将当前位置调到备注结尾，并且初始化状态
      i = j + 1;
      lastPos = i + 1;
      isParenthesisOpen = false;
    } else if (c === '(') {
      isParenthesisOpen = true;
    } else if (c === ')') {
      isParenthesisOpen = false;
    } else if (c === ';') {
      if (isParenthesisOpen) {
        // 在圆括号里面，忽略
      } else {
        addNewAttr();
      }
    } else if (c === '\n') {
      addNewAttr();
    }
  }

  return _.trim(retCSS);
}

module.exports = parseStyle;

},{"./util":333}],333:[function(require,module,exports){
module.exports = {
  indexOf: function (arr, item) {
    var i, j;
    if (Array.prototype.indexOf) {
      return arr.indexOf(item);
    }
    for (i = 0, j = arr.length; i < j; i++) {
      if (arr[i] === item) {
        return i;
      }
    }
    return -1;
  },
  forEach: function (arr, fn, scope) {
    var i, j;
    if (Array.prototype.forEach) {
      return arr.forEach(fn, scope);
    }
    for (i = 0, j = arr.length; i < j; i++) {
      fn.call(scope, arr[i], i, arr);
    }
  },
  trim: function (str) {
    if (String.prototype.trim) {
      return str.trim();
    }
    return str.replace(/(^\s*)|(\s*$)/g, '');
  },
  trimRight: function (str) {
    if (String.prototype.trimRight) {
      return str.trimRight();
    }
    return str.replace(/(\s*$)/g, '');
  }
};

},{}],334:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],335:[function(require,module,exports){
/**
 * default settings
 *
 * @author Zongmin Lei<leizongmin@gmail.com>
 */

var FilterCSS = require("cssfilter").FilterCSS;
var getDefaultCSSWhiteList = require("cssfilter").getDefaultWhiteList;
var _ = require("./util");

function getDefaultWhiteList() {
  return {
    a: ["target", "href", "title"],
    abbr: ["title"],
    address: [],
    area: ["shape", "coords", "href", "alt"],
    article: [],
    aside: [],
    audio: ["autoplay", "controls", "loop", "preload", "src"],
    b: [],
    bdi: ["dir"],
    bdo: ["dir"],
    big: [],
    blockquote: ["cite"],
    br: [],
    caption: [],
    center: [],
    cite: [],
    code: [],
    col: ["align", "valign", "span", "width"],
    colgroup: ["align", "valign", "span", "width"],
    dd: [],
    del: ["datetime"],
    details: ["open"],
    div: [],
    dl: [],
    dt: [],
    em: [],
    font: ["color", "size", "face"],
    footer: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    header: [],
    hr: [],
    i: [],
    img: ["src", "alt", "title", "width", "height"],
    ins: ["datetime"],
    li: [],
    mark: [],
    nav: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    section: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    table: ["width", "border", "align", "valign"],
    tbody: ["align", "valign"],
    td: ["width", "rowspan", "colspan", "align", "valign"],
    tfoot: ["align", "valign"],
    th: ["width", "rowspan", "colspan", "align", "valign"],
    thead: ["align", "valign"],
    tr: ["rowspan", "align", "valign"],
    tt: [],
    u: [],
    ul: [],
    video: ["autoplay", "controls", "loop", "preload", "src", "height", "width"]
  };
}

var defaultCSSFilter = new FilterCSS();

/**
 * default onTag function
 *
 * @param {String} tag
 * @param {String} html
 * @param {Object} options
 * @return {String}
 */
function onTag(tag, html, options) {
  // do nothing
}

/**
 * default onIgnoreTag function
 *
 * @param {String} tag
 * @param {String} html
 * @param {Object} options
 * @return {String}
 */
function onIgnoreTag(tag, html, options) {
  // do nothing
}

/**
 * default onTagAttr function
 *
 * @param {String} tag
 * @param {String} name
 * @param {String} value
 * @return {String}
 */
function onTagAttr(tag, name, value) {
  // do nothing
}

/**
 * default onIgnoreTagAttr function
 *
 * @param {String} tag
 * @param {String} name
 * @param {String} value
 * @return {String}
 */
function onIgnoreTagAttr(tag, name, value) {
  // do nothing
}

/**
 * default escapeHtml function
 *
 * @param {String} html
 */
function escapeHtml(html) {
  return html.replace(REGEXP_LT, "&lt;").replace(REGEXP_GT, "&gt;");
}

/**
 * default safeAttrValue function
 *
 * @param {String} tag
 * @param {String} name
 * @param {String} value
 * @param {Object} cssFilter
 * @return {String}
 */
function safeAttrValue(tag, name, value, cssFilter) {
  // unescape attribute value firstly
  value = friendlyAttrValue(value);

  if (name === "href" || name === "src") {
    // filter `href` and `src` attribute
    // only allow the value that starts with `http://` | `https://` | `mailto:` | `/` | `#`
    value = _.trim(value);
    if (value === "#") return "#";
    if (
      !(
        value.substr(0, 7) === "http://" ||
        value.substr(0, 8) === "https://" ||
        value.substr(0, 7) === "mailto:" ||
        value.substr(0, 4) === "tel:" ||
        value[0] === "#" ||
        value[0] === "/"
      )
    ) {
      return "";
    }
  } else if (name === "background") {
    // filter `background` attribute (maybe no use)
    // `javascript:`
    REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
    if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
      return "";
    }
  } else if (name === "style") {
    // `expression()`
    REGEXP_DEFAULT_ON_TAG_ATTR_7.lastIndex = 0;
    if (REGEXP_DEFAULT_ON_TAG_ATTR_7.test(value)) {
      return "";
    }
    // `url()`
    REGEXP_DEFAULT_ON_TAG_ATTR_8.lastIndex = 0;
    if (REGEXP_DEFAULT_ON_TAG_ATTR_8.test(value)) {
      REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
      if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
        return "";
      }
    }
    if (cssFilter !== false) {
      cssFilter = cssFilter || defaultCSSFilter;
      value = cssFilter.process(value);
    }
  }

  // escape `<>"` before returns
  value = escapeAttrValue(value);
  return value;
}

// RegExp list
var REGEXP_LT = /</g;
var REGEXP_GT = />/g;
var REGEXP_QUOTE = /"/g;
var REGEXP_QUOTE_2 = /&quot;/g;
var REGEXP_ATTR_VALUE_1 = /&#([a-zA-Z0-9]*);?/gim;
var REGEXP_ATTR_VALUE_COLON = /&colon;?/gim;
var REGEXP_ATTR_VALUE_NEWLINE = /&newline;?/gim;
var REGEXP_DEFAULT_ON_TAG_ATTR_3 = /\/\*|\*\//gm;
var REGEXP_DEFAULT_ON_TAG_ATTR_4 = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a)\:/gi;
var REGEXP_DEFAULT_ON_TAG_ATTR_5 = /^[\s"'`]*(d\s*a\s*t\s*a\s*)\:/gi;
var REGEXP_DEFAULT_ON_TAG_ATTR_6 = /^[\s"'`]*(d\s*a\s*t\s*a\s*)\:\s*image\//gi;
var REGEXP_DEFAULT_ON_TAG_ATTR_7 = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi;
var REGEXP_DEFAULT_ON_TAG_ATTR_8 = /u\s*r\s*l\s*\(.*/gi;

/**
 * escape doube quote
 *
 * @param {String} str
 * @return {String} str
 */
function escapeQuote(str) {
  return str.replace(REGEXP_QUOTE, "&quot;");
}

/**
 * unescape double quote
 *
 * @param {String} str
 * @return {String} str
 */
function unescapeQuote(str) {
  return str.replace(REGEXP_QUOTE_2, '"');
}

/**
 * escape html entities
 *
 * @param {String} str
 * @return {String}
 */
function escapeHtmlEntities(str) {
  return str.replace(REGEXP_ATTR_VALUE_1, function replaceUnicode(str, code) {
    return code[0] === "x" || code[0] === "X"
      ? String.fromCharCode(parseInt(code.substr(1), 16))
      : String.fromCharCode(parseInt(code, 10));
  });
}

/**
 * escape html5 new danger entities
 *
 * @param {String} str
 * @return {String}
 */
function escapeDangerHtml5Entities(str) {
  return str
    .replace(REGEXP_ATTR_VALUE_COLON, ":")
    .replace(REGEXP_ATTR_VALUE_NEWLINE, " ");
}

/**
 * clear nonprintable characters
 *
 * @param {String} str
 * @return {String}
 */
function clearNonPrintableCharacter(str) {
  var str2 = "";
  for (var i = 0, len = str.length; i < len; i++) {
    str2 += str.charCodeAt(i) < 32 ? " " : str.charAt(i);
  }
  return _.trim(str2);
}

/**
 * get friendly attribute value
 *
 * @param {String} str
 * @return {String}
 */
function friendlyAttrValue(str) {
  str = unescapeQuote(str);
  str = escapeHtmlEntities(str);
  str = escapeDangerHtml5Entities(str);
  str = clearNonPrintableCharacter(str);
  return str;
}

/**
 * unescape attribute value
 *
 * @param {String} str
 * @return {String}
 */
function escapeAttrValue(str) {
  str = escapeQuote(str);
  str = escapeHtml(str);
  return str;
}

/**
 * `onIgnoreTag` function for removing all the tags that are not in whitelist
 */
function onIgnoreTagStripAll() {
  return "";
}

/**
 * remove tag body
 * specify a `tags` list, if the tag is not in the `tags` list then process by the specify function (optional)
 *
 * @param {array} tags
 * @param {function} next
 */
function StripTagBody(tags, next) {
  if (typeof next !== "function") {
    next = function() {};
  }

  var isRemoveAllTag = !Array.isArray(tags);
  function isRemoveTag(tag) {
    if (isRemoveAllTag) return true;
    return _.indexOf(tags, tag) !== -1;
  }

  var removeList = [];
  var posStart = false;

  return {
    onIgnoreTag: function(tag, html, options) {
      if (isRemoveTag(tag)) {
        if (options.isClosing) {
          var ret = "[/removed]";
          var end = options.position + ret.length;
          removeList.push([
            posStart !== false ? posStart : options.position,
            end
          ]);
          posStart = false;
          return ret;
        } else {
          if (!posStart) {
            posStart = options.position;
          }
          return "[removed]";
        }
      } else {
        return next(tag, html, options);
      }
    },
    remove: function(html) {
      var rethtml = "";
      var lastPos = 0;
      _.forEach(removeList, function(pos) {
        rethtml += html.slice(lastPos, pos[0]);
        lastPos = pos[1];
      });
      rethtml += html.slice(lastPos);
      return rethtml;
    }
  };
}

/**
 * remove html comments
 *
 * @param {String} html
 * @return {String}
 */
function stripCommentTag(html) {
  return html.replace(STRIP_COMMENT_TAG_REGEXP, "");
}
var STRIP_COMMENT_TAG_REGEXP = /<!--[\s\S]*?-->/g;

/**
 * remove invisible characters
 *
 * @param {String} html
 * @return {String}
 */
function stripBlankChar(html) {
  var chars = html.split("");
  chars = chars.filter(function(char) {
    var c = char.charCodeAt(0);
    if (c === 127) return false;
    if (c <= 31) {
      if (c === 10 || c === 13) return true;
      return false;
    }
    return true;
  });
  return chars.join("");
}

exports.whiteList = getDefaultWhiteList();
exports.getDefaultWhiteList = getDefaultWhiteList;
exports.onTag = onTag;
exports.onIgnoreTag = onIgnoreTag;
exports.onTagAttr = onTagAttr;
exports.onIgnoreTagAttr = onIgnoreTagAttr;
exports.safeAttrValue = safeAttrValue;
exports.escapeHtml = escapeHtml;
exports.escapeQuote = escapeQuote;
exports.unescapeQuote = unescapeQuote;
exports.escapeHtmlEntities = escapeHtmlEntities;
exports.escapeDangerHtml5Entities = escapeDangerHtml5Entities;
exports.clearNonPrintableCharacter = clearNonPrintableCharacter;
exports.friendlyAttrValue = friendlyAttrValue;
exports.escapeAttrValue = escapeAttrValue;
exports.onIgnoreTagStripAll = onIgnoreTagStripAll;
exports.StripTagBody = StripTagBody;
exports.stripCommentTag = stripCommentTag;
exports.stripBlankChar = stripBlankChar;
exports.cssFilter = defaultCSSFilter;
exports.getDefaultCSSWhiteList = getDefaultCSSWhiteList;

},{"./util":338,"cssfilter":331}],336:[function(require,module,exports){
/**
 * xss
 *
 * @author Zongmin Lei<leizongmin@gmail.com>
 */

var DEFAULT = require("./default");
var parser = require("./parser");
var FilterXSS = require("./xss");

/**
 * filter xss function
 *
 * @param {String} html
 * @param {Object} options { whiteList, onTag, onTagAttr, onIgnoreTag, onIgnoreTagAttr, safeAttrValue, escapeHtml }
 * @return {String}
 */
function filterXSS(html, options) {
  var xss = new FilterXSS(options);
  return xss.process(html);
}

exports = module.exports = filterXSS;
exports.FilterXSS = FilterXSS;
for (var i in DEFAULT) exports[i] = DEFAULT[i];
for (var i in parser) exports[i] = parser[i];

// using `xss` on the browser, output `filterXSS` to the globals
if (typeof window !== "undefined") {
  window.filterXSS = module.exports;
}

// using `xss` on the WebWorker, output `filterXSS` to the globals
function isWorkerEnv() {
  return typeof self !== 'undefined' && typeof DedicatedWorkerGlobalScope !== 'undefined' && self instanceof DedicatedWorkerGlobalScope;
}
if (isWorkerEnv()) {
  self.filterXSS = module.exports;
}

},{"./default":335,"./parser":337,"./xss":339}],337:[function(require,module,exports){
/**
 * Simple HTML Parser
 *
 * @author Zongmin Lei<leizongmin@gmail.com>
 */

var _ = require("./util");

/**
 * get tag name
 *
 * @param {String} html e.g. '<a hef="#">'
 * @return {String}
 */
function getTagName(html) {
  var i = _.spaceIndex(html);
  if (i === -1) {
    var tagName = html.slice(1, -1);
  } else {
    var tagName = html.slice(1, i + 1);
  }
  tagName = _.trim(tagName).toLowerCase();
  if (tagName.slice(0, 1) === "/") tagName = tagName.slice(1);
  if (tagName.slice(-1) === "/") tagName = tagName.slice(0, -1);
  return tagName;
}

/**
 * is close tag?
 *
 * @param {String} html 如：'<a hef="#">'
 * @return {Boolean}
 */
function isClosing(html) {
  return html.slice(0, 2) === "</";
}

/**
 * parse input html and returns processed html
 *
 * @param {String} html
 * @param {Function} onTag e.g. function (sourcePosition, position, tag, html, isClosing)
 * @param {Function} escapeHtml
 * @return {String}
 */
function parseTag(html, onTag, escapeHtml) {
  "user strict";

  var rethtml = "";
  var lastPos = 0;
  var tagStart = false;
  var quoteStart = false;
  var currentPos = 0;
  var len = html.length;
  var currentTagName = "";
  var currentHtml = "";

  for (currentPos = 0; currentPos < len; currentPos++) {
    var c = html.charAt(currentPos);
    if (tagStart === false) {
      if (c === "<") {
        tagStart = currentPos;
        continue;
      }
    } else {
      if (quoteStart === false) {
        if (c === "<") {
          rethtml += escapeHtml(html.slice(lastPos, currentPos));
          tagStart = currentPos;
          lastPos = currentPos;
          continue;
        }
        if (c === ">") {
          rethtml += escapeHtml(html.slice(lastPos, tagStart));
          currentHtml = html.slice(tagStart, currentPos + 1);
          currentTagName = getTagName(currentHtml);
          rethtml += onTag(
            tagStart,
            rethtml.length,
            currentTagName,
            currentHtml,
            isClosing(currentHtml)
          );
          lastPos = currentPos + 1;
          tagStart = false;
          continue;
        }
        if ((c === '"' || c === "'") && html.charAt(currentPos - 1) === "=") {
          quoteStart = c;
          continue;
        }
      } else {
        if (c === quoteStart) {
          quoteStart = false;
          continue;
        }
      }
    }
  }
  if (lastPos < html.length) {
    rethtml += escapeHtml(html.substr(lastPos));
  }

  return rethtml;
}

var REGEXP_ILLEGAL_ATTR_NAME = /[^a-zA-Z0-9_:\.\-]/gim;

/**
 * parse input attributes and returns processed attributes
 *
 * @param {String} html e.g. `href="#" target="_blank"`
 * @param {Function} onAttr e.g. `function (name, value)`
 * @return {String}
 */
function parseAttr(html, onAttr) {
  "user strict";

  var lastPos = 0;
  var retAttrs = [];
  var tmpName = false;
  var len = html.length;

  function addAttr(name, value) {
    name = _.trim(name);
    name = name.replace(REGEXP_ILLEGAL_ATTR_NAME, "").toLowerCase();
    if (name.length < 1) return;
    var ret = onAttr(name, value || "");
    if (ret) retAttrs.push(ret);
  }

  // 逐个分析字符
  for (var i = 0; i < len; i++) {
    var c = html.charAt(i);
    var v, j;
    if (tmpName === false && c === "=") {
      tmpName = html.slice(lastPos, i);
      lastPos = i + 1;
      continue;
    }
    if (tmpName !== false) {
      if (
        i === lastPos &&
        (c === '"' || c === "'") &&
        html.charAt(i - 1) === "="
      ) {
        j = html.indexOf(c, i + 1);
        if (j === -1) {
          break;
        } else {
          v = _.trim(html.slice(lastPos + 1, j));
          addAttr(tmpName, v);
          tmpName = false;
          i = j;
          lastPos = i + 1;
          continue;
        }
      }
    }
    if (/\s|\n|\t/.test(c)) {
      html = html.replace(/\s|\n|\t/g, " ");
      if (tmpName === false) {
        j = findNextEqual(html, i);
        if (j === -1) {
          v = _.trim(html.slice(lastPos, i));
          addAttr(v);
          tmpName = false;
          lastPos = i + 1;
          continue;
        } else {
          i = j - 1;
          continue;
        }
      } else {
        j = findBeforeEqual(html, i - 1);
        if (j === -1) {
          v = _.trim(html.slice(lastPos, i));
          v = stripQuoteWrap(v);
          addAttr(tmpName, v);
          tmpName = false;
          lastPos = i + 1;
          continue;
        } else {
          continue;
        }
      }
    }
  }

  if (lastPos < html.length) {
    if (tmpName === false) {
      addAttr(html.slice(lastPos));
    } else {
      addAttr(tmpName, stripQuoteWrap(_.trim(html.slice(lastPos))));
    }
  }

  return _.trim(retAttrs.join(" "));
}

function findNextEqual(str, i) {
  for (; i < str.length; i++) {
    var c = str[i];
    if (c === " ") continue;
    if (c === "=") return i;
    return -1;
  }
}

function findBeforeEqual(str, i) {
  for (; i > 0; i--) {
    var c = str[i];
    if (c === " ") continue;
    if (c === "=") return i;
    return -1;
  }
}

function isQuoteWrapString(text) {
  if (
    (text[0] === '"' && text[text.length - 1] === '"') ||
    (text[0] === "'" && text[text.length - 1] === "'")
  ) {
    return true;
  } else {
    return false;
  }
}

function stripQuoteWrap(text) {
  if (isQuoteWrapString(text)) {
    return text.substr(1, text.length - 2);
  } else {
    return text;
  }
}

exports.parseTag = parseTag;
exports.parseAttr = parseAttr;

},{"./util":338}],338:[function(require,module,exports){
module.exports = {
  indexOf: function(arr, item) {
    var i, j;
    if (Array.prototype.indexOf) {
      return arr.indexOf(item);
    }
    for (i = 0, j = arr.length; i < j; i++) {
      if (arr[i] === item) {
        return i;
      }
    }
    return -1;
  },
  forEach: function(arr, fn, scope) {
    var i, j;
    if (Array.prototype.forEach) {
      return arr.forEach(fn, scope);
    }
    for (i = 0, j = arr.length; i < j; i++) {
      fn.call(scope, arr[i], i, arr);
    }
  },
  trim: function(str) {
    if (String.prototype.trim) {
      return str.trim();
    }
    return str.replace(/(^\s*)|(\s*$)/g, "");
  },
  spaceIndex: function(str) {
    var reg = /\s|\n|\t/;
    var match = reg.exec(str);
    return match ? match.index : -1;
  }
};

},{}],339:[function(require,module,exports){
/**
 * filter xss
 *
 * @author Zongmin Lei<leizongmin@gmail.com>
 */

var FilterCSS = require("cssfilter").FilterCSS;
var DEFAULT = require("./default");
var parser = require("./parser");
var parseTag = parser.parseTag;
var parseAttr = parser.parseAttr;
var _ = require("./util");

/**
 * returns `true` if the input value is `undefined` or `null`
 *
 * @param {Object} obj
 * @return {Boolean}
 */
function isNull(obj) {
  return obj === undefined || obj === null;
}

/**
 * get attributes for a tag
 *
 * @param {String} html
 * @return {Object}
 *   - {String} html
 *   - {Boolean} closing
 */
function getAttrs(html) {
  var i = _.spaceIndex(html);
  if (i === -1) {
    return {
      html: "",
      closing: html[html.length - 2] === "/"
    };
  }
  html = _.trim(html.slice(i + 1, -1));
  var isClosing = html[html.length - 1] === "/";
  if (isClosing) html = _.trim(html.slice(0, -1));
  return {
    html: html,
    closing: isClosing
  };
}

/**
 * shallow copy
 *
 * @param {Object} obj
 * @return {Object}
 */
function shallowCopyObject(obj) {
  var ret = {};
  for (var i in obj) {
    ret[i] = obj[i];
  }
  return ret;
}

/**
 * FilterXSS class
 *
 * @param {Object} options
 *        whiteList, onTag, onTagAttr, onIgnoreTag,
 *        onIgnoreTagAttr, safeAttrValue, escapeHtml
 *        stripIgnoreTagBody, allowCommentTag, stripBlankChar
 *        css{whiteList, onAttr, onIgnoreAttr} `css=false` means don't use `cssfilter`
 */
function FilterXSS(options) {
  options = shallowCopyObject(options || {});

  if (options.stripIgnoreTag) {
    if (options.onIgnoreTag) {
      console.error(
        'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'
      );
    }
    options.onIgnoreTag = DEFAULT.onIgnoreTagStripAll;
  }

  options.whiteList = options.whiteList || DEFAULT.whiteList;
  options.onTag = options.onTag || DEFAULT.onTag;
  options.onTagAttr = options.onTagAttr || DEFAULT.onTagAttr;
  options.onIgnoreTag = options.onIgnoreTag || DEFAULT.onIgnoreTag;
  options.onIgnoreTagAttr = options.onIgnoreTagAttr || DEFAULT.onIgnoreTagAttr;
  options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
  options.escapeHtml = options.escapeHtml || DEFAULT.escapeHtml;
  this.options = options;

  if (options.css === false) {
    this.cssFilter = false;
  } else {
    options.css = options.css || {};
    this.cssFilter = new FilterCSS(options.css);
  }
}

/**
 * start process and returns result
 *
 * @param {String} html
 * @return {String}
 */
FilterXSS.prototype.process = function(html) {
  // compatible with the input
  html = html || "";
  html = html.toString();
  if (!html) return "";

  var me = this;
  var options = me.options;
  var whiteList = options.whiteList;
  var onTag = options.onTag;
  var onIgnoreTag = options.onIgnoreTag;
  var onTagAttr = options.onTagAttr;
  var onIgnoreTagAttr = options.onIgnoreTagAttr;
  var safeAttrValue = options.safeAttrValue;
  var escapeHtml = options.escapeHtml;
  var cssFilter = me.cssFilter;

  // remove invisible characters
  if (options.stripBlankChar) {
    html = DEFAULT.stripBlankChar(html);
  }

  // remove html comments
  if (!options.allowCommentTag) {
    html = DEFAULT.stripCommentTag(html);
  }

  // if enable stripIgnoreTagBody
  var stripIgnoreTagBody = false;
  if (options.stripIgnoreTagBody) {
    var stripIgnoreTagBody = DEFAULT.StripTagBody(
      options.stripIgnoreTagBody,
      onIgnoreTag
    );
    onIgnoreTag = stripIgnoreTagBody.onIgnoreTag;
  }

  var retHtml = parseTag(
    html,
    function(sourcePosition, position, tag, html, isClosing) {
      var info = {
        sourcePosition: sourcePosition,
        position: position,
        isClosing: isClosing,
        isWhite: whiteList.hasOwnProperty(tag)
      };

      // call `onTag()`
      var ret = onTag(tag, html, info);
      if (!isNull(ret)) return ret;

      if (info.isWhite) {
        if (info.isClosing) {
          return "</" + tag + ">";
        }

        var attrs = getAttrs(html);
        var whiteAttrList = whiteList[tag];
        var attrsHtml = parseAttr(attrs.html, function(name, value) {
          // call `onTagAttr()`
          var isWhiteAttr = _.indexOf(whiteAttrList, name) !== -1;
          var ret = onTagAttr(tag, name, value, isWhiteAttr);
          if (!isNull(ret)) return ret;

          if (isWhiteAttr) {
            // call `safeAttrValue()`
            value = safeAttrValue(tag, name, value, cssFilter);
            if (value) {
              return name + '="' + value + '"';
            } else {
              return name;
            }
          } else {
            // call `onIgnoreTagAttr()`
            var ret = onIgnoreTagAttr(tag, name, value, isWhiteAttr);
            if (!isNull(ret)) return ret;
            return;
          }
        });

        // build new tag html
        var html = "<" + tag;
        if (attrsHtml) html += " " + attrsHtml;
        if (attrs.closing) html += " /";
        html += ">";
        return html;
      } else {
        // call `onIgnoreTag()`
        var ret = onIgnoreTag(tag, html, info);
        if (!isNull(ret)) return ret;
        return escapeHtml(html);
      }
    },
    escapeHtml
  );

  // if enable stripIgnoreTagBody
  if (stripIgnoreTagBody) {
    retHtml = stripIgnoreTagBody.remove(retHtml);
  }

  return retHtml;
};

module.exports = FilterXSS;

},{"./default":335,"./parser":337,"./util":338,"cssfilter":331}],340:[function(require,module,exports){
'use strict';

/**
 * 剪切板 操作工具包
 *
 */
var CONST = require('../config/const');
var utils = require('../libs/utils');

var ClipboardUtils = function ClipboardUtils() {
  var core = null;
  var env = null;
  var domUtils = null;
  var rangeUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
    rangeUtils = core.require.rangeUtils;
  };

  var getClipboardDiv = function getClipboardDiv() {
    var ieClipboardDiv = env.doc.createElement(CONST.TAG.TMP_TAG);
    domUtils.css(ieClipboardDiv, {
      position: 'absolute',
      'z-index': -1,
      top: '-100px',
      left: '-100px',
      'width': '1px',
      'height': '1px',
      color: 'transparent',
      background: 'transparent',
      overflow: 'hidden',
      opacity: 0,
      filter: 'alpha(opacity=0)'
    });
    env.body.appendChild(ieClipboardDiv);
    ieClipboardDiv.innerHTML = '<br/>';
    return ieClipboardDiv;
  };

  this.getData = function (e, callback) {
    var clipboard = {
      files: null,
      html: '',
      text: ''
    };

    if (env.browser.isIe) {
      var clipboardData = window.clipboardData;
      if (!clipboardData) {
        callback(clipboard);
        return;
      }

      rangeUtils.caretBackup();
      var clipboardText = clipboardData.getData('Text');
      var ieClipboardDiv = getClipboardDiv();
      rangeUtils.setRange(ieClipboardDiv, 0, ieClipboardDiv, 1);
      setTimeout(function () {
        // console.log('Clipboard Plain Text: ' + clipboardText);
        // console.log('Clipboard HTML: ' + ieClipboardDiv.innerHTML);
        clipboard.text = clipboardText || '';
        clipboard.html = ieClipboardDiv.innerHTML || '';
        // 必须先恢复后移除，
        // 因为焦点在 临时div 内，如果先删除 div 会导致 selection 操作异常
        rangeUtils.caretRestore();
        domUtils.remove(ieClipboardDiv);
        callback(clipboard);
      }, 50);
      return;
    }

    if (!e || !e.clipboardData) {
      callback(clipboard);
      return;
    }

    clipboard.files = e.clipboardData && e.clipboardData.items && e.clipboardData.items.length === 1 && /^image\//.test(e.clipboardData.items[0].type) ? e.clipboardData.items : null;
    clipboard.html = e.clipboardData && e.clipboardData.getData('text/html') || '';
    clipboard.text = e.clipboardData && e.clipboardData.getData('text/plain') || '';

    callback(clipboard);
  };

  this.setData = function (e, html, text, callback) {
    // console.log('------ setData ------');
    if (env.browser.isIe) {
      var clipboardData = window.clipboardData;
      if (clipboardData) {
        rangeUtils.caretBackup();
        var ieClipboardDiv = getClipboardDiv();
        clipboardData.setData('Text', text);
        ieClipboardDiv.innerHTML = html;
        // console.log(html);
        // console.log('--------- innerHtml ----------');
        // console.log(ieClipboardDiv.innerHTML);
        rangeUtils.setRange(ieClipboardDiv, 0, ieClipboardDiv, ieClipboardDiv.childNodes.length);
        setTimeout(function () {
          // 必须先恢复后移除，
          // 因为焦点在 临时div 内，如果先删除 div 会导致 selection 操作异常
          rangeUtils.caretRestore();
          domUtils.remove(ieClipboardDiv);
          callback();
        }, 50);
      } else {
        callback();
      }
      return;
    }

    if (!e || !e.clipboardData) {
      callback();
      return;
    }
    if (e.clipboardData && !env.browser.isIe) {
      e.clipboardData.clearData();
      e.clipboardData.setData('text/plain', text);
      e.clipboardData.setData('text/html', html);
    }

    if (e.clipboardData.getData('text')) {
      utils.stopEvent(e);
      callback();
      return;
    }

    // hack for ios
    // ios safari 不支持 e.clipboardData.setData
    var hackDiv = getClipboardDiv();
    var field = env.doc.createElement('textarea');
    field.value = text;
    domUtils.attr(field, { readonly: '' });

    domUtils.css(field, {
      position: 'absolute',
      top: '0',
      left: '0',
      width: '1000px'
    });
    domUtils.css(hackDiv, {
      position: 'absolute',
      top: '-99999px',
      left: '-99999px',
      overflow: 'hidden'
    });
    hackDiv.appendChild(field);
    env.body.appendChild(hackDiv);
    field.focus();
    field.selectionStart = 0;
    field.selectionEnd = field.value.length;
    setTimeout(function () {
      env.body.removeChild(hackDiv);
      field = null;
      hackDiv = null;
      callback();
    }, 50);
  };
};

module.exports = ClipboardUtils;

},{"../config/const":388,"../libs/utils":400}],341:[function(require,module,exports){
'use strict';

/**
 * 代码区域操作核心包 core
 */
var CONST = require('../config/const');
// const utils = require('../libs/utils');

var CommandExtend = function CommandExtend() {
  var _this = this;

  var core = null;
  var env = null;
  var blockUtils = null;
  var domUtils = null;
  var historyUtils = null;
  var rangeUtils = null;
  var todoUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    blockUtils = core.require.blockUtils;
    domUtils = core.require.domUtils;
    historyUtils = core.require.historyUtils;
    rangeUtils = core.require.rangeUtils;
    todoUtils = core.require.todoUtils;
  };

  var getHBlock = function getHBlock(dom) {
    // 因为 getBlockList 方法中 会将所有的 块级元素独立出来，所以找到一个 h1 - h6 就可以直接返回
    for (var i = 1; i <= 6; i++) {
      var h = dom.querySelector('h' + i);
      if (h) {
        return h;
      }
    }
    return null;
  };

  var patchExecForFormatBlock = function patchExecForFormatBlock(blockType) {
    var range = rangeUtils.getRange();
    if (!range) {
      return;
    }

    var start = range.startContainer;
    var startOffset = range.startOffset;
    var end = range.endContainer;
    var endOffset = range.endOffset;

    var blockList = blockUtils.fixAndGetBlockListFromRange();
    // console.log(blockList);
    var hasH = false;
    for (var i = 0; i < blockList.length; i++) {
      var block = blockList[i];
      hasH = domUtils.isTag(block, ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']) || !!getHBlock(block);
      if (hasH) {
        break;
      }
    }
    // 如果 blockType 为 div ，且区域内不存在 H1 - H6，则不进行任何操作
    if (!hasH && /^div$/ig.test(blockType)) {
      return true;
    }

    for (var _i = 0; _i < blockList.length; _i++) {
      var _block = blockList[_i];
      var h = getHBlock(_block);
      if (domUtils.isSelfClosingTag(_block) || _block.notFormat) {
        continue;
      }
      if (h && !domUtils.isTag(h, [blockType])) {
        blockList[_i] = domUtils.replaceTagName(h, blockType);
      } else if (domUtils.isTag(_block, ['ol', 'ul'])) {
        // 设置为标题时， ol ul 需要遍历 li
        var children = _block.children;
        for (var j = 0; j < children.length; j++) {
          var child = children[j];
          var tmp = domUtils.packageChildNodesByDiv(child);
          domUtils.replaceTagName(tmp, blockType);
        }
      } else if (domUtils.isTag(_block, ['td', 'th', 'li'])) {
        _block = domUtils.packageChildNodesByDiv(_block);
        blockList[_i] = domUtils.replaceTagName(_block, blockType);
      } else if (!h) {
        blockList[_i] = domUtils.replaceTagName(_block, blockType);
      }
    }

    clearFontSize(blockList);

    var newEnd = blockList[blockList.length - 1];
    if (start.parentNode && end.parentNode) {
      rangeUtils.setRange(start, startOffset, end, endOffset);
    } else if (start.parentNode) {
      rangeUtils.setRange(start, startOffset);
    } else if (end.parentNode) {
      rangeUtils.setRange(end, endOffset);
    } else {
      rangeUtils.setRange(newEnd, domUtils.getEndOffset(newEnd));
    }

    return true;
  };

  /**
   * 设置标题时，清空 block 内的 font-size
   */
  var clearFontSize = function clearFontSize(domList) {
    var isSingle = true;

    for (var i = domList.length - 1; i >= 0; i--) {
      var dom = domList[i];
      domUtils.clearStyle(dom, 'font-size', isSingle);
      clearFontSize(dom.querySelectorAll('[style]'));
    }
  };

  /**
   * pC & mac 客户端 使用的 Chrome 版本 49 对于操作 subscript superscript 有 bug 必须修正
   * 如果 sub 或 sup 内的 dom 有 <span> <b> 等标签就会导致无法取消 sub sup
   */
  var patchExecForSubAndSup = function patchExecForSubAndSup(command) {
    if (patchQueryForSubAndSup(command)) {
      // 格式刷目标第一个元素是目标元素 则清理 sub || sup
      _this.clearSubSup();
      return false;
    } else {
      // 设置 sub || sup
      return env.doc.execCommand(command, false);
    }
  };
  /**
   * pC & mac 客户端 使用的 Chrome 版本 49 对于操作 subscript superscript 有 bug 必须修正
   * 如果 sub 或 sup 内的 dom 有 <span> <b> 等标签就会导致永远得到 false
   */
  var patchQueryForSubAndSup = function patchQueryForSubAndSup(command) {
    var tagName = command === 'subscript' ? 'sub' : 'sup';
    // 设置 sub || sup
    var range = rangeUtils.getRange();
    var start = void 0;
    if (range) {
      start = rangeUtils.getRangeDetail(range.startContainer, range.startOffset);
      start = start.container;
      start = domUtils.getFirstDeepChild(start);
      start = domUtils.getParentByTagName(start, tagName, true);
    }
    return !!start;
  };

  var patchExecForOutdent = function patchExecForOutdent() {
    var blockList = blockUtils.fixAndGetBlockListFromRange();
    var targetList = [];
    var getTargetIndex = function getTargetIndex(target) {
      for (var i = 0; i < targetList.length; i++) {
        if (target === targetList[i].main) {
          return i;
        }
      }
      return -1;
    };
    var insertTarget = function insertTarget(target) {
      if (!target) {
        return;
      }
      var index = getTargetIndex(target.main);
      if (index < 0) {
        targetList.push(target);
      } else if (target.first && targetList[index].first) {
        targetList[index].last = target.last;
      } else {
        // 只要有其中一个为 null，则认为需要处理整个 块
        targetList[index].first = null;
        targetList[index].last = null;
      }
    };
    var checkChildList = function checkChildList(target, tagName) {
      var blockIndexList = domUtils.getIndexList(target);
      var list = target.querySelectorAll(tagName);
      var result = false;
      for (var j = 0; j < list.length; j++) {
        var item = list[j];
        var parentTarget = domUtils.getParentByTagName(item, ['ol', 'ul'], false);
        if (parentTarget) {
          var parentIndexList = domUtils.getIndexList(parentTarget);
          if (domUtils.compareIndexList(blockIndexList, parentIndexList) < 0) {
            item = null;
          }
        }
        if (item) {
          insertTarget({
            main: item,
            first: null,
            last: null
          });
          result = true;
        }
      }
      return result;
    };

    // 获取 缩进的块级元素集合
    for (var i = 0; i < blockList.length; i++) {
      var block = blockList[i];
      var target = void 0;
      if (domUtils.isTag(block, ['blockquote', 'ol', 'ul', 'li'])) {
        target = {
          main: block,
          first: null,
          last: null
        };
      } else {
        var checkOl = checkChildList(block, 'ol');
        var checkUl = checkChildList(block, 'ul');
        if (checkOl || checkUl) {
          target = null;
        } else {
          target = domUtils.getParentByTagName(block, ['blockquote', 'li'], false);
          if (target) {
            target = {
              main: target,
              first: block,
              last: block
            };
          }
        }
      }
      insertTarget(target);
    }

    var start = void 0,
        end = void 0;
    if (targetList.length > 0) {
      var startTarget = targetList[0];
      var endTarget = targetList[targetList.length - 1];
      start = domUtils.getFirstDeepChild(startTarget.first ? startTarget.first : startTarget.main);
      end = domUtils.getLastDeepChild(endTarget.last ? endTarget.last : endTarget.main);
    }

    // 遍历处理
    // console.log(targetList);
    for (var _i2 = 0; _i2 < targetList.length; _i2++) {
      var _target = targetList[_i2];
      if (domUtils.isTag(_target.main, 'blockquote')) {
        // <blockquote>
        if (!_target.first) {
          domUtils.peelDom(_target.main);
        } else {
          var _block2 = domUtils.splitDomBeforeSub(_target.main, _target.first);
          _block2 = domUtils.splitDomAfterSub(_block2, _target.last);
          domUtils.peelDom(_block2);
        }
      } else if (domUtils.isTag(_target.main, ['ol', 'ul'])) {
        // <ol> <ul>
        var listDom = domUtils.getParentByTagName(_target.main, ['ol', 'ul'], false);
        if (!listDom) {
          // 处理后，如果 li 父节点 不存在 ol、ul 则 将 li 处理为 div
          for (var j = _target.main.childNodes.length - 1; j >= 0; j--) {
            var child = _target.main.childNodes[j];
            if (domUtils.isTag(child, 'li')) {
              domUtils.packageChildNodesByDiv(child);
              domUtils.peelDom(child);
            }
          }
        }
        domUtils.peelDom(_target.main);
      } else {
        // <li>
        var _listDom = _target.main.parentNode;
        _listDom = domUtils.splitDomSingle(_listDom, _target.main);
        domUtils.peelDom(_listDom);

        _listDom = domUtils.getParentByTagName(_target.main, ['ol', 'ul'], false);
        if (!_listDom) {
          // 处理后，如果 li 父节点 不存在 ol、ul 则 将 li 处理为 div
          domUtils.packageChildNodesByDiv(_target.main);
          domUtils.peelDom(_target.main);
        }
      }
    }

    if (start && end) {
      rangeUtils.setRange(start, 0, end, domUtils.getEndOffset(end));
    }

    return targetList.length > 0;
  };

  /**
   * 修正 光标未选中文字时，无法设置 粗体、斜体、下划线的 bug
   */
  var patchExecForFont = function patchExecForFont(range) {
    var n = domUtils.createSpan();
    n.innerHTML = CONST.FILL_CHAR;
    range.insertNode(n);
  };

  var _event = {
    bind: function bind() {
      _event.unbind();
      env.event.add(CONST.EVENT.EXEC_COMMEND, _event.handler.onExecCommand);
    },
    unbind: function unbind() {
      env.event.remove(CONST.EVENT.EXEC_COMMEND, _event.handler.onExecCommand);
    },
    handler: {
      onExecCommand: function onExecCommand() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this.execCommand.apply(_this, args);
      }
    }
  };

  this.on = function () {
    _event.bind();
  };
  this.off = function () {
    _event.unbind();
  };
  this.clearSubSup = function () {
    var rangeResult = rangeUtils.getRangeDomList({
      noSplit: false
    });
    var p = void 0;
    var range = void 0,
        span = void 0;
    var start = void 0,
        end = void 0;
    if (!rangeResult || rangeResult.list.length === 0) {
      range = rangeUtils.getRange();
      if (range && range.collapsed) {
        span = domUtils.createSpan();
        span.innerHTML = CONST.FILL_CHAR + CONST.FILL_CHAR;
        range.insertNode(span);
        p = domUtils.getParentByTagName(span, ['sub', 'sup'], true);
        if (p) {
          p = domUtils.splitDomSingle(p, span);
          domUtils.peelDom(p);
          rangeUtils.setRange(span, 1);
        } else {
          domUtils.remove(span);
        }
      }
      return;
    }

    var firstP = domUtils.getParentByTagName(rangeResult.list[0], ['sub', 'sup'], true);
    // 只有一个 dom
    if (rangeResult.list.length === 1) {
      p = domUtils.splitDomSingle(firstP, rangeResult.list[0]);
      if (p) {
        start = p.firstChild;
        end = p.lastChild;
        domUtils.peelDom(p);
        rangeUtils.setRange(start, 0, end, domUtils.getEndOffset(end));
      } else {
        rangeUtils.setRange(rangeResult.startDom, rangeResult.startOffset, rangeResult.endDom, rangeResult.endOffset);
      }
      return;
    }

    // 必须要在 剥离 sub sup 之前先让选择范围最前、最后进行分割
    if (firstP) {
      domUtils.splitDomBeforeSub(firstP, rangeResult.list[0]);
    }
    var lastP = domUtils.getParentByTagName(rangeResult.list[rangeResult.list.length - 1], ['sub', 'sup'], true);
    if (lastP) {
      domUtils.splitDomAfterSub(lastP, rangeResult.list[rangeResult.list.length - 1]);
    }

    var isPeelSub = false;
    for (var i = 0; i < rangeResult.list.length; i++) {
      var dom = rangeResult.list[i];
      p = domUtils.getParentByTagName(dom, ['sub', 'sup'], true);
      if (i === 0) {
        start = dom;
      } else if (i === rangeResult.list.length - 1) {
        end = dom;
      }
      if (p) {
        if (i === 0) {
          start = p.firstChild;
        } else if (i === rangeResult.list.length - 1) {
          end = p.lastChild;
        }
        domUtils.peelDom(p);
        isPeelSub = true;
      }
    }
    // 操作后必须修正 Range
    if (isPeelSub) {
      rangeUtils.setRange(start, 0, end, domUtils.getEndOffset(end));
    } else {
      rangeUtils.fixRange(rangeResult);
    }
  };
  /**
   * 封装 execCommand 方法，用于 编辑器内部事件触发
   */
  this.execCommand = function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var range = rangeUtils.getRange();
    var startTodoMain = void 0,
        startTodoCheckbox = void 0,
        startTodoId = void 0;
    if (range && range.collapsed && todoUtils) {
      startTodoMain = todoUtils.getMainByCaret();
      startTodoCheckbox = todoUtils.getCheckbox(startTodoMain);
      startTodoId = startTodoCheckbox ? startTodoCheckbox.id : '';
    }

    var command = args[0];

    var codeBeforeRange = null;
    if (range && /^(insertOrderedList)|(insertUnorderedList)$/i.test(command)) {
      //设置 有序、无序列表时，光标前面为 CodeMirror， CodeMirror 前面为 有序、无序列表，
      // 此时必须设置 CodeMirror 容器 contenteditable = true
      // 否则会导致 CodeMirror 后面的 空行变为 列表后，同时会被移动到 CodeMirror 前面
      var start = range.startContainer;
      var startOffset = range.startOffset;
      if (start.nodeType === 1 && startOffset < start.childNodes.length) {
        start = start.childNodes[startOffset];
      }
      start = domUtils.getPreviousNode(start, true);
      codeBeforeRange = domUtils.getParentByClass(start, CONST.CLASS.CODE_CONTAINER, false);
      if (codeBeforeRange) {
        domUtils.setContenteditable(codeBeforeRange, true);
      }
    }

    var result = void 0;
    if (/formatblock/i.test(args[0])) {
      result = patchExecForFormatBlock(args[2]);
    } else if (/subscript|superscript/i.test(args[0])) {
      result = patchExecForSubAndSup(args[0]);
    } else if (/outdent/i.test(args[0])) {
      result = patchExecForOutdent(args[0]);
    } else {
      if (/bold|italic|underline/i.test(args[0]) && range && range.collapsed) {
        patchExecForFont(range);
      }
      result = env.doc.execCommand.apply(env.doc, args);
    }

    if (codeBeforeRange) {
      // 恢复原设置
      domUtils.setContenteditable(codeBeforeRange, false);
    }

    // fix orderList className
    if (/^(indent)|(outdent)|(insertOrderedList)|(insertUnorderedList)$/i.test(command)) {
      domUtils.fixOrderList();
    }

    // patch for ios
    // 修正 ios 客户端出现 的 bug：
    // 无序列表 + todoList 文本，在行末尾回车，然后立刻执行 缩进操作，然后输入文本，文本会被加入 font 标签而且会设置小一号的字体
    // 解决办法，缩进后判断如果是空的 todoList，则将checkbox 后内容删除重新设置 span 标签
    if (startTodoId && (/^indent$/i.test(command) && env.client.type.isIOS || /^outdent$/i.test(command))) {

      if (/^outdent$/i.test(command) && todoUtils) {
        // 减少缩进操作会导致将 todoList 的 container 剥离
        todoUtils.fixNewTodo();
      }
      startTodoCheckbox = env.body.querySelector('#' + startTodoId);
      startTodoMain = todoUtils && todoUtils.getMainFromChild(startTodoCheckbox);

      if (startTodoMain && todoUtils && todoUtils.isEmptyMain(startTodoMain)) {
        var checkbox = todoUtils.getCheckbox(startTodoMain);
        while (startTodoMain.lastChild !== checkbox) {
          startTodoMain.removeChild(startTodoMain.lastChild);
        }
        var span = domUtils.createSpan();
        domUtils.after(span, checkbox);
        span.innerHTML = CONST.FILL_CHAR + CONST.FILL_CHAR;
        rangeUtils.setRange(span, 1);
      }
    }

    // PC 客户端使用的 Chrome 引擎在 设置列表后，会自动出现 font-size 的样式，必须要进行修正
    domUtils.fixFont();

    env.event.call(CONST.EVENT.ON_EXEC_COMMAND);
    env.event.call(CONST.EVENT.ON_SELECTION_CHANGE);
    return result;
  };
  this.queryCommandState = function (command) {
    var result = void 0;
    if (/subscript|superscript/i.test(command)) {
      result = patchQueryForSubAndSup(command);
    } else {
      result = env.doc.queryCommandState(command);
    }
    return result;
  };
};

module.exports = CommandExtend;

},{"../config/const":388}],342:[function(require,module,exports){
'use strict';

/**
 * Dom 操作工具包（基础核心包，主要都是 get 等读取操作）
 *
 */
var CONST = require('../config/const');
var utils = require('../libs/utils');

var defaultFontSize = 12;

var DomUtils = function DomUtils() {
  var _this = this;

  var core = null;
  var env = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
  };

  /**
   * 添加 class name
   */
  this.addClass = function (domList, className) {
    if (!domList) {
      return;
    }
    if (!!domList.nodeType) {
      domList = [domList];
    }
    var i = void 0,
        dom = void 0;
    for (i = domList.length - 1; i >= 0; i--) {
      dom = domList[i];
      if (dom.nodeType === 1 && !_this.hasClass(dom, className)) {
        dom.className = (dom.className + ' ' + className).trim();
      }
    }
  };

  /**
   * 将 dom 插入到 target 后
   */
  this.after = function (newDom, target) {
    _this.before(newDom, target, true);
  };

  /**
   * 给 DOM.getAttribute('style') 对象 设置 样式
   */
  this.appendStyle = function (styleStr, styleObj) {
    if (!styleStr) {
      return;
    }
    var styleList = styleStr.split(';'),
        i = void 0,
        j = void 0,
        t = void 0;
    for (i = 0, j = styleList.length; i < j; i++) {
      if (styleList[i].indexOf(':') > 0) {
        t = styleList[i].split(':');
        styleObj[t[0].trim()] = t[1].trim();
      }
    }
  };

  /**
   * 修改子节点的属性（attribute）
   */
  this.attr = function (dom, attr) {
    var key = void 0,
        value = void 0;
    if (!dom || !attr || dom.nodeType !== 1) {
      return;
    }
    for (key in attr) {
      if (attr.hasOwnProperty(key) && typeof key === 'string') {
        value = attr[key];
        if (!value) {
          dom.removeAttribute(key);
        } else {
          dom.setAttribute(key, value);
        }
      }
    }
  };

  /**
   * wiz 编辑器使用的 插入 dom 方法（isAfter 默认为 false，即将 dom 插入到 target 前面）
   */
  this.before = function (newDom, target, isAfter) {
    isAfter = !!isAfter;
    if (!target || !newDom) {
      return;
    }
    var isBody = target === env.body,
        parent = isBody ? target : target.parentNode,
        nextDom = isBody ? isAfter ? null : env.body.childNodes[0] : isAfter ? target.nextSibling : target;
    var last = void 0;
    if (!utils.isArray(newDom)) {
      parent.insertBefore(newDom, nextDom);
    } else {
      last = nextDom;
      for (var i = newDom.length - 1; i >= 0; i--) {
        var d = newDom[i];
        parent.insertBefore(d, last);
        last = d;
      }
    }
  };

  /**
   * 获取 body 内的 innerText
   */
  this.getBodyText = function () {
    var body = env.body;
    if (!body) return " ";
    return body.innerText ? body.innerText : '';
  };

  /**
   * 判断 dom 是否为可编辑的 dom 类型
   */
  this.canEdit = function (dom) {
    //过滤 script、style等标签
    var filterTag = ['script', 'style'];
    return dom && (dom.nodeType === 1 || dom.nodeType === 3) && (_this.isTag(dom, 'br') || !_this.isEmptyDom(dom)) && !_this.checkInTmp(dom) && !(dom.nodeType === 1 && _this.isTag(dom, filterTag) || dom.nodeType === 3 && dom.parentNode && _this.isTag(dom.parentNode, filterTag));
  };

  this.checkInTmp = function (dom) {
    return !!_this.getParentByTagName(dom, CONST.TAG.TMP_TAG, true);
  };
  /**
   * 清理 dom 内无用的 childNodes（主要用于 处理 剪切板的 html）
   */
  this.childNodesFilter = function (dom) {
    if (!dom || dom.nodeType !== 1) {
      return;
    }
    for (var i = dom.childNodes.length - 1; i >= 0; i--) {
      var d = dom.childNodes[i];
      if (d.nodeType === 1) {
        if (/link|style|script|meta/ig.test(d.nodeName)) {
          dom.removeChild(d);
        }
        _this.childNodesFilter(d);
      } else if (d.nodeType !== 3) {
        dom.removeChild(d);
      }
    }
  };

  /**
   * 清理重复嵌套的 DOM 结构
   */
  this.clearChild = function (dom, parentRoot, index) {
    // 保险起见，不处理 剪辑的笔记
    if (!dom || dom.nodeType !== 1 || env.isWizTemplate || /^wiz_/ig.test(dom.tagName) || _this.isTag(dom, ['svg']) || _this.hasClass(dom, CONST.CLASS.CODE_CONTAINER) || !env.doc.querySelector('#' + CONST.ID.WIZ_DEFAULT_STYLE)) {
      return false;
    }

    if (!parentRoot) {
      parentRoot = dom;
    }

    var wizFlag = /(^| )wiz[\-_]/i;
    var ns = dom.childNodes,
        i = void 0,
        item = void 0;
    var hasMerge = false;
    var canMerge = !_this.isTag(dom, ['table', 'tbody', 'tr', 'th', 'td', 'ul', 'ol', 'li', 'pre', 'code', 'blockquote']) && !wizFlag.test(dom.tagName) && !wizFlag.test(dom.id) && !wizFlag.test(dom.className);
    var canRemoveEmpty = dom.childNodes.length > 2;

    if (canMerge && ns.length === 1) {
      hasMerge = _this.clearChild(ns[0], parentRoot, index + 1);
    } else {
      var hasBr = false;
      var lastBr = null;
      for (i = ns.length - 1; i >= 0; i--) {
        item = ns[i];
        _this.clearChild(item, null, 0);

        // 清理大量同级空 DOM
        if (canMerge && canRemoveEmpty && !!item.parentNode && // 避免 item 已经被 remove
        item.nodeType === 1 && !_this.isSelfClosingTag(item) && item.childNodes.length === 0) {
          // 避免清理 span 之间的 div 导致丢失换行
          if (!hasBr && _this.isTag(item, 'div') && !/inline/i.test(item.style.display)) {
            lastBr = env.doc.createElement('br');
            _this.after(lastBr, item);
            hasBr = true;
          }
          _this.remove(item);
        } else if (!!item.parentNode && _this.isTag(item, 'div') && item.childNodes.length === 0) {
          // 清理完全为空的 div
          _this.remove(item);
        } else {
          hasBr = false;
        }
      }
      // 遍历子节点后，重新检查是否只剩下一个子元素
      if (canMerge && ns.length === 1) {
        hasMerge = _this.clearChild(ns[0], parentRoot, index + 1);
      }
    }

    if (canMerge && index > 5 && !hasMerge && parentRoot) {
      _this.mergeDomParent(dom, parentRoot);
      return true;
    } else if (canMerge && ns.length === 0 && !_this.isBlock(dom, { includeBr: true }) && _this.isEmptyDom(dom) || _this.isTag(dom, ['ol', 'ul']) && ns.length === 0) {
      // 末级的 inline 为空的元素直接删除
      _this.remove(dom);
    } else if (canMerge) {
      // 如果 dom 的子元素全部都是 <div> or <p>，则将 子元素提取出来
      var startDivCount = 0;
      var endDivCount = 0;
      for (i = 0; i < ns.length; i++) {
        item = ns[i];
        if (!_this.isTag(item, ['p', 'div'])) {
          break;
        }
        startDivCount = i + 1;
      }
      if (startDivCount < ns.length) {
        for (i = ns.length - 1; i >= 0; i--) {
          item = ns[i];
          if (!_this.isTag(item, ['p', 'div'])) {
            break;
          }
          endDivCount = ns.length - i;
        }
      }

      if (startDivCount && startDivCount === ns.length) {
        _this.peelDom(dom, function (child) {
          _this.mergeStyleAToB(dom, child);
          return true;
        });
      } else {
        for (i = 0; i < startDivCount; i++) {
          item = dom.firstChild;
          _this.mergeStyleAToB(dom, item);
          _this.before(item, dom);
        }
        for (i = 0; i < endDivCount; i++) {
          item = dom.lastChild;
          _this.mergeStyleAToB(dom, item);
          _this.after(item, dom);
        }
      }
    }
    return hasMerge;
  };

  /**
   * 清理无用的 子节点 span ，合并 attribute & style 相同的 span
   */
  this.clearChildSpan = function (dom, excludeList) {
    if (!dom) {
      return;
    }
    var isExclude = excludeList.indexOf(dom) >= 0;
    var str = void 0;
    if (!isExclude && dom.nodeType === 3 && !_this.isUsableTextNode(dom) && !_this.getParentByTagName(dom, 'pre', false)) {
      // pre 内不进行清理
      _this.remove(dom);
      return;
    } else if (!isExclude && dom.nodeType === 3) {
      str = dom.nodeValue.replace(CONST.FILL_CHAR_REG, '');
      // ios 10.3 设置 nodeValue 会导致光标移位（str === nodeValue 时，也会移位）
      if (str !== dom.nodeValue) {
        dom.nodeValue = str;
      }
      return;
    }

    if (!isExclude && dom.nodeType === 1) {
      var ns = dom.childNodes,
          i = void 0,
          item = void 0;
      for (i = ns.length - 1; i >= 0; i--) {
        item = ns[i];
        _this.clearChildSpan(item, excludeList);
      }
      _this.mergeChildSpan(dom, excludeList);

      if (excludeList.indexOf(dom) < 0 && dom.childNodes.length === 0 && dom.nodeType === 1 && !_this.isSelfClosingTag(dom) &&
      // dom.tagName.toLowerCase() == 'span' && !!dom.getAttribute(CONST.ATTR.SPAN)) {
      !!dom.getAttribute(CONST.ATTR.SPAN)) {
        _this.remove(dom);
      }
    }
  };

  /**
   * 清除 Dom 上 某一个 inline 的 style 属性
   * isSingle 是否只处理 dom 本身（false : 会自动处理其行级元素父节点）
   */
  this.clearStyle = function (dom, styleKey, isSingle) {
    var removeStyle = function removeStyle(_dom, _styleKey) {
      _dom.style[styleKey] = '';
      if (_this.isTag(_dom, 'font') && _styleKey === 'color') {
        _this.attr(_dom, { color: null });
      }
    };
    removeStyle(dom, styleKey);
    if (isSingle) {
      return;
    }
    while (dom && !_this.isBlock(dom)) {
      removeStyle(dom, styleKey);
      dom = dom.parentNode;
    }
  };

  /**
   * 清除 html 字符串内 style 样式（IOS 正在使用控制拖放、粘贴）
   */
  this.clearStyleFromHtml = function (html, whiteList) {
    var reg = /(<[^<>]* style=(['"]))((\r?\n|(?!(\2|[<>])).)*)/ig;

    whiteList = whiteList ? whiteList : [];
    var white = void 0,
        index = void 0;
    for (var i = 0; i < whiteList.length; i++) {
      white = whiteList[i];
      index = white.indexOf('*');
      whiteList[i] = index >= 0 ? white.substr(0, index).escapeRegex() : white.escapeRegex() + '$';
    }
    var whiteListReg = whiteList.length > 0 ? new RegExp('^(' + whiteList.join('|') + ')', 'i') : null;

    html = html.replace(reg, function (m0, m1, m2, m3) {
      var result = [m1];
      // 先还原特殊字符，处理后再替换回去 例如：
      //font-family: -apple-system, &quot;Helvetica Neue&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif;
      m3 = m3.replace(/&quot;/ig, '"');
      var styleList = m3.split(';'),
          style = void 0,
          index = void 0,
          k = void 0,
          v = void 0;
      for (var _i = 0, j = styleList.length; _i < j; _i++) {
        style = styleList[_i];
        index = style.indexOf(':');
        k = '';
        v = '';
        if (index > -1) {
          k = style.substr(0, index).trim();
          v = style.substr(index + 1).trim();
        } else {
          continue;
        }

        if (k && v && whiteListReg && whiteListReg.test(k)) {
          if (/^font-size$/i.test(k)) {
            v = _this.getFontSizeRem(v, {
              useRootSize: true
            });
            // 保存时由 fixFont方法 自动处理 font-family，所以粘贴时不再进行特殊处理
            // } else if (/^font-family$/i.test(k) &&
            //   (v.replace(/"| /g, '').toLowerCase() === CONST.CSS.DEFAULT_FONT.replace(/"| /g, '').toLowerCase() ||
            //     v.indexOf(',') > -1)) {
            //   // 避免粘贴时 设置 多余的 font-family
            //   continue;
          } else if (/^text-align$/i.test(k) && !/right|justify/i.test(v) || /^font-style$/i.test(k) && !/italic/i.test(v)) {
            v = null;
            // } else if (/^width$/i.test(k) && /^calc/i.test(v)) {
            //   // 清理 width 为 calc 计算的内容
            //   v = null;
          }
          if (v && !/^(inherit|initial|transparent)$/i.test(v)) {
            result.push(k, ':', v.replace(/"/ig, '&quot;'), ';');
          }
        }
      }
      return result.join('');
    });
    return html;
  };

  /**
   * 复制 dom
   */
  this.clone = function (dom, excludeInner) {
    var result = void 0,
        tmp = void 0,
        attList = void 0,
        atts = void 0,
        i = void 0,
        j = void 0,
        k = void 0;
    if (!dom) {
      return null;
    }
    if (excludeInner) {
      if (dom.nodeType === 3) {
        result = env.doc.createTextNode('');
      } else {
        result = env.doc.createElement(dom.tagName);
        attList = dom.attributes;
        atts = {};
        for (i = 0, j = attList.length; i < j; i++) {
          k = attList[i];
          if (/^id$/i.test(k.nodeName)) {
            continue;
          }
          atts[k.nodeName] = k.nodeValue;
        }
        _this.attr(result, atts);
      }
    } else {
      if (dom.nodeType === 3) {
        result = env.doc.createTextNode(dom.nodeValue);
      } else {
        tmp = env.doc.createElement('div');
        tmp.innerHTML = dom.outerHTML;
        result = tmp.childNodes[0];
      }
    }

    return result;
  };

  /**
   * 比较 IndexList
   */
  this.compareIndexList = function (a, b) {
    var j = Math.min(a.length, b.length);
    for (var i = 0; i < j; i++) {
      var x = a[i];
      var y = b[i];
      if (x < y) {
        return -1;
      }
      if (x > y) {
        return 1;
      }
    }

    if (a.length < b.length) {
      return -1;
    }

    if (a.length > b.length) {
      return 1;
    }

    return 0;
  };

  /**
   * a 是否包含 b （from jQuery 1.10.2）
   */
  this.contains = function (a, b) {
    var aDown = a.nodeType === 9 ? a.documentElement : a,
        bup = b && b.parentNode;
    return a === bup || !!(bup && bup.nodeType === 1 && (aDown.contains ? aDown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
  };

  /**
   * 根据 src 将 img 转换为 Base64
   */
  this.convertImageToBase64 = function (src, width, height, callback) {
    // var xhr = new XMLHttpRequest();
    // xhr.open('GET', src, true);
    // xhr.responseType = 'blob';
    // xhr.onload = () => {
    //     var blob, read;
    //     if (/^file:/i.test(src) || this.status == 200) {
    //         blob = this.response;
    //         read= new FileReader();
    //         read.readAsDataURL(blob);
    //         read.onload = () => {
    //             // callback(canvas.toDataURL());
    //             console.log(this.result);
    //         }
    //     } else {console.log(this)}
    // };
    // xhr.send();
    var img = env.doc.createElement('img');
    img.onload = function () {
      var canvas = env.doc.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      var context = canvas.getContext("2d");
      var dx = width / img.width;
      var dy = height / img.height;
      var d = Math.max(dx, dy);
      context.scale(d, d);
      context.drawImage(img, 0, 0);
      callback(canvas.toDataURL());
      img = null;
      canvas = null;
    };
    img.src = src;
  };

  /**
   * 创建 编辑器 自用的 span
   */
  this.createSpan = function () {
    var s = env.doc.createElement('span');
    var attr = {};
    attr[CONST.ATTR.SPAN] = CONST.ATTR.SPAN;
    _this.attr(s, attr);
    return s;
  };

  /**
   * 设置 dom css
   */
  this.css = function (dom, style) {
    if (!dom || !style || _this.isTag(dom, 'br')) {
      //禁止给 br 添加任何样式
      return;
    }
    var targetStyle = {};
    var k = void 0,
        v = void 0;
    for (k in style) {
      if (style.hasOwnProperty(k) && typeof k === 'string') {
        v = style[k];
        if (!v && v !== 0) {
          _this.clearStyle(dom, k, false);
        } else {
          targetStyle[k] = v;
        }
      }
    }

    for (k in targetStyle) {
      if (targetStyle.hasOwnProperty(k) && typeof k === 'string') {
        v = targetStyle[k];
        if (!v && v !== 0) {
          _this.clearStyle(dom, k, false);
        } else if (v.toString().indexOf('!important') > 0) {
          //对于 具有 !important 的样式需要特殊添加
          _this.clearStyle(dom, k, true);
          dom.style.cssText += k + ':' + v;
        } else if (k.toLowerCase() === 'font-size') {
          //如果设置的字体与 body 默认字体 同样大小， 则扩展设置 rem
          _this.clearStyle(dom, k, true);
          v = _this.getFontSizeRem(v);
          if (v) {
            dom.style.cssText += k + ':' + v;
          }
        } else if (dom.style[k] !== v) {
          dom.style[k] = v;
        }
      }
    }
  };

  /**
   * 修正 fontSize fontFamily
   */
  this.fixFont = function () {
    var domList = env.body.querySelectorAll('[style]');
    var colorReg = /color\s*:\s*([^;]*)/i;
    var bgColorReg = /background-color\s*:\s*([^;]*)/i;
    var fontFamilyReg = /font-family\s*:\s*([^;]*)/i;
    var fontSizeReg = /font-size\s*:\s*([%.\w]*)/i;
    var rootFontFamily = _this.getComputedStyle(env.body, 'font-family');

    for (var i = 0; i < domList.length; i++) {
      var dom = domList[i];
      if (!dom.parentNode || _this.isTag(dom, ['html'])) {
        continue;
      }
      var style = dom.getAttribute('style');

      // <math> 不存在 style 属性
      if (!style || !dom.style) {
        continue;
      }
      var fontFamilyMatch = style.match(fontFamilyReg);
      // 如果 字体与 body 的字体一致，一概取消

      if (fontFamilyMatch && (rootFontFamily === fontFamilyMatch[1] || rootFontFamily.indexOf(fontFamilyMatch[1] + ',') === 0)) {
        // 只要 fontFamily 内存在 逗号，就删除其 fontFamily 设置(字体含有 逗号 的需要保留，因为 百度编辑器插件插入的字体会有逗号)
        // 不能简单的设置 fontFamily 为 null，会导致自动继承父级 span 的字体
        // dom.style.fontFamily = null;
        var spanTop = _this.getSpanTop(dom);
        spanTop = _this.splitDomSingle(spanTop, dom);
        while (spanTop && spanTop.nodeType === 1) {
          spanTop.style.fontFamily = null;
          spanTop = spanTop.firstChild;
        }
      }

      var fontSizeMatch = fontSizeReg.exec(style);
      if (fontSizeMatch) {
        var size = fontSizeMatch[1];
        if (_this.getComputedStyle(dom, 'font-size') === _this.getComputedStyle(dom.parentNode, 'font-size')) {
          // 判断如果与父节点有相同的 font-size 则直接删除 样式
          dom.style.fontSize = null;
        } else if (size.indexOf('rem') < 0) {
          // 非 rem 单位的 font-size 需要修正为 rem
          dom.style.fontSize = _this.getFontSizeRem(size, {
            useRootSize: true
          });
        }
      }

      // 主要用于清理 由于粘贴造成的 color 冗余
      var colorMatch = colorReg.exec(style);
      if (colorMatch && !_this.isTag(dom, 'a')) {
        // <a> 不清理 color 属性，否则会导致颜色被系统默认的值取代
        var color = colorMatch[1].trim();
        // 夜间模式下 color 只检查 style 内的定义
        var s1 = env.options.nightMode.enable ? utils.rgb2Hex(color) : _this.getComputedStyle(dom, 'color');
        var s2 = _this.getComputedStyle(dom.parentNode, 'color');
        if (s1 === s2) {
          dom.style.color = null;
        }
      }

      // 主要用于清理 由于粘贴造成的 background-color 冗余
      var bgColorMatch = bgColorReg.exec(style);
      if (bgColorMatch) {
        var bgColor = bgColorMatch[1].trim();
        // 夜间模式下 background-color 只检查 style 内的定义
        var _s = env.options.nightMode.enable ? utils.rgb2Hex(bgColor) : _this.getComputedStyle(dom, 'background-color');
        var _s2 = _this.getComputedStyle(dom.parentNode, 'background-color', true);
        if (_s === _s2) {
          dom.style.backgroundColor = null;
        }
      }
    }
  };

  /**
   * 修正 有序列表 ol 的 className
   */
  this.fixOrderList = function () {
    var orderList = env.body.querySelectorAll('ol');
    for (var i = 0; i < orderList.length; i++) {
      var ol = orderList[i];
      var p = ol;
      var level = 0;
      while (p) {
        level++;
        p = _this.getParentByTagName(p, ['ul', 'ol'], false);
      }
      _this.removeClass(ol, CONST.CLASS.ORDER_LIST_LEVEL);
      _this.addClass(ol, CONST.CLASS.ORDER_LIST_LEVEL[level % 3]);
    }
  };

  /**
   * 设置 焦点
   */
  this.focus = function () {
    if (env.win.WizTemplate) {
      env.win.WizTemplate.focus();
    } else {
      env.body.focus();
    }
  };

  /**
   * 处理 copy、cut 操作时的元素容器，清理多余内容
   */
  this.fragmentFilterForCopy = function (fragment) {
    // 清理 codeMirror 内多余元素
    var removeList = function removeList(list) {
      for (var i = list.length - 1; i >= 0; i--) {
        var dom = list[i];
        _this.remove(dom);
      }
    };

    removeList(fragment.querySelectorAll('.' + CONST.CLASS.CODE_CONTAINER + ' textarea'));
    removeList(fragment.querySelectorAll('.' + CONST.CLASS.CODE_MIRROR_MEASURE));
    removeList(fragment.querySelectorAll('.' + CONST.CLASS.CODE_MIRROR_GUTTER));
    removeList(fragment.querySelectorAll('.' + CONST.CLASS.CODE_TOOLS));
  };

  /**
   * 获取第一个是 Block 块级元素的父节点
   */
  this.getBlockParent = function (dom, includeSelf) {
    if (!dom) {
      return null;
    }
    return _this.getParentByFilter(dom, function (obj) {
      return _this.isBlock(obj);
    }, includeSelf);
  };

  /**
   * 获取 dom 的 计算样式
   * includeParent  （Boolean 如果当前Dom 不存在指定的样式，是否递归到父节点）
   */
  this.getComputedStyle = function (dom, name, includeParent) {
    if (!dom || dom.nodeType === 3 || !name) {
      return '';
    }
    var value = void 0;
    //while (includeParent && !value && dom!=env.body) {
    while (!value) {
      if (!dom) {
        return '';
      }
      if (dom.nodeType !== 1) {
        dom = dom.parentNode;
        continue;
      }

      var s = env.win.getComputedStyle(dom, null);
      value = utils.rgb2Hex(s[name] || '');

      if (dom === env.body || !includeParent || !!value) {
        break;
      }

      //(includeParent && !value)
      dom = dom.parentNode;
    }
    return value;
  };

  /**
   * 获取当前页面源码
   */
  this.getContentHtml = function (options) {
    // PC 客户端使用的 Chrome 引擎在 设置列表后，会自动出现 font-size 的样式，必须要进行修正
    _this.fixFont();

    _this.fixOrderList();

    var isSaveTemp = options && options.isSaveTemp;
    env.event.call(CONST.EVENT.BEFORE_GET_DOCHTML, null);

    //将 input text、textarea 的内容设置到 html 内
    var obj = void 0;
    var objList = env.body.getElementsByTagName('input');
    for (var i = 0, j = objList.length; i < j; i++) {
      obj = objList[i];
      if (/^test$/i.test(obj.getAttribute('type')) && obj.value !== obj.getAttribute('value')) {
        _this.attr(obj, { value: obj.value });
      }
    }
    objList = env.body.getElementsByTagName('textarea');
    for (var _i2 = 0, _j = objList.length; _i2 < _j; _i2++) {
      obj = objList[_i2];
      if (!_this.getParentByClass(obj, CONST.CLASS.CODE_CONTAINER, false)) {
        // CodeMirror 内的 Textarea 已经在 BEFORE_GET_DOCHTML 事件内自行处理，
        // 这里重复操作会导致 CodeMirror 无法编辑
        _this.setTextarea(obj);
      }
    }
    //处理 table 容器内 table 之外的内容
    objList = env.body.querySelectorAll('.' + CONST.CLASS.TABLE_CONTAINER);
    for (var _i3 = 0, _j2 = objList.length; _i3 < _j2; _i3++) {
      _this.moveOutFromTableContainer(objList[_i3]);
    }

    var tmpStyle = [CONST.NAME.TMP_STYLE];
    if (!isSaveTemp) {
      tmpStyle.push(CONST.NAME.UNSAVE_STYLE);
    }
    var content = void 0,
        docType = '';
    if (env.options.container && !env.options.useFrame) {
      if (env.options.editor.type === CONST.NOTE_EDITOR_TYPE.MARKDOWN) {
        content = env.body.innerHTML;
      } else {
        // todo 普通笔记不适合采用 iFrame 方式
        content = '';
        throw new Error('普通笔记不适合采用 iFrame 方式');
      }
    } else {
      docType = _this.getDocType(env.doc);
      var fontSize = void 0;
      if (env.isSetBodyFontSize) {
        fontSize = env.body.style.fontSize;
        env.body.style.fontSize = null;
      }
      content = env.doc.documentElement.outerHTML;
      if (env.isSetBodyFontSize) {
        env.body.style.fontSize = fontSize;
      }
    }

    content = _this.removeStyleByNameFromHtml(content, tmpStyle);
    content = _this.removeByTagFromHtml(content, CONST.TAG.TMP_TAG);
    content = _this.peelTagFromHtml(content, CONST.TAG.TMP_PLUGIN_TAG);

    // 移除 viewport
    // content = this.removeViewportFromHtml(content, CONST.TAG.TMP_TAG);

    // 奇葩案例：抓取的页面注释中出现以下内容，导致 笔记被编辑后，就把全文都全部注释，导致看不到内容
    /*
       <!-- <link rel="stylesheet" href="/monthly/themes/tomorrow.css">
       <script src="/monthly/highlight/highlight.pack.js"> -->
    */
    // 所以必须先清理注释，然后再清理 script

    // 移除 注释内容
    content = content.replace(/<!--(.|\n)*?(-->)/g, '');
    // 移除 script
    content = content.replace(/<script[^<>]*\/>/ig, '').replace(/<script[^<>]*>(((?!<\/script>).)|(\r?\n))*<\/script>/ig, '');

    // 需要兼容 WizTemplate 中的部分区域可编辑 状态
    //var bodyReg = /(<body( [^<>]*)*)[ ]+contenteditable[ ]*=[ ]*['"][^'"<>]*['"]/ig;
    var editableReg = /(<[\w]*[^<>]*[ ]+)contenteditable([ ]*=[ ]*['"][^'"<>]*['"])?/ig;
    content = content.replace(editableReg, '$1');

    // 清理 body 样式
    var bodyReg = /(<body [^<>]*class=(['"]))(.*?)(\2)/ig;
    var bodyTmpClassReg = new RegExp(' *(' + CONST.CLASS.EDITING + '|' + CONST.CLASS.READONLY + ') *', 'g');
    content = content.replace(bodyReg, function (wholeMatch, m1, m2, m3, m4) {
      return m1 + m3.replace(bodyTmpClassReg, ' ') + m4;
    });

    // 需要处理 CodeMirror 内 的隐藏占位区域，否则会把内容当作摘要
    content = content.replace(/(<div class="CodeMirror-measure">)<pre><span>xxxxxxxxxx<\/span><\/pre>/ig, '$1');

    content = _this.hideTableFromHtml(content);
    content = _this.hideCodeFromHtml(content);

    if (!isSaveTemp) {

      content = _this.removeLazyLoadFromHtml(content);

      // 清理 base 标签（主要用于 Web 版的内容获取）
      var baseReg = /<base\s*[^>]*>/ig;
      content = content.replace(baseReg, '');
    }

    //过滤其他插件
    if (env.win.WizTemplate) {
      content = env.win.WizTemplate.hideTemplateFormHtml(content);
    }

    // 清理特殊字符
    content = utils.replaceSpecialChar(content);

    if (!isSaveTemp) {
      // Android 编辑图片时，临时保存页面，不能去掉 Editing 标识，否则无法替换 img 的 src
      var editingImgReg = new RegExp('(<img[^<>]*)( ' + CONST.ATTR.IMG_EDITING + '=(\'|")1\\3)', 'ig');
      content = content.replace(editingImgReg, '$1');

      // 恢复图片 index_files 的路径
      content = _this.restoreImgPath(content);
    }
    return docType + content;
  };

  /**
   * 专门用于处理 笔记延迟加载图片的内容
   * @param html
   * @returns {string}
   */
  this.removeLazyLoadFromHtml = function (html) {
    var searchImgReg = /<img [^>]*data-src\s*=\s*('|")[^>]*>/ig;
    var lazyLoadClassReg = /(('|")[^'"]*[^\s])(\s*wiz-lazyload\s*)([^'"]*\2)/ig;
    var emptyClassReg = /\s*class\s*=\s*('|")\s*\1/ig;
    var dataSrcReg = /\s*data-src\s*=/ig;
    var srcReg = /\s+src\s*=/i;

    var result = html.replace(searchImgReg, function (matchStr) {
      var str = matchStr;
      // 不存在 wiz-lazyload 属性，并且 存在 src 的 dom 不进行特殊处理
      if (str.indexOf('wiz-lazyload') < 0 && srcReg.test(str)) {
        return str;
      }
      str = str.replace(lazyLoadClassReg, '$1$4').replace(emptyClassReg, '').replace(dataSrcReg, ' src=');
      return str;
    });
    return result;
  };

  /**
   * 获取当前页面的HTML （专门用于 Reader 在渲染后使用）
   */
  this.getRenderDocument = function () {
    env.event.call(CONST.EVENT.BEFORE_GET_DOCHTML, null);

    var content = void 0,
        docType = '';
    if (env.options.container && !env.options.useFrame) {
      content = env.body.innerHTML;
    } else {
      docType = _this.getDocType(env.doc);
      content = env.doc.documentElement.outerHTML;
    }

    content = _this.removeByTagFromHtml(content, CONST.TAG.TMP_TAG);
    content = _this.peelTagFromHtml(content, CONST.TAG.TMP_PLUGIN_TAG);

    // 移除 注释内容
    content = content.replace(/<!--(.|\n)*?(-->)/g, '');
    // 移除 script
    content = content.replace(/<script[^<>]*\/>/ig, '').replace(/<script[^<>]*>(((?!<\/script>).)|(\r?\n))*<\/script>/ig, '');

    // 需要处理 CodeMirror 内 的隐藏占位区域，否则会把内容当作摘要
    content = content.replace(/(<div class="CodeMirror-measure">)<pre><span>xxxxxxxxxx<\/span><\/pre>/ig, '$1');

    content = _this.hideTableFromHtml(content);
    content = _this.hideCodeFromHtml(content);

    //过滤其他插件
    if (env.win.WizTemplate) {
      content = env.win.WizTemplate.hideTemplateFormHtml(content);
    }

    // 恢复图片 index_files 的路径
    content = _this.restoreImgPath(content);

    return docType + content;
  };

  /**
   * 恢复图片 index_files 的路径
   */
  this.restoreImgPath = function (content) {
    content = replace(content, env.indexFilesFullPath, env.indexFilesPath);
    // web 端需要考虑 base 处理
    var base = env.doc.querySelector('head base');
    if (base) {
      content = replace(content, base.href + 'index_files/', 'index_files');
    }
    return content;

    function replace(html, fullpath, indexPath) {
      var imgFullPathReg = new RegExp('(<[^<>]*src[ ]*=[ ]*("|\'))' + fullpath.escapeRegex(), 'ig');
      var imgMarkdownFullPathReg = new RegExp('(!\\[[^[\\]]*\\]\\()' + fullpath.escapeRegex(), 'ig');

      return html.replace(imgFullPathReg, '$1' + indexPath + '/').replace(imgMarkdownFullPathReg, '$1' + indexPath + '/');
    }
  };

  /**
   * 获取 DocType
   */
  this.getDocType = function (doc) {
    var docType = doc.doctype;
    var docTypeHtml = '';
    if (!!docType && !docType.systemId && !docType.publicId) {
      docTypeHtml = '<!DOCTYPE HTML>';
    } else if (!!docType) {
      docTypeHtml = '<!';
      docTypeHtml += 'DOCTYPE HTML PUBLIC "' + docType.publicId + '" "' + docType.systemId + '" >';
    } else {
      docTypeHtml = '<!DOCTYPE HTML>';
    }
    return docTypeHtml;
  };

  /**
   * 获取 Dom 的子元素长度（同时支持 TextNode 和 Element）
   */
  this.getEndOffset = function (dom) {
    if (!dom) {
      return 0;
    }
    return dom.nodeType === 3 ? dom.nodeValue.length : dom.childNodes.length;
  };
  this.getFirst = function (container) {
    if (!container) {
      container = env.body;
    }
    var dom = _this.getFirstDeepChild(container);
    var canEdit = _this.canEdit(dom);
    while (dom && !canEdit) {
      dom = _this.getNextNodeCanEdit(dom, false);
      canEdit = _this.canEdit(dom);
    }
    return dom;
  };
  /**
   * 获取 dom 子孙元素中第一个 叶子节点
   */
  this.getFirstDeepChild = function (obj) {
    if (!obj) {
      return null;
    }
    var tmp = obj;
    while (tmp && tmp.childNodes && tmp.childNodes.length > 0) {
      tmp = tmp.childNodes[0];
      while (tmp && tmp.nodeType === 1 && /^wiz_/ig.test(tmp.tagName)) {
        tmp = tmp.nextSibling;
      }
      if (tmp) {
        obj = tmp;
      }
    }
    return obj;
  };

  /**
   * 根据字号获取 rem 值
   */
  this.getFontSizeRem = function (fontSize, _options) {
    fontSize = fontSize.trim();
    var size = parseFloat(fontSize);
    if (fontSize.indexOf('%') > -1) {
      return Math.round(size / 100 * 1000) / 1000 + 'rem';
    } else if (/^smaller$/i.test(fontSize)) {
      return '0.83rem';
    } else if (/^small$/i.test(fontSize)) {
      return '0.8125rem';
    } else if (/^x-small$/i.test(fontSize)) {
      return '0.75rem';
    } else if (/^xx-small$/i.test(fontSize)) {
      return '0.75rem';
    } else if (/^larger$/i.test(fontSize)) {
      return '1.2rem';
    } else if (/^large$/i.test(fontSize)) {
      return '1.125rem';
    } else if (/^x-large$/i.test(fontSize)) {
      return '1.5rem';
    } else if (/^xx-large$/i.test(fontSize)) {
      return '2rem';
    } else if (/^medium$/i.test(fontSize)) {
      return '1rem';
    } else if (!/pt|px/i.test(fontSize)) {
      return isNaN(size) ? null : size + 'rem';
    }

    var options = {
      useRootSize: !!(_options && _options.useRootSize)
    };

    var s = env.win.getComputedStyle(env.doc.body.parentNode),
        pxRoot = parseFloat(s.fontSize);
    // 粘贴操作时， pt、px 都按照当前 根字体大小计算 em
    // 其他情况 pt 单位按照 默认字体大小计算 em（因为客户端设置字体的数字都是根据默认大小传递的）
    var ptRoot = options.useRootSize ? defaultFontSize * _this.getRootSizeRate() : defaultFontSize;

    if (isNaN(pxRoot) || isNaN(size) || pxRoot === 0) {
      return null;
    }
    if (/pt/i.test(fontSize)) {
      size = size / ptRoot;
    } else {
      size = size / pxRoot;
    }
    return Math.round(size * 1000) / 1000 + 'rem';
  };

  /**
   * 根据 dom 树索引集合 获取 dom
   */
  this.getFromIndexList = function (indexList) {
    if (!indexList || indexList.length === 0) {
      return null;
    }
    var d = env.body,
        offset = void 0;
    try {
      var i = void 0,
          j = void 0;
      for (i = 0, j = indexList.length - 1; i < j; i++) {
        d = d.childNodes[indexList[i]];
      }
      offset = indexList[i];
      return { dom: d, offset: offset };
    } catch (e) {
      return null;
    }
  };

  /**
   * 获取 图片数据
   */
  this.getImageData = function (img) {
    var size = _this.getImageSize(img.src);
    // Create an empty canvas element
    var canvas = env.doc.createElement("canvas");
    canvas.width = size.width;
    canvas.height = size.height;

    // Copy the image contents to the canvas
    var ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0);

    // Get the data-URL formatted image
    // Firefox supports PNG and JPEG. You could check img.src to
    // guess the original format, but be aware the using "image/jpg"
    // will re-encode the image.
    var dataURL = canvas.toDataURL("image/png");
    return dataURL.replace(/^data:image\/(png|jpg);base64,/, "");
  };

  /**
   * 获取 图片 宽高
   */
  this.getImageSize = function (imgSrc) {
    var newImg = new Image();
    newImg.src = imgSrc;
    return {
      width: newImg.width,
      height: newImg.height
    };
  };

  /**
   * 获取 Dom 在当前相邻节点中的 位置（index）
   */
  this.getIndex = function (dom) {
    if (!dom || !dom.parentNode) {
      return -1;
    }
    var k = 0,
        e = dom;
    while (e = e.previousSibling) {
      ++k;
    }
    return k;
  };

  /**
   * 获取 dom 在 dom 树内的 索引集合
   */
  this.getIndexList = function (dom) {
    var e = dom,
        indexList = [];
    while (e && !_this.isBody(e)) {
      indexList.splice(0, 0, _this.getIndex(e));
      e = e.parentNode;
    }
    return indexList;
  };

  /**
   * FF下无法获取innerText，通过解析DOM树来解析innerText，来渲染markdown
   */
  this.getInnerText = function (ele) {
    var t = '';

    var normalize = function normalize(a) {
      if (!a) {
        return "";
      }
      return a.replace(/ +/gm, " ").replace(/[\t]+/gm, "").replace(/[ ]+$/gm, "").replace(/^[ ]+/gm, "").replace(/\n+/gm, "\n").replace(/\n+$/, "").replace(/^\n+/, "").replace(/NEWLINE/gm, '\n');
      //return a.replace(/ +/g, " ")
      //    .replace(/[\t]+/gm, "")
      //    .replace(/[ ]+$/gm, "")
      //    .replace(/^[ ]+/gm, "")
      //    .replace(/\n+/g, "\n")
      //    .replace(/\n+$/, "")
      //    .replace(/^\n+/, "")
    };
    var removeWhiteSpace = function removeWhiteSpace(node) {
      // 去掉空的文本节点
      var isWhite = function isWhite(node) {
        return !/[^\t\n\r ]/.test(node.nodeValue);
      };
      var ws = [];
      var findWhite = function findWhite(node) {
        for (var i = 0; i < node.childNodes.length; i++) {
          var n = node.childNodes[i];
          if (n.nodeType === 3 && isWhite(n)) {
            ws.push(n);
          } else if (n.hasChildNodes()) {
            findWhite(n);
          }
        }
      };
      findWhite(node);
      for (var i = 0; i < ws.length; i++) {
        ws[i].parentNode.removeChild(ws[i]);
      }
    };
    var sty = function sty(n, prop) {
      // 获取节点的style
      if (n.style[prop]) {
        return n.style[prop];
      }
      var s = n.currentStyle || n.ownerDocument.defaultView.getComputedStyle(n, null);
      if (n.tagName === "SCRIPT") {
        return "none";
      }
      if (!s[prop]) {
        return "LI,P,TR".indexOf(n.tagName) > -1 ? "block" : n.style[prop];
      }
      if (s[prop] === "block" && n.tagName === "TD") {
        return "feaux-inline";
      }
      return s[prop];
    };

    var blockTypeNodes = "table-row,block,list-item";
    var isBlock = function isBlock(n) {
      // 判断是否为block元素
      var s = sty(n, "display") || "feaux-inline";
      return blockTypeNodes.indexOf(s) > -1;
    };
    // 遍历所有子节点，收集文本内容，注意需要空格和换行
    var recurse = function recurse(n) {
      // 处理pre元素
      if (/pre/.test(sty(n, "whiteSpace"))) {
        t += n.innerHTML.replace(/\t/g, " ");
        return "";
      }
      var s = sty(n, "display");
      if (s === "none") {
        return "";
      }
      var gap = isBlock(n) ? "\n" : " ";
      t += gap;
      for (var i = 0; i < n.childNodes.length; i++) {
        var c = n.childNodes[i];
        if (c.nodeType === 3) {
          t += c.nodeValue;
        }

        if (c.childNodes.length) {
          recurse(c);
        }
      }
      t += gap;
      return t;
    };

    var node = ele.cloneNode(true);
    // br转换成会忽略换行, 会出现 <span>aaa</span><br><span>bbb</span> 的情况，因此用一个特殊字符代替，而不是直接替换成 \n
    node.innerHTML = node.innerHTML.replace(/<br[\/]?>/gi, 'NEWLINE');

    // p元素会多一个换行，暂时用NEWLINE进行占位，markdown中不考虑p元素
    //var paras = node.getElementsByTagName('p');
    //for(var i = 0; i < paras.length; i++) {
    //    paras[i].innerHTML += 'NEWLINE';
    //}
    removeWhiteSpace(node);
    return normalize(recurse(node));
  };

  this.getLast = function (container) {
    if (!container) {
      container = env.body;
    }
    var dom = _this.getLastDeepChild(container);
    var canEdit = _this.canEdit(dom);
    while (dom && !canEdit) {
      dom = _this.getPreviousNodeCanEdit(dom, false);
      canEdit = _this.canEdit(dom);
    }
    return dom;
  };

  /**
   * 获取 dom 子孙元素中最后一个 叶子节点
   */
  this.getLastDeepChild = function (obj) {
    if (!obj) {
      return null;
    }
    var tmp = obj;
    while (tmp && tmp.childNodes && tmp.childNodes.length > 0) {
      tmp = tmp.childNodes[tmp.childNodes.length - 1];
      while (tmp && tmp.nodeType === 1 && /^wiz_/ig.test(tmp.tagName)) {
        tmp = tmp.previousSibling;
      }
      if (tmp) {
        obj = tmp;
      }
    }
    return obj;
  };

  /**
   * 获取 DomA 到 DomB 中包含的所有 叶子节点
   */
  this.getListA2B = function (options) {
    var startDom = options.startDom,
        startOffset = options.startOffset,
        endDom = options.endDom,
        endOffset = options.endOffset,
        noSplit = !!options.noSplit,
        isText = void 0,
        changeStart = false,
        changeEnd = false;

    //修正 start & end 位置
    if (startDom.nodeType === 1 && startOffset > 0 && startOffset < startDom.childNodes.length) {
      startDom = startDom.childNodes[startOffset];
      startOffset = 0;
    }
    if (endDom.nodeType === 1 && endOffset > 0 && endOffset < endDom.childNodes.length) {
      endDom = endDom.childNodes[endOffset];
      endOffset = 0;
    }
    //如果起始点 和终止点位置不一样， 且 endOffset == 0，则找到 endOom 前一个叶子节点
    if (startDom !== endDom && endOffset === 0) {
      endDom = _this.getPreviousNode(endDom, false, startDom);
      if (!endDom) {
        endDom = startDom;
      }

      if (_this.isSelfClosingTag(endDom)) {
        //如果 修正后的 endDom 为 自闭合标签， 需要特殊处理
        endOffset = 1;
      } else {
        endOffset = _this.getEndOffset(endDom);
      }
    }

    // get dom which is start and end
    if (startDom === endDom && startOffset !== endOffset) {
      isText = startDom.nodeType === 3;
      if (isText && !startDom.parentNode.getAttribute(CONST.ATTR.SPAN_DELETE) && !noSplit) {
        startDom = _this.splitRangeText(startDom, startOffset, endOffset, false);
        endDom = startDom;
        changeStart = true;
        changeEnd = true;
      } else if (startDom.nodeType === 1 && startDom.childNodes.length > 0 && !_this.isSelfClosingTag(startDom)) {
        startDom = startDom.childNodes[startOffset];
        endDom = endDom.childNodes[endOffset - 1];
        changeStart = true;
        changeEnd = true;
      }
    } else if (startDom !== endDom) {
      if (startDom.nodeType === 3 && !startDom.parentNode.getAttribute(CONST.ATTR.SPAN_DELETE) && !noSplit) {
        startDom = _this.splitRangeText(startDom, startOffset, null, false);
        changeStart = true;
      } else if (startDom.nodeType === 1 && startDom.childNodes.length > 0 && startOffset < startDom.childNodes.length) {
        startDom = startDom.childNodes[startOffset];
        changeStart = true;
      }
      if (endDom.nodeType === 3 && endOffset > 0 && !endDom.parentNode.getAttribute(CONST.ATTR.SPAN_DELETE) && !noSplit) {
        endDom = _this.splitRangeText(endDom, 0, endOffset, true);
        changeEnd = true;
      } else if (!_this.isSelfClosingTag(endDom) && endDom.nodeType === 1 && endOffset > 0) {
        endDom = _this.getLastDeepChild(endDom.childNodes[endOffset - 1]);
        changeEnd = true;
      }
    }
    if (changeStart) {
      startOffset = 0;
    }
    if (changeEnd) {
      endOffset = _this.getEndOffset(endDom);
    }

    //make the array
    var curDom = startDom,
        result = [];
    if (startOffset === startDom.length) {
      curDom = _this.getNextNode(curDom, false, endDom);
    }

    while (curDom && !(startDom === endDom && startOffset === endOffset)) {
      if (curDom === endDom || curDom === endDom.parentNode) {
        addDomForGetDomList(result, endDom);
        break;
      } else if (_this.isBody(curDom)) {
        addDomForGetDomList(result, curDom);
        break;
      } else {
        addDomForGetDomList(result, curDom);
      }
      curDom = _this.getNextNode(curDom, false, endDom);
    }

    // startDom 和 endDom 在 clearChild 操作中可能会被删除，所以必须要记住边缘 Dom 范围
    var startDomBak = _this.getPreviousNode(result[0], false, null),
        endDomBak = _this.getNextNode(result[result.length - 1], false, null);
    if (startDomBak && startDomBak.nodeType === 1 && startDomBak.firstChild) {
      startDomBak = startDomBak.firstChild;
    }
    if (endDomBak && endDomBak.nodeType === 1 && endDomBak.lastChild) {
      endDomBak = endDomBak.lastChild;
    }
    var startOffsetBak = _this.getEndOffset(startDomBak),
        endOffsetBak = 0;

    return {
      list: result,
      startDom: startDom,
      startOffset: startOffset,
      endDom: endDom,
      endOffset: endOffset,
      startDomBak: startDomBak,
      startOffsetBak: startOffsetBak,
      endDomBak: endDomBak,
      endOffsetBak: endOffsetBak
    };

    function addDomForGetDomList(main, sub) {
      main.push(sub);
    }
  };

  /**
   * 在 Index 范围内根据指定 tagName 获取 DOM 集合
   * startIndex  //1.1.5
   * endIndex    //1.4.2
   */
  this.getListFromTagAndIndex = function (tagName, container, startIndex, endIndex) {
    var result = [];
    var tagList = container.querySelectorAll(tagName);
    for (var i = 0; i < tagList.length; i++) {
      var tag = tagList[i];
      var tagIndex = _this.getIndexList(tag).join('.');
      if (utils.compareVersion(tagIndex, startIndex) > -1 && utils.compareVersion(tagIndex, endIndex) < 1) {
        result.push(tag);
      }
    }
    return result;
  };

  /**
   * 根据 node 获取其之后的第一个 块级元素（包括 br，自己的父节点）
   */
  this.getNextBlock = function (tmpEnd) {
    var isNext = false,
        tmp = void 0;

    if (_this.isBlock(tmpEnd, { includeBr: true })) {
      return tmpEnd;
    }

    while (tmpEnd) {
      if (isNext && tmpEnd.childNodes && tmpEnd.childNodes.length > 0) {
        tmpEnd = tmpEnd.childNodes[0];
        isNext = false;
      } else {
        tmp = tmpEnd.nextSibling;
        if (tmp) {
          tmpEnd = tmp;
          isNext = true;
        } else {
          tmpEnd = tmpEnd.parentNode;
          isNext = false;
        }
      }
      if (_this.isBlock(tmpEnd, { includeBr: true })) {
        break;
      }
    }
    return tmpEnd;
  };

  /**
   * 获取 DOM 的下一个叶子节点（包括不相邻的情况），到达指定的 endDom 为止（如果为空则忽略）
   */
  this.getNextNode = function (dom, onlyElement, endDom) {
    var originalDom = dom;
    if (!dom || dom === endDom) {
      return null;
    }
    onlyElement = !!onlyElement;

    function next(d) {
      if (!d) {
        return null;
      }
      return onlyElement ? d.nextElementSibling : d.nextSibling;
    }

    function first(d) {
      if (!d) {
        return null;
      }
      return onlyElement ? d.firstElementChild : d.firstChild;
    }

    if (!next(dom) && !dom.parentNode) {
      return null;
    } else if (!next(dom)) {
      //if hasn't nextSibling,so find its parent's nextSibling
      while (dom.parentNode) {
        dom = dom.parentNode;
        //必须首先判断 是否 body
        if (_this.isBody(dom)) {
          dom = null;
          break;
        }
        if (dom === endDom) {
          break;
        }
        if (next(dom)) {
          dom = next(dom);
          break;
        }
      }
    } else {
      dom = next(dom);
    }

    if (dom === endDom) {
      return dom;
    }

    //if next node has child nodes, so find the first child node.
    var tmpD = first(dom);
    if (!!dom && tmpD) {
      while (tmpD) {
        dom = tmpD;
        if (dom === endDom) {
          break;
        }
        tmpD = first(tmpD);
      }
    }
    if (dom === originalDom) {
      return null;
    }
    return dom;
  };

  /**
   * 获取 DOM 的 下一个 可编辑的叶子节点
   */
  this.getNextNodeCanEdit = function (dom, onlyElement, endDom) {
    dom = _this.getNextNode(dom, onlyElement, endDom);
    while (dom && !_this.canEdit(dom)) {
      dom = _this.getNextNode(dom, onlyElement, endDom);
    }
    return dom;
  };

  /**
   * 获取 offset 结果
   */
  this.getOffset = function (dom) {
    var offset = { top: 0, left: 0 };
    if (dom.offsetParent) {
      while (dom.offsetParent) {
        offset.top += dom.offsetTop;
        offset.left += dom.offsetLeft;
        dom = dom.offsetParent;
      }
    } else {
      offset.left += dom.offsetLeft;
      offset.top += dom.offsetTop;
    }
    return offset;
  };
  /**
   * 获取 页面滚动条位置
   */
  this.getPageScroll = function () {
    var scroll = {
      left: 0,
      top: 0
    };
    var target = env.scrollContainer;
    var win = void 0,
        doc = void 0;
    if (target === env.doc.body) {
      win = env.win;
      doc = env.doc;
    } else if (target === window.document.body) {
      win = window;
      doc = window.document;
    }

    if (win && typeof win.pageYOffset !== 'undefined') {
      scroll.left = win.pageXOffset;
      scroll.top = win.pageYOffset;
    } else if (doc && typeof doc.compatMode !== 'undefined' && doc.compatMode !== 'BackCompat') {
      scroll.left = doc.documentElement.scrollLeft || doc.body.scrollLeft;
      scroll.top = doc.documentElement.scrollTop || doc.body.scrollTop;
    } else if (target) {
      scroll.left = target.scrollLeft;
      scroll.top = target.scrollTop;
    }
    return scroll;
  };

  /**
   * 根据 ClassName 查找 Dom 的父节点
   */
  this.getParentByClass = function (node, className, includeSelf) {
    return _this.getParentByFilter(node, function (dom) {
      return _this.hasClass(dom, className);
    }, includeSelf);
  };

  /**
   * 根据 filterFn 函数设置的 自定义规则 查找 Dom 的父节点
   */
  this.getParentByFilter = function (node, filterFn, includeSelf) {
    if (node && !_this.isBody(node)) {
      node = includeSelf ? node : node.parentNode;
      while (node) {
        if (!filterFn || filterFn(node)) {
          return node;
        }
        if (_this.isBody(node)) {
          return null;
        }
        node = node.parentNode;
      }
    }
    return null;
  };

  /**
   * 根据 Tag 名称查找 Dom 的父节点
   */
  this.getParentByTagName = function (node, tagNames, includeSelf, excludeFn) {
    if (!node) {
      return null;
    }
    tagNames = utils.listToMap(utils.isArray(tagNames) ? tagNames : [tagNames]);
    return _this.getParentByFilter(node, function (node) {
      return tagNames[node.tagName] && !(excludeFn && excludeFn(node));
    }, includeSelf);
  };

  /**
   * 获取 Dom 的 父节点集合
   */
  this.getParentList = function (obj) {
    var list = [];
    var p = obj.parentNode;
    while (!!p && p !== env.body && !_this.hasClass(p, CONST.CLASS.WIZ_BODY)) {
      list.splice(0, 0, p);
      p = p.parentNode;
    }
    return list;
  };

  /**
   * 获取多个 dom 共同的父节点
   */
  this.getParentRoot = function (domList) {
    if (!domList || domList.length === 0) {
      return null;
    }
    var tmpIdx = void 0,
        pNode = void 0,
        parentList = [];
    pNode = domList[0].nodeType === 1 ? domList[0] : domList[0].parentNode;
    while (pNode && !_this.isBody(pNode)) {
      parentList.push(pNode);
      pNode = pNode.parentNode;
    }
    for (var i = 1, j = domList.length; i < j; i++) {
      pNode = domList[i];
      while (pNode) {
        if (_this.isBody(pNode)) {
          return env.body;
        }
        tmpIdx = parentList.indexOf(pNode);
        if (tmpIdx > -1) {
          parentList.splice(0, tmpIdx);
          break;
        }
        pNode = pNode.parentNode;
      }
    }
    if (parentList.length === 0) {
      return env.body;
    } else {
      return parentList[0];
    }
  };

  /**
   * 获取 DOM 的 坐标 & 大小
   */
  this.getPosition = function (obj) {
    if (!obj) {
      return null;
    }
    return {
      top: obj.offsetTop,
      left: obj.offsetLeft,
      height: obj.offsetHeight,
      width: obj.offsetWidth
    };
  };

  /**
   * 根据 node 获取其之前的第一个 块级元素（包括 br，自己的父节点）
   */
  this.getPrevBlock = function (tmpStart) {
    var isPre = false,
        tmp = void 0;
    if (_this.isBlock(tmpStart, { includeBr: true })) {
      return tmpStart;
    }
    while (tmpStart) {
      if (isPre && tmpStart.childNodes && tmpStart.childNodes.length > 0) {
        tmpStart = tmpStart.childNodes[tmpStart.childNodes.length - 1];
        isPre = false;
      } else {
        tmp = tmpStart.previousSibling;
        if (tmp) {
          tmpStart = tmp;
          isPre = true;
        } else {
          tmpStart = tmpStart.parentNode;
          isPre = false;
        }
      }
      if (_this.isBlock(tmpStart, { includeBr: true })) {
        break;
      }
    }
    return tmpStart;
  };
  /**
   * 获取 DOM 的前一个叶子节点（包括不相邻的情况），到达指定的 startDom 为止（如果为空则忽略）
   */
  this.getPreviousNode = function (dom, onlyElement, startDom) {
    var originalDom = dom;
    if (!dom || dom === startDom) {
      return null;
    }
    onlyElement = !!onlyElement;

    function prev(d) {
      return onlyElement ? d.previousElementSibling : d.previousSibling;
    }

    function last(d) {
      return onlyElement ? d.lastElementChild : d.lastChild;
    }

    if (!prev(dom)) {
      //if hasn't previousSibling,so find its parent's previousSibling
      while (dom.parentNode) {
        dom = dom.parentNode;
        //必须首先判断 是否 body
        if (_this.isBody(dom)) {
          dom = null;
          break;
        }
        if (dom === startDom) {
          break;
        }
        if (prev(dom)) {
          dom = prev(dom);
          break;
        }
      }
    } else {
      dom = prev(dom);
    }

    if (!dom) {
      return null;
    }
    //对于查找前一个dom节点的算法 与 查找 下一个dom的算法略有不同
    //如果 dom 与 startDom 相同， 但 dom 有子元素的时候， 不能直接返回 dom
    if (dom === startDom && (dom.nodeType === 3 || dom.nodeType === 1 && dom.childNodes.length === 0)) {
      return dom;
    }

    //if previous node has child nodes, so find the last child node.
    var tmpD = void 0;
    tmpD = last(dom);
    if (!!dom && tmpD) {
      while (tmpD) {
        dom = tmpD;
        if (dom === startDom && (dom.nodeType === 3 || dom.nodeType === 1 && dom.childNodes.length === 0)) {
          break;
        }
        tmpD = last(tmpD);
      }
    }

    if (dom === originalDom) {
      // 如果最终找到的 last child node 还是原始的 dom ，那么说明没有 prev
      return null;
    }

    return dom;
  };

  /**
   * 获取 DOM 的 下一个 可编辑的叶子节点
   */
  this.getPreviousNodeCanEdit = function (dom, onlyElement, endDom) {
    dom = _this.getPreviousNode(dom, onlyElement, endDom);
    while (dom && !_this.canEdit(dom)) {
      dom = _this.getPreviousNode(dom, onlyElement, endDom);
    }
    return dom;
  };

  /**
   * 生成并返回当前笔记视图放大状态
   * 1. 必须有 wiz_customm_css 样式
   * 2. 强制 12pt 当作 1:1 的状态
   */
  this.getRootSizeRate = function () {
    if (!env.doc.getElementById(CONST.ID.WIZ_DEFAULT_STYLE)) {
      return 1;
    }
    var s = env.win.getComputedStyle(env.body.parentNode),
        rootSize = parseFloat(s.fontSize);
    // console.log('rootSize rate: ' + (parseFloat(rootSize) / this.pt2px() / 12));
    return rootSize / _this.pt2px() / defaultFontSize;
  };

  this.getScrollContainer = function () {
    var target = env.options.container || env.body;
    if (target === env.doc.body) {
      return target;
    }
    var p = target;
    var body = env.body;
    while (p && p.nodeType === 1) {
      var s = env.win.getComputedStyle(p);
      if (/auto|scroll/i.test(s.overflowY)) {
        return p;
      }
      if (_this.isTag(p, ['body'])) {
        body = p;
      }
      p = p.parentNode;
    }
    return body;
  };

  /**
   * 获取 span 的顶级 span 元素
   * @param span
   */
  this.getSpanTop = function (span) {
    if (!span) {
      return span;
    }
    var spanTop = span;
    while (_this.isTag(span, 'span')) {
      spanTop = span;
      span = span.parentNode;
    }
    return spanTop;
  };

  /**
   * 给 dom 内添加 Tab 时 获取 4 个 ' '
   */
  this.getTab = function () {
    var x = env.doc.createElement('span');
    x.innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;';
    return x.childNodes[0];
  };

  /**
   * 获取窗口可视区域大小
   */
  this.getWindowSize = function () {
    return {
      width: env.doc.documentElement.clientWidth,
      height: env.doc.documentElement.clientHeight
    };
  };

  /**
   * 根据 dom 获取其 修订的父节点， 如果不是 修订内容，则返回空
   */
  this.getWizAmendParent = function (dom) {
    return _this.getParentByFilter(dom, function (node) {
      //node.childNodes.length == 0 时，键盘敲入的字符加在 span 外面
      return node && node.nodeType === 1 && (node.getAttribute(CONST.ATTR.SPAN_INSERT) || node.getAttribute(CONST.ATTR.SPAN_DELETE));
    }, true);
  };

  /**
   * 判断 dom 是否含有 某个 class name
   */
  this.hasClass = function (obj, className) {
    if (obj && obj.nodeType === 1) {
      return (' ' + obj.className + ' ').indexOf(' ' + className + ' ') > -1;
    }
    return false;
  };

  /**
   * 针对 html 源码隐藏 CodeMirror 光标 & 当前行 & 当前选中区域，主要用于保存操作
   */
  this.hideCodeFromHtml = function (html) {
    var regHide = /(<div [^<>]*)(CodeMirror-activeline-background|CodeMirror-cursors|CodeMirror-selected|CodeMirror-hscrollbar|CodeMirror-vscrollbar)([^<>]*>)/ig;
    html = html.replace(regHide, '$1 wiz-hide wiz_$2$3');
    var regNoClass = /(<span [^<>]*)(CodeMirror-matchingbracket)([^<>]*>)/ig;
    html = html.replace(regNoClass, '$1$3');
    return html;
  };

  /**
   * 针对 html 源码隐藏表格的高亮信息，主要用于保存操作
   */
  this.hideTableFromHtml = function (html) {
    var regex = /(<[^<> ]*[^<>]* class[ ]*=[ ]*['"])([^'"]*)(['"])/ig;
    var reg = new RegExp(' (' + CONST.CLASS.SELECTED_CELL + '|' + CONST.CLASS.SELECTED_CELL_MULTI + ')(?= )', 'ig');
    var result = html.replace(regex, function (matchStr, m1, m2, m3) {
      var str = m2;
      //先处理 float layer
      str = (' ' + str + ' ').replace(reg, '').trim();
      return m1 + str + m3;
    });
    return result;
  };

  this.html2Markdown = function (container, options) {
    var dom = void 0,
        childNodes = void 0,
        str = void 0;
    options = options || {};

    if (container.nodeType === 3) {
      str = container.nodeValue;
      if (options.isInA) {
        str = str.replace(/([\[\]])/g, '\\$1');
      }
      container.nodeValue = str;
      return;
    }

    if (container.nodeType !== 1) {
      return;
    }

    // options.noPureLink 主要用于避免此规则影响 粘贴时的超链接转换
    if (options.noPureLink && _this.isTag(container, 'a') && container.childElementCount === 0) {
      // 正常编辑笔记时，由于自动生成超链接的功能会导致 Markdown 笔记内出现如下结构：
      // [wiz.cn](<a href="http://www.wiz.cn">http://www.wiz.cn</a>)
      // 此 Dom 结构如果不处理，会导致生成的 MarkdownSrc 为：
      // [wiz.cn]([http://www.wiz.cn](http://www.wiz.cn/))
      // 从而产生异常，为了对之前情况进行兼容，对于 超链接内是纯文本的情况不进行转换处理
      return;
    }

    if (!options.isInA) {
      options.isInA = _this.isTag(container, 'a');
    }

    childNodes = container.childNodes;
    for (var i = childNodes.length - 1; i >= 0; i--) {
      _this.html2Markdown(childNodes[i], {
        isInA: options.isInA,
        noPureLink: options.noPureLink
      });
    }

    // 表格内的以下内容都不进行 markdown 转换
    if (_this.getParentByTagName(container, 'table')) {
      return;
    }
    if (_this.isTag(container, 'a')) {
      str = container.innerText;
      dom = env.doc.createElement('span');
      dom.innerText = '[' + str + '](' + container.href + ')';
      _this.before(dom, container);
      _this.remove(container);
    } else if (_this.isTag(container, 'img') && !_this.hasClass(container, CONST.CLASS.TODO_CHECKBOX)) {
      str = container.alt || utils.getFileNameByUrl(container.src);
      dom = env.doc.createElement('span');
      dom.innerText = '![' + str + '](' + container.src + ')';
      _this.before(dom, container);
      _this.remove(container);
    } else if (_this.isTag(container, ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li'])) {
      str = container.innerText;
      dom = env.doc.createElement('div');
      dom.innerText = str;
      _this.before(dom, container);
      _this.remove(container);
    } else if (_this.isTag(container, ['ol', 'ul'])) {
      while (container.lastChild) {
        _this.after(container.lastChild, container);
      }
      _this.remove(container);
    }
  };

  this.initDocHtml = function (docHtml) {
    var htmlReg = /<html[^<>]*>([\s\S]*)<\/html>/im;
    var htmlStrInner = docHtml.match(htmlReg);
    var docHtmlFull = htmlStrInner ? htmlStrInner[0] : null;

    var headReg = /(<head( [^<>]*)?>)/i;
    var htmlStartReg = /(<html( [^<>]*)?>)/i;
    var htmlEndReg = /(<\/html>)/i;
    var bodyStartReg = /(<body( [^<>]*)?>)/i;
    var bodyEndReg = /(<\/body>)/i;

    // 修正有错误结构的 html
    var docTypeReg = /(<\!DOCTYPE( [^<>]*)?>)/i;
    var headFullReg = /<head[^<>]*>([\s\S]*)<\/head>/im;
    var tagReg = /<[^<>]*>/i;
    var enterReg = /\r|\n/g;
    var tmpHtml = docHtml.replace(docTypeReg, '').replace(htmlReg, '').replace(tagReg, '').replace(enterReg, '').trim();
    if (tmpHtml.length > 0) {
      var headMatch = docHtml.match(headFullReg);
      var head = '';
      if (headMatch) {
        head = headMatch[0];
      }
      tmpHtml = docHtml.replace(htmlStartReg, '').replace(htmlEndReg, '').replace(bodyStartReg, '').replace(bodyEndReg, '');
      docHtml = '<!DOCTYPE html><html>' + head + '<body>' + tmpHtml + '</body></html>';
    }

    var base = '';
    if (env.client.type.isWeb && env.options.htmlBaseUrl) {
      base = '<base href="' + env.options.htmlBaseUrl + '" />';
    }

    //添加样式保证文字可以自动换行，避免 由于 很长的超链接 导致文本过长，从而引起 ios9 的bug 让 字体变大
    if (docHtml && headReg.test(docHtml)) {
      docHtmlFull = docHtml.replace(headReg, '$1' + base.escapeReplace());
    } else {
      docHtmlFull = docHtml.replace(htmlStartReg, '$1<head>' + base.escapeReplace() + '</head>');
      // } else {
      //   docHtmlFull = '<!DOCTYPE html><html><head>' + base + '</head><body>' + docHtml + '</body></html>';
    }

    return docHtmlFull;
  };

  /**
   * 判断 dom 是否为 块级元素
   */
  this.isBlock = function (dom, options) {
    if (!dom) {
      return false;
    }
    // if (dom.nodeType == 9 || dom.nodeType == 11) {
    //     return true;
    // }

    if (options && options.includeBr && _this.isTag(dom, 'br')) {
      return true;
    }
    if (_this.isWizDom(dom)) {
      // 对于 Wiz 专用 tag 全部认为是 block dom
      return true;
    }
    var displayValue = _this.getComputedStyle(dom, 'display', false);
    return !!displayValue && !/^(inline|inline-block|inline-table|none)$/i.test(displayValue);
  };

  /**
   * 判断 dom 是否为 document.body
   */
  this.isBody = function (dom) {
    return dom && dom === env.body;
  };

  /**
   * 判断 dom 是否为空（里面仅有 br 时 也被认为空）
   */
  this.isEmptyDom = function (dom) {
    if (!dom) {
      return false;
    }
    if (dom.nodeType === 3) {
      var v = dom.nodeValue;
      return utils.isEmpty(v);
    }

    if (dom.nodeType !== 1) {
      return true;
    }

    if (dom.childNodes.length === 0) {
      return _this.isTag(dom, 'br') || !_this.isSelfClosingTag(dom);
    }

    for (var i = 0, j = dom.childNodes.length; i < j; i++) {
      if (!_this.isEmptyDom(dom.childNodes[i])) {
        return false;
      }
    }
    return true;
  };

  /**
   * 判断 dom 内容是否为 填充的特殊字符
   */
  this.isFillChar = function (node, isInStart) {
    return node.nodeType === 3 && !node.nodeValue.replace(new RegExp((isInStart ? '^' : '') + CONST.FILL_CHAR), '').length;
  };

  this.isInWizBody = function (target) {
    return target === env.body || !!_this.getParentByFilter(target, function (dom) {
      return dom === env.body;
    }, true);
  };

  this.isParent = function (target, parent) {
    if (!target || !parent || target === parent) {
      return false;
    }
    while (target) {
      target = target.parentNode;
      if (target === parent) {
        return true;
      }
    }
    return false;
  };

  /**
   * 判断两个 dom 的 attribute 是否相同
   */
  this.isSameAttr = function (n, m) {
    var attrA = n.attributes,
        attrB = m.attributes;
    if (attrA.length !== attrB.length) {
      return false;
    }
    for (var i = 0, j = attrA.length; i < j; i++) {
      var a = attrA[i];
      if (a.name === 'style') {
        continue;
      }
      if (a.name === CONST.ATTR.SPAN_TIMESTAMP) {
        if (!utils.isSameAmendTime(a.value, attrB[a.name].value)) {
          return false;
        }
        // continue;
      } else if (!attrB[a.name] || attrB[a.name].value !== a.value) {
        return false;
      }
    }
    return true;
  };

  /**
   * 判断两个 span 属性（style & attribute）是否相同（属性相同且相邻的两个 span 才可以合并）
   */
  this.isSameSpan = function (n, m) {
    return !!n && !!m && n.nodeType === 1 && m.nodeType === 1 && _this.isTag(n, 'span') && n.tagName === m.tagName && n.getAttribute(CONST.ATTR.SPAN) === CONST.ATTR.SPAN && _this.isSameStyle(n, m) && _this.isSameAttr(n, m);
  };

  /**
   * 判断 dom 的 style （inline）是否相同
   */
  this.isSameStyle = function (n, m) {
    var styleA = {};
    var styleB = {};
    _this.appendStyle(n.getAttribute('style'), styleA);
    _this.appendStyle(m.getAttribute('style'), styleB);
    for (var k in styleA) {
      if (styleA.hasOwnProperty(k)) {
        if (styleB[k] !== styleA[k]) {
          return false;
        }
        delete styleA[k];
        delete styleB[k];
      }
    }
    for (var _k in styleB) {
      if (styleB.hasOwnProperty(_k)) {
        return false;
      }
    }
    return true;
  };

  /**
   * 判断 dom 是否为 自闭和标签 （主要用于清理冗余 dom 使用，避免 dom 被删除）
   */
  this.isSelfClosingTag = function (node) {
    var selfLib = /^(area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;
    return node && node.nodeType === 1 && selfLib.test(node.tagName);
  };

  /**
   * 判断 dom 是否为指定的 tagName
   */
  this.isTag = function (dom, tagNames) {
    if (!utils.isArray(tagNames)) {
      tagNames = [tagNames];
    }
    if (!dom || dom.nodeType !== 1) {
      return false;
    }
    var tag = dom.tagName.toLowerCase();
    for (var i = 0, j = tagNames.length; i < j; i++) {
      if (tag === tagNames[i].toLowerCase()) {
        return true;
      }
    }
    return false;
  };

  /**
   * 判断 TextNode 内容是否为 非空 有效
   */
  this.isUsableTextNode = function (node) {
    return node.nodeType === 3 && !utils.isEmpty(node.nodeValue);
  };

  this.isVisible = function (target) {
    return !!(target.offsetWidth || target.offsetHeight || target.getClientRects().length);
  };

  this.isWizDom = function (dom) {
    return dom.nodeType === 1 && /^wiz_/i.test(dom.tagName);
  };

  /**
   * 判断 dom 是否为 wiz 编辑器 的 span
   */
  this.isWizSpan = function (dom) {
    return !!dom && !!dom.getAttribute(CONST.ATTR.SPAN);
  };

  /**
   * 把 domA 合并到 domB （仅合并 attribute 和 style）
   */
  this.mergeAtoB = function (objA, objB, isOverlay) {
    _this.mergeStyleAToB(objA, objB, isOverlay);
    _this.mergeAttrAtoB(objA, objB, isOverlay);
  };

  /**
   * 把 domA 的属性（attribute） 合并到 domB
   */
  this.mergeAttrAtoB = function (objA, objB, isOverlay) {
    if (objA.nodeType !== 1 || objB.nodeType !== 1) {
      return;
    }
    var attrA = objA.attributes,
        attrB = objB.attributes,
        i = void 0,
        j = void 0,
        a = void 0;
    for (i = 0, j = attrA.length; i < j; i++) {
      a = attrA[i];
      if (a.name === 'style') {
        continue;
      }
      if (attrB[a.name] && !isOverlay) {
        continue;
      }
      var attr = {};
      attr[a.name] = a.value;
      _this.attr(objB, attr);
    }
  };

  /**
   * 合并 子节点中相邻且相同（style & attribute ）的 span
   * merge the same span with parent and child nodes.
   */
  this.mergeChildSpan = function (dom, excludeList) {
    if (!dom || dom.nodeType !== 1) {
      return;
    }
    for (var i = 0, j = dom.children.length; i < j; i++) {
      _this.mergeChildSpan(dom.children[i], excludeList);
    }
    _this.mergeSiblingSpan(dom, excludeList);

    var n = dom.children[0],
        tmp = void 0;
    if (!!n && excludeList.indexOf(n) < 0 && dom.childNodes.length === 1 && dom.getAttribute(CONST.ATTR.SPAN) === CONST.ATTR.SPAN && n.getAttribute(CONST.ATTR.SPAN) === CONST.ATTR.SPAN) {
      _this.mergeChildToParent(dom, n);
    } else {
      while (!!n) {
        if (excludeList.indexOf(n) < 0 && excludeList.indexOf(dom) < 0 && _this.isSameSpan(dom, n)) {
          tmp = n.previousElementSibling;
          _this.mergeChildToParent(dom, n);
          n = tmp ? tmp.nextElementSibling : dom.children[0];
        } else {
          n = n.nextElementSibling;
        }
      }
    }
  };

  /**
   * 将 子节点 合并到 父节点 （主要用于 嵌套的 span 合并）
   */
  this.mergeChildToParent = function (parent, child) {
    if (!parent || !child || child.parentNode !== parent) {
      return;
    }
    while (child.childNodes.length > 0) {
      _this.before(child.childNodes[0], child);
    }
    _this.mergeAtoB(parent, child, false);
    _this.mergeAtoB(child, parent, true);
    parent.removeChild(child);
  };

  /**
   * 配合 clearChild 方法合并末级 Dom 直到 指定的 Parent
   */
  this.mergeDomParent = function (dom, parentRoot) {
    var setStyle = function setStyle(key, value, styleMap) {
      key = key.trim();
      value = value ? value.trim() : '';
      if (value && !styleMap[key]) {
        styleMap[key] = value;
      }
    };
    var getStyle = function getStyle(_dom, styleMap) {
      var styleStr = _dom.getAttribute('style') || '';
      var styleList = styleStr.split(';');
      for (var i = 0, j = styleList.length; i < j; i++) {
        if (styleList[i].indexOf(':') > 0) {
          var t = styleList[i].split(':');
          setStyle(t[0], t[1], styleMap);
        }
      }
      if (_this.isTag(_dom, ['strong', 'b'])) {
        setStyle('font-weight', 'bold', styleMap);
      } else if (_this.isTag(_dom, ['i', 'em'])) {
        setStyle('font-style', 'italic', styleMap);
      } else if (_this.isTag(_dom, ['u', 'ins'])) {
        setStyle('text-decoration', 'underline', styleMap);
      }
    };

    var styleMap = {};
    var tmp = dom;
    getStyle(tmp, styleMap);
    while (tmp) {
      tmp = tmp.parentNode;
      if (!tmp || tmp === parentRoot || tmp === env.body) {
        break;
      }
      getStyle(tmp, styleMap);
    }
    var style = [];
    for (var key in styleMap) {
      style.push(key + ':' + styleMap[key]);
    }
    parentRoot.removeChild(parentRoot.firstChild);
    _this.attr(dom, { style: style.join(';') });
    parentRoot.appendChild(dom);
    // console.log(dom);
  };

  /**
   * 合并相邻且相同（style & attribute ）的 span
   * @param parentDom
   * @param excludeList
   */
  this.mergeSiblingSpan = function (parentDom, excludeList) {
    var n = parentDom.childNodes[0],
        m = void 0,
        tmp = void 0;
    if (!n) {
      return;
    }
    while (n) {
      m = n.nextSibling;
      if (m && excludeList.indexOf(m) < 0 && excludeList.indexOf(n) < 0 && _this.isSameSpan(n, m)) {
        while (m.childNodes.length) {
          tmp = m.childNodes[0];
          if (tmp && (tmp.innerHTML || tmp.nodeValue && tmp.nodeValue !== CONST.FILL_CHAR)) {
            n.appendChild(tmp);
          } else {
            m.removeChild(tmp);
          }
        }
        _this.remove(m);
      } else {
        n = m;
      }
    }
  };

  /**
   * 把 domA 的样式（style） 合并到 domB
   */
  this.mergeStyleAToB = function (objA, objB, isOverlay) {
    if (objA.nodeType !== 1 || objB.nodeType !== 1) {
      return;
    }
    var sA = objA.getAttribute('style'),
        sB = objB.getAttribute('style') || '';
    if (!sA) {
      return;
    }
    var styleObj = {};
    if (!!isOverlay) {
      _this.appendStyle(sB, styleObj);
      _this.appendStyle(sA, styleObj);
    } else {
      _this.appendStyle(sA, styleObj);
      _this.appendStyle(sB, styleObj);
    }

    var result = [];
    for (var k in styleObj) {
      // merge 时 忽略 display 属性
      if (styleObj.hasOwnProperty(k) && k !== 'display') {
        result.push(k + ':' + styleObj[k]);
      }
    }
    _this.attr(objB, { style: result.join(';') });
  };

  this.modifyChildNodesStyle = function (dom, style, attr) {
    if (!dom) {
      return;
    }
    var ns = dom.childNodes,
        done = false;
    for (var i = 0; i < ns.length; i++) {
      var item = ns[i];
      if (!done && _this.isUsableTextNode(item)) {
        done = true;
        _this.modifyStyle(dom, style, attr);
      } else if (item.nodeType === 1) {
        _this.modifyChildNodesStyle(item, style, attr);
      }
    }
  };

  /**
   * 修改 Dom 的样式（style） & 属性（attribute）
   */
  this.modifyNodeStyle = function (item, style, attr, isLast) {
    if (item.nodeType === 1) {
      if (_this.isSelfClosingTag(item)) {
        _this.modifyStyle(item, style, attr);
      } else {
        _this.modifyChildNodesStyle(item, style, attr);
      }
    } else if (_this.isUsableTextNode(item)) {
      item = _this.splitRangeText(item, null, null, isLast);
      _this.modifyStyle(item, style, attr);
    }
    return item;
  };

  /**
   * 修改 集合中所有 Dom 的样式（style） & 属性（attribute）
   */
  this.modifyNodesStyle = function (domList, style, attr) {
    if (domList.length === 0) {
      return;
    }
    for (var i = 0, j = domList.length; i < j; i++) {
      var item = domList[i];
      domList[i] = _this.modifyNodeStyle(item, style, attr, i === j - 1);
    }
  };

  /**
   * 修改样式（style） & 属性（attribute）后，进行清理操作
   */
  this.modifyNodesStyleAndClear = function (domList, style, attr, excludeList) {
    //modify style
    _this.modifyNodesStyle(domList, style, attr);
    //clear redundant span & TextNode
    var ps = [],
        t = void 0,
        tempAmend = void 0;
    for (var i = 0, j = domList.length; i < j; i++) {
      t = domList[i].parentNode;
      if (!t) {
        continue;
      }
      if (ps.indexOf(t) < 0) {
        ps.push(t);
      }
    }
    //获取需要重构的 dom 集合共同的 parent 节点
    t = _this.getParentRoot(ps);
    //如果是 修订节点，则找到修订节点的 父节点进行清理操作
    tempAmend = _this.getWizAmendParent(t);
    t = tempAmend ? tempAmend.parentNode : t;
    _this.clearChildSpan(t, excludeList);
  };

  /**
   * 修改 Dom 的样式（style） & 属性（attribute）
   */
  this.modifyStyle = function (dom, style, attr) {
    var isSelfClosingTag = _this.isSelfClosingTag(dom);
    var isTodoCheckbox = _this.hasClass(dom, CONST.CLASS.TODO_CHECKBOX);
    if (isTodoCheckbox) {
      // TodoCheckbox 禁止通过此方法修改样式和属性
      return;
    }
    // 自闭合标签 不允许设置 新增的修订标识
    if (attr && attr[CONST.ATTR.SPAN_INSERT] && isSelfClosingTag) {
      return;
    }

    var d = dom;
    // 把 A 标签的子节点封装到一个 span 内，用于拆分
    var filterForA = function filterForA(aObj) {
      if (!aObj) {
        return;
      }
      var span = _this.createSpan();
      _this.attr(span, { style: aObj.getAttribute('style') || '' });
      _this.attr(aObj, { style: null });
      while (aObj.firstChild) {
        span.insertBefore(aObj.firstChild, null);
      }
      aObj.insertBefore(span, null);
    };

    if (attr && (attr[CONST.ATTR.SPAN_INSERT] || attr[CONST.ATTR.SPAN_DELETE])) {
      // 如果 dom 是 修订的内容， 且设定修订内容 则必须要针对 修订DOM 处理
      d = _this.getWizAmendParent(dom);
      if (!d) {
        d = dom;
      } else {
        dom = null;
      }
    }

    if (!!dom && !isSelfClosingTag && (!_this.isTag(dom, 'span') || dom.getAttribute(CONST.ATTR.SPAN) !== CONST.ATTR.SPAN)) {
      d = _this.createSpan();
      dom.insertBefore(d, null);
      while (dom.childNodes.length > 1) {
        d.insertBefore(dom.childNodes[0], null);
      }
    }

    // 遍历 style ，检查是否有需要清空的样式
    var k = void 0,
        v = void 0,
        hasClearList = [];
    for (k in style) {
      if (style.hasOwnProperty(k)) {
        v = style[k];
        if (!v) {
          hasClearList.push(k);
        }
      }
    }
    // 如果有 需要清空的 style，则需要拆分父节点
    var tmpP = d,
        tmpA = void 0,
        p = d;
    if (hasClearList.length > 0) {
      // 找到 行级元素顶级节点
      while (tmpP) {
        // if (tmpP.getAttribute(CONST.ATTR.SPAN) !== CONST.ATTR.SPAN) {
        // block 或 TodoMain 的 span 都禁止拆分
        if (_this.isBlock(tmpP) || _this.hasClass(tmpP, CONST.CLASS.TODO_MAIN)) {
          break;
        }
        if (_this.isTag(tmpP, 'a')) {
          tmpA = tmpP;
        }
        p = tmpP;
        tmpP = p.parentNode;
      }
      // 如果父节点有 A 标签，需要特殊处理，避免 清理样式时 A 标签被拆分成多个
      if (!tmpA) {
        _this.splitDomSingle(p, d);
      } else if (tmpA === p) {
        filterForA(tmpA);
        _this.splitDomSingle(tmpA.firstChild, d);
      } else {
        _this.splitDomSingle(p, tmpA);
        filterForA(tmpA);
        _this.splitDomSingle(tmpA.firstChild, d);
      }
    }
    _this.css(d, style);
    _this.attr(d, attr);
  };

  /**
   * 将 table 容器内 非 table 内容移出
   */
  this.moveOutFromTableContainer = function (container) {
    if (!container) {
      return;
    }

    var move = function move(mainDom, _container) {
      if (!mainDom || !_container) {
        return;
      }

      var isInContainer = mainDom === _container;
      var childList = void 0,
          dom = void 0,
          target = void 0,
          i = void 0,
          before = false,
          hasTableChild = false;
      childList = _container.childNodes;
      target = mainDom;
      for (i = childList.length - 1; i >= 0; i--) {
        dom = childList[i];
        // 遍历 chlidren 时，在 table 之前 before 为 true；在 table 之后 before 为 false
        if (dom.nodeType === 1 && (isInContainer && _this.hasClass(dom, CONST.CLASS.TABLE_BODY) || !isInContainer && _this.isTag(dom, ['table', CONST.TAG.TMP_TAG]))) {
          if (!hasTableChild) {
            // hasTableChild 必须要进行判断，
            // 否则由于用户反复编辑有可能会出现 一个 container 下有多个 tableBody 的情况，从而导致渲染后 table 消失
            if (_this.hasClass(dom, CONST.CLASS.TABLE_BODY) || _this.isTag(dom, 'table')) {
              before = true;
              hasTableChild = true;
            }
            continue;
          }
        }
        if (_this.hasClass(dom, CONST.CLASS.TABLE_TOOLS)) {
          // Table Tools 不能被移出，否则会导致 Tools 的位置异常
          continue;
        }
        _this.before(dom, target, !before);
        // 往前放的时候， 必须每次更换 target，否则 DOM 顺序会错误
        if (before) {
          target = dom;
        }
      }

      if (_container.childNodes.length === 0) {
        // 如果 table 容器内清空，则删除 容器
        _this.remove(mainDom);
      }
    };

    move(container, container);
    move(container, container.querySelector('.' + CONST.CLASS.TABLE_BODY));
  };

  this.packageChildNodesByDiv = function (dom) {
    if (dom.childNodes.length === 1 && _this.isBlock(dom.firstChild)) {
      // 如果 dom 仅有一个 child 且为 block，则直接返回
      return dom.firstChild;
    }
    var tmp = env.doc.createElement('div');
    while (dom.firstChild) {
      tmp.appendChild(dom.firstChild);
    }
    dom.appendChild(tmp);
    return tmp;
  };
  // /**
  //  * 针对 body、td、th 内的 textNode 封装 div
  //  */
  // this.packageByDiv = (dom) => {
  //   let p, packDiv;
  //   p = dom;
  //   while (p) {
  //     if (this.isBlock(p)) {
  //       packDiv = p;
  //       p = null;
  //       break;
  //     }
  //     if (this.isTag(p.parentNode, ['body', 'td', 'th'])) {
  //       break;
  //     }
  //
  //     p = p.parentNode;
  //   }
  //
  //   if (packDiv) {
  //     return packDiv;
  //   }
  //
  //   let start = p,
  //     end = p, next, isLast, tmp;
  //   while (start) {
  //     tmp = start.previousSibling;
  //     if (!tmp || this.isBlock(tmp)) {
  //       break;
  //     }
  //     start = tmp;
  //   }
  //   while (end) {
  //     tmp = end.nextSibling;
  //     if (!tmp || this.isBlock(tmp)) {
  //       break;
  //     }
  //     end = tmp;
  //   }
  //
  //   packDiv = env.doc.createElement('div');
  //   this.before(packDiv, start);
  //   tmp = start;
  //   do {
  //     next = tmp.nextSibling;
  //     packDiv.appendChild(tmp);
  //     isLast = tmp === end;
  //     tmp = next;
  //   } while (!isLast);
  //
  //   return packDiv;
  // };

  /**
   * 将 dom 剥壳
   */
  this.peelDom = function (dom, checkFun) {
    if (!dom || dom.nodeType === 3) {
      return;
    }
    var result = {
      start: null,
      end: null
    };
    var childNodes = void 0,
        child = void 0,
        i = void 0;
    childNodes = dom.childNodes;
    for (i = childNodes.length - 1; i >= 0; i--) {
      child = childNodes[i];
      if (!checkFun || checkFun(child)) {
        _this.after(child, dom);
        if (!result.start) {
          result.start = child;
          result.end = child;
        } else {
          result.end = child;
        }
      }
    }
    _this.remove(dom);
    return result;
  };

  /**
   * 从 dom 中清除指定 tag 标签，但保留 innerHTML
   */
  this.peelTag = function (tagName) {
    var list = env.body.querySelectorAll(tagName),
        i = void 0,
        tag = void 0;
    for (i = list.length - 1; i >= 0; i--) {
      tag = list[i];
      while (tag.firstChild) {
        _this.before(tag.firstChild, tag);
      }
      _this.remove(tag);
    }
  };

  /**
   * 从 html 源码中清除指定 tag 标签，但保留 innerHTML
   */
  this.peelTagFromHtml = function (html, tag) {
    var reg = new RegExp('<' + tag + '( [^>]*)?>|<\/' + tag + '>', 'ig');
    return html.replace(reg, '');
  };

  /**
   * 生成并返回当前设备 1pt 对应 px 的值
   */
  this.pt2px = function () {
    var pt2px = void 0;
    var span = document.createElement('span');
    span.style.visibility = 'hidden';
    span.style.position = 'absolute';
    span.style.top = '0';
    span.style.left = '0';
    span.style.fontSize = defaultFontSize + 'pt';
    env.body.appendChild(span);
    pt2px = env.win.getComputedStyle(span).fontSize;
    pt2px = parseInt(pt2px, 10) / defaultFontSize;
    env.body.removeChild(span);
    _this.pt2px = function () {
      return pt2px;
    };
    // console.log('1pt == ' + pt2px + 'px');
    return pt2px;
  };

  /**
   * 移除 Dom
   */
  this.remove = function (dom) {
    if (!dom || !dom.parentNode) {
      return;
    }
    dom.parentNode.removeChild(dom);
  };

  /**
   * 移除 class name
   */
  this.removeClass = function (domList, className) {
    if (!domList) {
      return;
    }
    if (!!domList.nodeType) {
      domList = [domList];
    }
    if (!utils.isArray(className)) {
      className = [className];
    }
    for (var i = domList.length - 1; i >= 0; i--) {
      var dom = domList[i];
      if (dom.nodeType === 1) {
        dom.className = " " + dom.className + " ";
        for (var j = className.length; j >= 0; j--) {
          var css = className[j];
          dom.className = dom.className.replace(' ' + css + ' ', ' ');
        }
        dom.className = dom.className.trim();
      }
    }
  };

  /**
   * 从 Dom 中清除指定 name 的 tag
   */
  this.removeByName = function (name) {
    var s = env.doc.getElementsByName(name);
    for (var i = s.length - 1; i >= 0; i--) {
      var dom = s[i];
      _this.remove(dom);
    }
  };

  /**
   * 从 Dom 中清除指定 的 tag
   */
  this.removeByTag = function (tag) {
    var s = env.doc.getElementsByTagName(tag);
    for (var i = s.length - 1; i >= 0; i--) {
      var dom = s[i];
      _this.remove(dom);
    }
  };

  /**
   * 在删除 当前用户已删除 指定的Dom 后， 判断其 parentNode 是否为空，如果为空，继续删除
   */
  this.removeEmptyParent = function (pDom) {
    if (!pDom) {
      return;
    }
    var p = void 0;
    if (_this.isEmptyDom(pDom)) {
      if (pDom === env.body) {
        //如果 pDom 为 body | td | th 且为空， 则添加 div & br 标签
        pDom.innerHTML = '<div><br/></div>';
      } else if (_this.isTag(pDom, ['td', 'th'])) {
        //如果 pDom td | th 且为空， 则添加 br 标签
        pDom.innerHTML = '<br/>';
      } else {
        p = pDom.parentNode;
        if (p) {
          p.removeChild(pDom);
          _this.removeEmptyParent(p);
        }
      }
    }
  };

  /**
   * 从 dom 集合中删除符合特殊规则的 dom
   */
  this.removeListFilter = function (domList, filter) {
    var removeList = [],
        dom = void 0;
    if (!domList || !filter) {
      return removeList;
    }
    for (var i = domList.length - 1; i >= 0; i--) {
      dom = domList[i];
      if (filter(dom)) {
        removeList.unshift(domList.splice(i, 1)[0]);
      }
    }
    return removeList;
  };

  /**
   * 从 html 源码中清除指定 name 的 style
   * 因为使用正则，不可能直接将 有嵌套 div 的div html 代码删除，所以此函数只能针对 style 等不会包含 html 代码的 tag 进行操作
   */
  this.removeStyleByNameFromHtml = function (html, nameList) {
    var name = '(' + nameList.join('|') + ')';
    var regStyle = new RegExp('<style( ([^<>])+[ ]+|[ ]+)name *= *([\'"])' + name + '\\3[^<>]*>[^<]*<\/style>', 'ig');
    var regLink = new RegExp('<link( ([^<>])+[ ]+|[ ]+)name *= *([\'"])' + name + '\\3[^<>]*>', 'ig');
    return html.replace(regStyle, '').replace(regLink, '');
  };

  /**
   * 从 html 源码中清除指定 id 的 style
   * 因为使用正则，不可能直接将 有嵌套 div 的div html 代码删除，所以此函数只能针对 style 等不会包含 html 代码的 tag 进行操作
   */
  // this.removeStyleByIdFromHtml = (html, idList) => {
  //   let id = '(' + idList.join('|') + ')';
  //   let regStyle = new RegExp('<style( ([^<>])+[ ]+|[ ]+)id *= *([\'"])' + id + '\\3[^<>]*>[^<]*<\/style>', 'ig');
  //   let regLink = new RegExp('<link( ([^<>])+[ ]+|[ ]+)id *= *([\'"])' + id + '\\3[^<>]*>', 'ig');
  //   return html.replace(regStyle, '').replace(regLink, '');
  // };

  // this.removeViewportFromHtml = (html, tag) => {
  //   //检查 head 内存在 viewport 才删除，避免将 code 内的 viewport 删除
  //   if (env.body.querySelector('head meta[name=viewport]')) {
  //     let reg = new RegExp('<meta( ([^<>])+[ ]+|[ ]+)name *= *([\'"])viewport\\3[^<>]*>', 'i');
  //     return html.replace(reg, '');
  //   }
  //   return html;
  // };

  this.replaceTagName = function (dom, tagName) {
    if (_this.isTag(dom, tagName)) {
      return dom;
    }
    var isTodo = _this.hasClass(dom, CONST.CLASS.TODO_LAYER);
    var tag = env.doc.createElement(tagName);
    _this.after(tag, dom);
    while (dom.firstChild) {
      tag.appendChild(dom.firstChild);
    }
    if (isTodo) {
      if (dom.className) {
        tag.className = dom.className;
      }
      if (dom.id) {
        tag.id = dom.id;
      }
    }
    _this.remove(dom);
    return tag;
  };

  /**
   * 从 html 源码中清除指定的 tag （注意，一定要保证该 tag 内不存在嵌套同样 tag 的情况）
   */
  this.removeByTagFromHtml = function (html, tag) {
    var reg = new RegExp('<' + tag + '( [^>]*)?>((?!<\/' + tag + '>).|\r|\n)*?<\/' + tag + '>', 'ig');
    return html.replace(reg, '');
  };

  /**
   * 根据 查询表达式 查找 dom，并放到 list 集合内
   */
  this.search = function (dom, expStr, list) {
    var tmpList = dom.querySelectorAll(expStr),
        i = void 0,
        j = void 0,
        d = void 0;
    list = list ? list : [];
    for (i = 0, j = tmpList.length; i < j; i++) {
      d = tmpList[i];
      list.push(d);
    }
  };

  /**
   * 设置区域可编辑
   */
  this.setContenteditable = function (content, enable) {
    if (!content && env.win.WizTemplate) {
      env.win.WizTemplate.setContenteditable(enable);
    } else {
      if (!content) {
        content = env.body;
      }
      _this.attr(content, { contenteditable: enable ? 'true' : 'false' });
    }
    if (content === env.body) {
      // patch for table
      var tableBodyList = env.body.querySelectorAll('.' + CONST.CLASS.TABLE_BODY);
      for (var i = tableBodyList.length - 1; i >= 0; i--) {
        var tableBody = tableBodyList[i];
        if (!_this.checkInTmp(tableBody)) {
          _this.attr(tableBody, { contenteditable: enable ? 'true' : 'false' });
        }
      }
    }
  };

  /**
   * 自动布局（根据 target 的位置 以及 屏幕大小，设置 layerObj 的坐标，保证在可视区域内显示）
   * options {layerObj, target, layout, fixed, noSpace, reverse}
   */
  this.setLayout = function (options) {
    var layerObj = options.layerObj,
        target = options.target,
        layout = options.layout,
        fixed = !!options.fixed,
        noSpace = options.noSpace,
        reverse = !!options.reverse;

    var confirmPos = _this.getPosition(layerObj),
        targetPos = target.nodeType ? _this.getPosition(target) : target,
        scrollPos = _this.getPageScroll(),
        winWidth = env.doc.documentElement.clientWidth,
        winHeight = env.doc.documentElement.clientHeight,
        marginTop = env.win.getComputedStyle(env.doc.body, null)['margin-top'],
        left = '50%',
        top = '30%',
        mTop = 0,
        mLeft = -confirmPos.width / 2,
        minWidth = void 0,
        maxWidth = void 0,
        minHeight = void 0,
        maxHeight = void 0;

    var bodyTop = void 0;
    //iphone 客户端 编辑时 window 窗口顶端有其他 window 遮罩， 所以必须要计算 body 的 margin-top
    if (!!marginTop) {
      bodyTop = parseInt(marginTop);
      if (isNaN(bodyTop)) {
        bodyTop = 0;
      }
    }
    if (fixed) {
      minWidth = 0;
      maxWidth = winWidth - 5; //右侧需要保留一些空间，避免有时候超出
      minHeight = bodyTop;
      maxHeight = winHeight;
    } else {
      minWidth = 0 + scrollPos.left;
      maxWidth = winWidth + scrollPos.left - 5; //右侧需要保留一些空间，避免有时候超出
      minHeight = bodyTop + (scrollPos.top <= bodyTop ? 0 : Math.abs(scrollPos.top - bodyTop));
      maxHeight = winHeight + scrollPos.top;
    }

    if (targetPos && layout) {
      mTop = 0;
      mLeft = 0;
      if (layout === CONST.TYPE.POS.upLeft || layout === CONST.TYPE.POS.upRight) {
        top = targetPos.top - confirmPos.height - (noSpace ? 0 : CONST.AMEND.INFO_SPACE);
      } else if (layout === CONST.TYPE.POS.downLeft || layout === CONST.TYPE.POS.downRight) {
        top = targetPos.top + targetPos.height + (noSpace ? 0 : CONST.AMEND.INFO_SPACE);
      } else if (layout === CONST.TYPE.POS.leftUp || layout === CONST.TYPE.POS.leftDown) {
        left = targetPos.left - confirmPos.width - (noSpace ? 0 : CONST.AMEND.INFO_SPACE);
      } else if (layout === CONST.TYPE.POS.rightUp || layout === CONST.TYPE.POS.rightDown) {
        left = targetPos.left + targetPos.width + (noSpace ? 0 : CONST.AMEND.INFO_SPACE);
      }

      if (layout === CONST.TYPE.POS.upLeft || layout === CONST.TYPE.POS.downLeft) {
        left = targetPos.left;
        if (fixed) {
          left -= scrollPos.left;
        }
      } else if (layout === CONST.TYPE.POS.upRight || layout === CONST.TYPE.POS.downRight) {
        left = targetPos.left + targetPos.width - confirmPos.width;
        if (fixed) {
          left -= scrollPos.left;
        }
      } else if (layout === CONST.TYPE.POS.leftUp || layout === CONST.TYPE.POS.rightUp) {
        top = targetPos.top;
        if (fixed) {
          top -= scrollPos.top;
        }
      } else if (layout === CONST.TYPE.POS.leftDown || layout === CONST.TYPE.POS.rightDown) {
        top = targetPos.top + targetPos.height - confirmPos.height;
        if (fixed) {
          top -= scrollPos.top;
        }
      }

      if (left + confirmPos.width > maxWidth) {
        left = maxWidth - confirmPos.width;
      }
      if (left < minWidth) {
        left = minWidth;
      }
      if (top + confirmPos.height > maxHeight) {
        top = maxHeight - confirmPos.height;
      }
      if (reverse && top < minHeight) {
        top = targetPos.top + targetPos.height;
      }
      if (top < minHeight || top + confirmPos.height > maxHeight) {
        top = minHeight;
      }
    }
    _this.css(layerObj, {
      left: left + 'px',
      top: top + 'px',
      'margin-top': mTop + 'px',
      'margin-left': mLeft + 'px'
    });
  };

  /**
   * 设置横向 页面滚动条位置
   */
  this.setPageScrollLeft = function (left) {
    var target = env.scrollContainer;
    var doc = void 0;
    if (target === env.doc.body) {
      doc = env.doc;
    } else if (target === window.document.body) {
      doc = window.document;
    }
    if (doc && typeof doc.compatMode !== 'undefined' && doc.compatMode !== 'BackCompat') {
      // PC 客户端 webview 版本有问题，不支持 documentElement
      doc.body.scrollLeft = left;
      doc.documentElement.scrollLeft = left;
    } else if (target) {
      target.scrollLeft = left;
    }
  };

  this.setPageScrollTop = function (top) {
    // let debugTimerId = 'setPageScrollTop()';
    // window.wizDebugTimer.start(debugTimerId);

    var target = env.scrollContainer;
    var doc = void 0;
    if (target === env.doc.body) {
      doc = env.doc;
    } else if (target === window.document.body) {
      doc = window.document;
    }
    // window.wizDebugTimer.add(debugTimerId, 'init doc');

    // 文档内容过多时，设置 滚动条位置会导致性能问题，
    // 这里通过 setTimeout进行处理
    setTimeout(function () {
      if (doc && typeof doc.compatMode !== 'undefined' && doc.compatMode !== 'BackCompat') {
        // PC 客户端 webview 版本有问题，不支持 documentElement
        doc.body.scrollTop = top;
        doc.documentElement.scrollTop = top;
      } else if (target) {
        target.scrollTop = top;
      }
    }, 0);
    // window.wizDebugTimer.add(debugTimerId, 'set scroll top');
    // window.wizDebugTimer.end(debugTimerId);
  };
  /**
   * 设置纵向 页面滚动条位置
   */
  this.setPageScrollTopTimer = null;
  this.setPageScrollTopAni = function (top) {
    // console.log('setPageScrollTopAni: ' + top);
    if (_this.setPageScrollTopTimer) {
      clearTimeout(_this.setPageScrollTopTimer);
    }
    var startTime = new Date().valueOf();
    var startScroll = _this.getPageScroll();
    var change = top - startScroll.top;
    var during = 250;
    var lastTop = startScroll.top;
    // console.log('setPageScrollTop: ' + top);

    var scrollTo = function scrollTo() {
      var curScroll = _this.getPageScroll();
      // console.log('curScroll.top: ' + curScroll.top);
      if (Math.abs(curScroll.top - lastTop) > 30) {
        // console.log('curScroll.top: ' + curScroll.top);
        return;
      }

      var curTime = new Date().valueOf() - startTime;
      if (curTime > during) {
        curTime = during;
      }
      // console.log([curTime, startScroll.top, change, during].join(', '));
      var _top = easeOut(curTime, startScroll.top, change, during);
      // console.log(_top);
      _this.setPageScrollTop(_top);
      if (change > 0 && _top < top || change < 0 && _top > top) {
        // console.log(_top);
        lastTop = _top;
        _this.setPageScrollTopTimer = setTimeout(scrollTo, 20);
      }
    };

    scrollTo();

    // t: 当前时间
    // b: 初始值
    // c: 变化量
    // d: 持续时间
    function easeOut(t, b, c, d) {
      return -c * (t /= d) * (t - 2) + b;
    }
  };

  /**
   * 设置 textarea 的值
   */
  this.setTextarea = function (textarea, text) {
    var textType = textarea.textContent === undefined ? 'innerText' : 'textContent';
    if (text) {
      textarea[textType] = utils.replaceSpecialChar(text);
      return;
    }
    if (textarea.value !== textarea[textType]) {
      textarea[textType] = textarea.value;
    }
  };

  /**
   * 将 mainDom 以子节点 subDom 之后为分割点 分割为两个 mainDom（用于 修订处理）
   * 返回 subDom 所在的 mainDom
   */
  this.splitDomAfterSub = function (mainDom, subDom) {
    var tmpP = void 0,
        next = void 0;

    // 拆分 subDom 后面的内容
    if (!subDom.nextSibling) {
      tmpP = subDom.parentNode;
      while (tmpP && tmpP !== mainDom) {
        // if (tmpP.getAttribute(CONST.ATTR.SPAN) !== CONST.ATTR.SPAN) {
        // if (this.isBlock(tmpP)) {
        //     break;
        // }
        next = tmpP.nextSibling;
        if (!!next) {
          break;
        }
        tmpP = tmpP.parentNode;
      }
    } else {
      next = subDom.nextSibling;
    }
    if (next) {
      _this.splitDomBeforeSub(mainDom, next);
    }
    return mainDom;
  };

  /**
   * 将 mainDom 以子节点 subDom 之前为分割点 分割为两个 mainDom（用于 修订处理）
   * 返回 subDom 所在的 mainDom
   */
  this.splitDomBeforeSub = function (mainDom, subDom) {
    if (!mainDom || !subDom) {
      return mainDom;
    }
    var parents = [subDom],
        p = subDom.parentNode;
    var isFirstChild = p.firstChild === subDom;
    while (p) {
      parents.push(p);
      if (isFirstChild && p.parentNode.firstChild !== p) {
        isFirstChild = false;
      }
      if (p === mainDom) {
        break;
      }
      p = p.parentNode;
    }
    if (isFirstChild) {
      // 如果 subDom 每一个父节点（包括 subDom） 都是 firstChild， 则不进行拆分
      return mainDom;
    }

    // 如果 subDom 不是 mainDom 的子孙节点直接返回
    if (parents[parents.length - 1] !== mainDom) {
      return mainDom;
    }
    while (parents.length > 1) {
      parents[1] = split(parents[1], parents[0]);
      parents.splice(0, 1);
    }

    return parents[0];

    function split(parent, child) {
      var p = parent.parentNode,
          pCopy = parent.cloneNode(false),
          next = void 0;

      while (child) {
        next = child.nextSibling;
        pCopy.appendChild(child);
        child = next;
      }
      p.insertBefore(pCopy, parent.nextSibling);
      return pCopy;
    }
  };

  /**
   * 将 mainDom 以子节点 subDom 前后为分割点，把 subDom 独立于 前后 元素独立拆分成 3 段，并且保持 Dom 结构
   */
  this.splitDomSingle = function (mainDom, subDom) {
    if (mainDom && subDom && mainDom.nodeType === 1 && subDom === mainDom.firstChild && mainDom.childNodes.length === 1) {
      return mainDom;
    }

    // 拆分 subDom 前面的内容
    var mainP = _this.splitDomBeforeSub(mainDom, subDom);
    mainP = _this.splitDomAfterSub(mainP, subDom);
    return mainP;
  };

  /**
   * 根据 光标选择范围 拆分 textNode
   * splitRangeText 不能返回 TextNode，所以在 wizSpan 内要把 TextNode 独立分割出来，然后返回其 parentNode
   */
  this.splitRangeText = function (node, start, end, isLast) {
    if (!_this.isUsableTextNode(node)) {
      return node;
    }
    var p = void 0,
        s = void 0,
        t = void 0,
        v = node.nodeValue;
    p = node.parentNode;
    //            var isWizSpan = this.isWizSpan(p);
    s = _this.createSpan();

    if (!start && !end || start === 0 && end === node.nodeValue.length) {
      //the range is all text in this node
      // td,th 必须特殊处理，否则会导致 td 被添加 修订样式
      if (p.childNodes.length > 1 || _this.isTag(p, ['td', 'th'])) {
        if (isLast) {
          p.insertBefore(s, node);
        } else {
          p.insertBefore(s, node.nextSibling);
        }
        s.appendChild(node);
      } else {
        //if textNode is the only child node, return its parent node.
        s = p;
      }
    } else if (start === 0) {
      //the range is [0, n] (n<length)
      s.textContent = v.substring(start, end);
      p.insertBefore(s, node);
      node.nodeValue = v.substring(end);
    } else if (!end || end === node.nodeValue.length) {
      s.textContent = v.substring(start);
      p.insertBefore(s, node.nextSibling);
      node.nodeValue = v.substring(0, start);
    } else {
      //the range is [m, n] (m>0 && n<length)
      t = env.doc.createTextNode(v.substring(end));
      s.textContent = v.substring(start, end);
      p.insertBefore(s, node.nextSibling);
      p.insertBefore(t, s.nextSibling);
      //必须要先添加文字，最后删除多余文字，否则，如果先删除后边文字，会导致滚动条跳动
      node.nodeValue = v.substring(0, start);
    }
    return s;
  };
};

module.exports = DomUtils;

},{"../config/const":388,"../libs/utils":400}],343:[function(require,module,exports){
'use strict';

/**
 * 代码区域操作核心包 core
 */
var CONST = require('../config/const');
var utils = require('../libs/utils');

var FormatStyleList = ['background', 'background-color', 'color', 'font-family', 'font-size', 'font-weight', 'font-style', 'text-decoration', 'text-align'];
var FormatTitleList = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
var FormatSubSupList = ['sub', 'sup'];
var FormatFontList = ['b', 'i', 'u', 'strike'];
var FormatCommand = {
  'b': 'bold',
  'div': 'formatBlock',
  'h1': 'formatBlock',
  'h2': 'formatBlock',
  'h3': 'formatBlock',
  'h4': 'formatBlock',
  'h5': 'formatBlock',
  'h6': 'formatBlock',
  'i': 'italic',
  'strike': 'strikeThrough',
  'sub': 'subscript',
  'sup': 'superscript',
  'u': 'underline',
  'text-align-center': 'justifyCenter',
  'text-align-justify': 'justifyFull',
  'text-align-left': 'JustifyLeft',
  'text-align-right': 'JustifyRight'
};

var FormatPainter = function FormatPainter() {
  var _this = this;

  var core = null;
  var env = null;
  var codeUtils = null;
  var commandExtend = null;
  var domUtils = null;
  var historyUtils = null;
  var rangeUtils = null;
  var tableCore = null;
  var tableZone = null;
  var wizStyle = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    codeUtils = core.require.codeUtils;
    commandExtend = core.require.commandExtend;
    domUtils = core.require.domUtils;
    historyUtils = core.require.historyUtils;
    rangeUtils = core.require.rangeUtils;
    tableCore = core.require.tableCore;
    tableZone = core.require.tableZone;
    wizStyle = core.require.wizStyle;
  };

  var keepFormat = false;
  var target = void 0;

  var analyseStyle = function analyseStyle(start, obj, styleList, result) {
    var startComputeStyle = env.win.getComputedStyle(start);
    for (var i = styleList.length - 1; i >= 0; i--) {
      var name = styleList[i];
      var style = obj.style[name];
      // 需要考虑 <font color="red"> 的情况
      if (!style && name === 'color' && domUtils.isTag(obj, 'font')) {
        style = obj.getAttribute(name);
      }
      if (style && domUtils.getFontSizeRem(style) === domUtils.getFontSizeRem(startComputeStyle[name])) {
        styleList.splice(i, 1);
        result[name] = style;
      }
    }
    // obj.style;
  };
  var checkBlockTag = function checkBlockTag(tagName) {
    return tagName.charAt(0) === 'h' || tagName === 'div';
  };
  var checkSubSupTag = function checkSubSupTag(tagName) {
    return (/sub|sup/i.test(tagName)
    );
  };
  var getStyle = function getStyle(start) {
    var styleList = FormatStyleList.concat(),
        styleResult = {};
    var tagList = FormatTitleList.concat(FormatSubSupList, FormatFontList);
    var tagMap = {},
        tagName = void 0,
        tagObj = void 0;
    var hasTitle = false,
        hasSubSup = false,
        hasI = false,
        hasB = false;
    var startObj = start.nodeType === 1 ? start : start.parentNode;
    var obj = startObj;

    // 逐级查找 style 属性
    while (obj && obj !== env.body) {
      analyseStyle(startObj, obj, styleList, styleResult);
      obj = obj.parentNode;
    }

    // 设置不存在的 style 为 null
    for (var i = styleList.length - 1; i >= 0; i--) {
      styleResult[styleList[i]] = null;
    }
    target.style = styleResult;

    // 逐级查找 tag
    obj = start;
    while (obj) {
      obj = domUtils.getParentByTagName(obj, tagList, true);
      if (obj) {
        tagName = obj.tagName.toLowerCase();
        tagObj = { name: tagName, enabled: true };
        if (checkBlockTag(tagName)) {
          // 标题必须第一个处理，所以永远要写到首位
          target.tagList.splice(0, 0, tagObj);
          hasTitle = true;
        } else if (checkSubSupTag(tagName)) {
          target.tagList.push(tagObj);
          hasSubSup = true;
        } else {
          target.tagList.push(tagObj);
          // if (tagName.toLowerCase() === 'i') {
          if (/^i$/i.test(tagName)) {
            hasI = true;
          } else if (/^b$/i.test(tagName)) {
            hasB = true;
          }
        }
        tagMap[tagName] = 1;
        obj = obj.parentNode;
      }
    }
    if (!hasTitle) {
      target.tagList.splice(0, 0, { name: 'div', enabled: true });
    }
    if (!hasSubSup) {
      target.tagList.push({ name: 'sub', enabled: false });
    }
    for (var _i = 0; _i < tagList.length; _i++) {
      tagName = tagList[_i];
      if (checkBlockTag(tagName) || checkSubSupTag(tagName)) {
        // 所有不存在的标题 都不写入 tagList
        // sub & sup 不重复写入 tagList
        continue;
      }
      if (!tagMap[tagName]) {
        target.tagList.push({ name: tagName, enabled: false });
      }
    }

    // 表格内 格式刷不处理 左右对齐
    var zone = tableZone.getZone();
    if (zone.range) {
      delete target.style['text-align'];
    } else {
      // 左右对齐需要使用 execCommand 操作
      if (target.style['text-align']) {
        tagName = 'text-align-' + target.style['text-align'];
      } else {
        tagName = 'text-align-left';
      }
      delete target.style['text-align'];
      target.tagList.push({ name: tagName, enabled: true });
    }

    // console.log(target);
  };
  var init = function init() {
    target = {
      style: null,
      tagList: []
    };
  };

  var _event = {
    bind: function bind() {
      _event.unbind();
      env.event.add(CONST.EVENT.ON_KEY_DOWN, _event.handler.onKeyDown);
      env.event.add(CONST.EVENT.ON_MOUSE_UP, _event.handler.onMouseUp);
    },
    unbind: function unbind() {
      env.event.remove(CONST.EVENT.ON_KEY_DOWN, _event.handler.onKeyDown);
      env.event.remove(CONST.EVENT.ON_MOUSE_UP, _event.handler.onMouseUp);
    },
    handler: {
      onKeyDown: function onKeyDown(e) {
        var keyCode = e.keyCode || e.which;
        if (keyCode === 27) {
          _this.off();
        }
      },
      onMouseUp: function onMouseUp() {
        if (!target.style) {
          return;
        }

        historyUtils.saveSnap(false);
        var range = void 0,
            start = void 0,
            end = void 0;

        var zone = tableZone.getZone();
        if (zone.range) {
          // 表格内 格式刷不处理 左右对齐
          delete target.tagList['text-align-left'];
          delete target.tagList['text-align-right'];
        }
        // 必须先执行 execCommand；因为修改样式会导致 range 改变
        for (var i = 0; i < target.tagList.length; i++) {
          var tag = target.tagList[i];
          var commandName = FormatCommand[tag.name];
          if (checkBlockTag(tag.name)) {
            // 处理 段落 参数与其他不同
            commandExtend.execCommand(commandName, false, tag.name);
            continue;
          }
          if (checkSubSupTag(tag.name)) {
            // 处理 sub sup
            if (tag.enabled) {
              commandExtend.execCommand(commandName, false);
            } else {
              // 清理 sub & sup
              commandExtend.clearSubSup();
            }
            continue;
          }
          var commandState = commandExtend.queryCommandState(commandName);
          if (tag.enabled && !commandState) {
            commandExtend.execCommand(commandName, false);
          } else if (!tag.enabled && commandState) {
            commandExtend.execCommand(commandName, false);
          } else {
            // 避免被选中的区域内有部分内容 commandState 为 true
            // 浏览器表现不一致
            // 例如 <b>...</b><span>...</span><b>...</b> 这范围内 得到的 commandState 有的为 true 有的为 false
            // 保险起见，只要 目标与希望结果一致时，都需要执行两次
            commandExtend.execCommand(commandName, false);
            // Chrome bug：连续两次执行 execCommand 时，特殊情况会导致 range 得到的是错误结果
            // 所以必须修正 range
            range = rangeUtils.getRange();
            if (range) {
              start = rangeUtils.getRangeDetail(range.startContainer, range.startOffset);
              end = rangeUtils.getRangeDetail(range.endContainer, range.endOffset);
            }
            commandExtend.execCommand(commandName, false);
            if (range) {
              rangeUtils.setRange(start.container, start.offset, end.container, end.offset);
            }
          }
        }

        if (!tableCore.modifySelectionDom(target.style, null)) {
          // 处理普通文本样式
          rangeUtils.modifySelectionDom(target.style, null);
        }

        if (!keepFormat) {
          _this.init();
        }
      }
    }
  };

  this.init = function () {
    _this.off();
    // // todo 为便于测试，临时添加快捷键
    // env.event.add(CONST.EVENT.ON_KEY_UP, _event.handler.onKeyUp);
  };
  this.on = function (keep) {
    init();
    keepFormat = !!keep;

    if (_this.status() === 0) {
      return 0;
    }

    var range = rangeUtils.getRange(),
        zone = tableZone.getZone();
    var start = void 0,
        startOffset = 0;
    if (range) {
      start = rangeUtils.getRangeDetail(range.startContainer, range.startOffset);
      startOffset = start.offset;
      start = start.container;
    } else {
      start = zone.start.cell;
    }
    start = domUtils.getFirstDeepChild(start);
    getStyle(start, startOffset);

    _event.bind();
    wizStyle.insertStyle({
      id: CONST.ID.FORMAT_PAINTER_STYLE,
      name: CONST.NAME.TMP_STYLE
    }, 'body {cursor:url("' + env.dependency.files.cursor.formatPainter + '"), auto;}');
    return 2;
  };
  this.off = function () {
    init();
    wizStyle.removeStyleById(CONST.ID.FORMAT_PAINTER_STYLE);
    _event.unbind();

    // todo 为便于测试，临时添加快捷键
    // env.event.remove(CONST.EVENT.ON_KEY_UP, _event.handler.onKeyUp);

    return _this.status();
  };
  this.status = function () {
    if (env.readonly || env.client.type.isPhone || env.client.type.isPad) {
      // 阅读模式下所有客户端 以及 编辑模式下手机、Pad 禁止使用 格式刷
      return 0;
    }

    var range = rangeUtils.getRange(),
        zone = tableZone.getZone();
    if (!range && !zone.range || zone.active) {
      // 编辑区域无焦点，且不再 table 内，禁止使用 格式刷
      return 0;
    }

    if (range && codeUtils && codeUtils.getContainerFromChild(range.startContainer)) {
      // CodeMirror 内禁止使用 格式刷
      return 0;
    }

    // 关闭时 为 1； 使用时 为 2
    return !!target && !!target.style ? 2 : 1;
  };
};

module.exports = FormatPainter;

},{"../config/const":388,"../libs/utils":400}],344:[function(require,module,exports){
'use strict';

/**
 * 超链接操作基本方法集合
 */
var CONST = require('../config/const');
var utils = require('../libs/utils');

var defaultColor = 'yellow';
var activeColor = '#FF9632';

var HighlightUtils = function HighlightUtils() {
  var _this = this;

  var core = null;
  var env = null;
  var codeUtils = null;
  var domUtils = null;
  var readerEvent = null;
  var rangeUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    codeUtils = core.require.codeUtils;
    domUtils = core.require.domUtils;
    readerEvent = core.require.readerEvent;
    rangeUtils = core.require.rangeUtils;
  };

  var hasHighlight = false;
  var curTarget = void 0,
      curIndex = void 0,
      targetList = [];

  var _class = {
    searching: 'cm-searching'
  };

  var highlightAll = function highlightAll(key, focusFirst) {
    if (focusFirst) {
      curIndex = -1;
      curTarget = null;
      targetList = [];
    }
    hasHighlight = false;

    // 需要定位第一个匹配结果时，需要单独查找一次，获取第一次的 target
    if (focusFirst && env.win.find(key, false, false, true)) {
      curTarget = highlightTarget(key);
    }

    rangeUtils.setRange(env.body, env.body.childNodes.length);

    // 最多 高亮 100 次
    // 注意：样式-webkit-user-select: none; 会导致 find 方法永远都停留在某一个位置，从而出现死循环
    var count = 1;
    while (count++ < 101 && env.win.find(key, false, true)) {
      highlightTarget(key);
    }

    hasHighlight = !!env.body.querySelector(CONST.TAG.TMP_HIGHLIGHT_TAG) || !!env.body.querySelector(CONST.TAG.CODE_MIRROR + ' .' + _class.searching);

    if (hasHighlight && !focusFirst) {
      rangeUtils.setRange(document.body, 0);
    }
  };
  var highlightTarget = function highlightTarget(key) {
    var range = void 0,
        item = void 0,
        tmp = void 0;
    range = rangeUtils.getRange();

    if (!range) {
      return;
    }

    // 如果需要高亮的目标已经高亮，直接跳过
    if (range && domUtils.getParentByTagName(range.startContainer, CONST.TAG.TMP_HIGHLIGHT_TAG)) {
      // 必须要让 range 折叠，否则有可能导致第一个目标出现阴影
      range.collapse(true);
      return null;
    }

    var codeContainer = codeUtils && codeUtils.getContainerFromChild(range.startContainer);
    if (codeContainer) {
      // 如果 container 查询过同关键字，忽略
      if (!codeContainer.state || codeContainer.state.query !== key) {
        codeUtils.highlight.search(codeContainer, key);
        if (!curTarget) {
          item = codeContainer.querySelector('.' + _class.searching);
        }
      }
    } else {
      item = document.createElement(CONST.TAG.TMP_HIGHLIGHT_TAG);
      domUtils.addClass(item, _class.searching);
      item.style.backgroundColor = defaultColor;

      tmp = range.extractContents();
      while (tmp.firstChild) {
        item.appendChild(tmp.firstChild);
      }

      // 如果选中的内容为 input 内 item 将为空
      if (!domUtils.isEmptyDom(item)) {
        range.insertNode(item);
      }
    }
    return item;
  };
  var initTargetList = function initTargetList() {
    targetList = env.body.querySelectorAll('.' + _class.searching);
    if (targetList.length === 0) {
      return;
    }
    for (var i = targetList.length - 1; i >= 0; i--) {
      var target = targetList[i];
      if (target === curTarget) {
        curIndex = i;
        return;
      }
    }
    // 如果没有找到 curTarget 则设置为第一个 target
    curIndex = 0;
    curTarget = targetList[0];
  };
  var setTargetFocus = function setTargetFocus(index) {
    var lastIndex = curIndex;

    if (targetList.length === 0) {
      return;
    }

    // 实现循环搜索
    if (index >= targetList.length) {
      index = 0;
    } else if (index < 0) {
      index = targetList.length - 1;
    }

    // 如果需要设置的 index 与 上一次的相同，则不操作
    if (index === lastIndex) {
      curTarget.style.backgroundColor = activeColor;
      return;
    }

    targetList[lastIndex].style.backgroundColor = defaultColor;
    curIndex = index;
    curTarget = targetList[curIndex];
    curTarget.style.backgroundColor = activeColor;

    if (curTarget.scrollIntoViewIfNeeded) {
      curTarget.scrollIntoViewIfNeeded();
    }
  };
  var highlightSingle = function highlightSingle(key, aBackwards, rangeStart) {
    var sel = rangeUtils.getSelection();
    var range = void 0,
        item = void 0,
        tmp = void 0;

    if (rangeStart === -1) {
      rangeUtils.setRange(env.body, 0);
    } else if (rangeStart === 1) {
      rangeUtils.setRange(env.body, env.body.childNodes.length);
    }

    if (env.win.find(key, false, aBackwards, true)) {
      item = document.createElement(CONST.TAG.TMP_HIGHLIGHT_TAG);
      item.style.backgroundColor = 'yellow';
      range = rangeUtils.getRange();
      tmp = range.extractContents();
      while (tmp.firstChild) {
        item.appendChild(tmp.firstChild);
      }
      // 如果选中的内容为 input 内  item 将为空
      if (!domUtils.isEmptyDom(item)) {
        range.insertNode(item);
        if (!aBackwards) {
          rangeUtils.setRange(item, item.childNodes.length);
        }
        item.scrollIntoViewIfNeeded();
      } else if (aBackwards) {
        sel.collapseToStart();
      } else {
        sel.collapseToEnd();
      }
      return true;
    }
    return false;
  };

  this.on = function (keyList, focusFirst) {
    _this.off();
    if (!keyList) {
      return false;
    }
    if (!utils.isArray(keyList)) {
      keyList = [keyList];
    }
    // 关键字数量 大于 1 的时候，不实现 第一个搜索结果高亮
    if (keyList.length > 1) {
      focusFirst = false;
    }

    var scroll = domUtils.getPageScroll();

    for (var i = 0, j = keyList.length; i < j; i++) {
      highlightAll(keyList[i], focusFirst);
    }

    initTargetList();
    if (focusFirst) {
      setTargetFocus(curIndex);
    } else if (!readerEvent.isScrolled && targetList.length > 0 && (env.client.type.isWin || env.client.type.isMac || env.client.type.isLinux)) {
      // Pc / Mac 客户端第一次进入时，需要让 第一个高亮关键字进入可视区
      if (targetList[0].scrollIntoViewIfNeeded) {
        targetList[0].scrollIntoViewIfNeeded();
      }
    } else {
      // find 方法会导致滚动条移动，所以需要恢复初始位置
      domUtils.setPageScrollTop(scroll.top);
    }
    return hasHighlight;
  };
  this.off = function () {
    domUtils.peelTag(CONST.TAG.TMP_HIGHLIGHT_TAG);
    if (codeUtils) {
      codeUtils.highlight.clearAll();
    }
  };
  this.next = function () {
    setTargetFocus(curIndex + 1);
  };
  this.previous = function () {
    setTargetFocus(curIndex - 1);
  };
};

module.exports = HighlightUtils;

},{"../config/const":388,"../libs/utils":400}],345:[function(require,module,exports){
'use strict';

/**
 * undo、redo 工具包
 */
var CONST = require('../config/const'),
    utils = require('../libs/utils');

var getCm = function getCm(body, cmContainerId) {
  var cm = null;
  var cmContainer = body.querySelector('#' + cmContainerId);
  if (cmContainer && cmContainer.codeMirror) {
    // CodeMirror change 时不用考虑 keepIndex，因为肯定是发生改变了
    cm = cmContainer.codeMirror;
  }
  return cm;
};

var getCmContainerList = function getCmContainerList(body) {
  return body.querySelectorAll('.' + CONST.CLASS.CODE_CONTAINER);
};

var HistoryUtils = function HistoryUtils() {
  var _this = this;

  var core = null;
  var env = null;
  var domUtils = null;
  var rangeUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
    rangeUtils = core.require.rangeUtils;
  };

  var MaxRedo = 100;
  var codeMirrorDocList = {};

  var saveCmDocList = function saveCmDocList() {
    var containerList = getCmContainerList(env.body);
    var container = void 0,
        cm = void 0,
        i = void 0;
    for (i = containerList.length - 1; i >= 0; i--) {
      container = containerList[i];
      cm = container.codeMirror;
      if (cm) {
        codeMirrorDocList[container.id] = cm.getDoc().copy(true);
      }
    }
    // console.log(codeMirrorDocList);
  };

  /**
   * 历史记录功能的 事件处理
   */
  var historyEvent = {
    /**
     * 初始化时， 绑定历史记录相关的必要事件
     */
    bind: function bind() {
      historyEvent.unbind();
      env.event.add(CONST.EVENT.ON_KEY_DOWN, historyEvent.onKeyDown);
    },
    /**
     * 解绑历史记录相关的必要事件
     */
    unbind: function unbind() {
      env.event.remove(CONST.EVENT.ON_KEY_DOWN, historyEvent.onKeyDown);
    },
    /**
     * 快捷键 监控
     * @param e
     */
    onKeyDown: function onKeyDown(e) {
      var keyCode = e.keyCode || e.which;
      //console.log('history keydown.....' + keyCode);
      /**
       * Ctrl + Z
       */
      if (e.ctrlKey && keyCode === 90 || e.metaKey && keyCode === 90 && !e.shiftKey) {
        _this.undo();
        utils.stopEvent(e);
        return;
      }
      /**
       * Ctrl + Y
       */
      if (e.ctrlKey && keyCode === 89 || e.metaKey && keyCode === 89 || e.metaKey && keyCode === 90 && e.shiftKey) {
        _this.redo();
        utils.stopEvent(e);
      }
    }
  };

  this.enable = false;
  /**
   * 执行 undo 操作时，触发的回调函数， 返回 history 的缓存集合数量，以及当前 undo、redo 操作游标的所在位置——用于控制 undo、redo 按钮的 disabled
   */
  this.callback = [];
  /**
   * undo 集合
   */
  this.stack = [];
  /**
   * undo 集合当前游标位置
   */
  this.stackIndex = 0;

  /**
   * 初始化
   */
  this.init = function () {
    _this.callback = [];
    _this.stack = [];
    _this.stackIndex = 0;
  };

  this.addCallback = function (callback) {
    if (!callback || typeof callback !== 'function') {
      return;
    }
    for (var i = 0, j = _this.callback.length; i < j; i++) {
      if (_this.callback[i] === callback) {
        return;
      }
    }
    _this.callback.push(callback);
  };

  /**
   * 触发 callback
   */
  this.applyCallback = function () {
    var result = _this.getUndoState();
    for (var i = 0, j = _this.callback.length; i < j; i++) {
      _this.callback[i](result);
    }
    // console.log(JSON.stringify(result));
  };

  /**
   * 判断 当前快照是否可以保存
   */
  this.canSave = function (s1, s2) {
    var result = { add: false, replace: false, direct: 0 };
    if (s1.content.length !== s2.content.length || !!s1.content.localeCompare(s2.content)) {
      result.direct = compareFocus(s1.focus, s2.focus);
      if (result.direct === 0 || result.direct !== s2.direct || !/^\s*$/g.test(s1.focus.lastChar + s2.focus.lastChar) && /\s/.test(s2.focus.lastChar) || Math.abs(s1.focus.startOffset - s2.focus.startOffset) > 20) {
        // direct 为 0 表明不是在一个 TextNode 操作
        // direct 不相同操作不一致
        // s1 & s2 的 lastChar 不同时为空
        // 连续输入超过 3秒 需要截断
        result.add = true;
      } else {
        result.replace = true;
      }
    }
    // console.log(' ..... can Save .....');
    // console.log((s1.focus.lastChar !== s2.focus.lastChar) + ', ' + (s1.focus.lastChar === ' ') + ', ' + (s2.focus.lastChar === ' '));
    // console.log(s1.direct + ', ' + s2.direct + ', ' + result.direct);
    // console.log(JSON.stringify(s1.focus));
    // console.log(JSON.stringify(s2.focus));
    // console.log(result);
    return result;

    function compareFocus(f1, f2) {
      if (f1.isCollapsed !== f2.isCollapsed) {
        return 0;
      }
      if (f1.start.length !== f2.start.length || f1.end.length !== f2.end.length) {
        return 0;
      }
      var result = compareIndexList(f1.start, f2.start);
      if (result < 1) {
        return result;
      }
      result = compareIndexList(f1.end, f2.end);
      return result;
    }

    function compareIndexList(index1, index2) {
      var isSame = 1,
          i = void 0,
          j = void 0;
      for (i = 0, j = index1.length - 1; i < j; i++) {
        if (index1[i] !== index2[i]) {
          isSame = 0;
          break;
        }
      }
      if (isSame && index1[j] < index2[j]) {
        isSame = -1;
      }
      //console.log('.....compareIndexList.....')
      //console.log(index1)
      //console.log(index2)
      //console.log(isSame)
      return isSame;
    }
  };

  /**
   * 根据 containerId 获取对应的 CodeMirror Doc 副本
   */
  this.getCodeMirrorDoc = function (containerId) {
    var cmDoc = codeMirrorDocList[containerId] || null;
    if (cmDoc) {
      cmDoc = cmDoc.copy(true);
    }
    return cmDoc;
  };

  this.getUndoState = function () {
    return {
      'undoCount': _this.stack.length,
      'undoIndex': _this.stackIndex
    };
  };

  /**
   * redo 操作
   */
  this.redo = function () {
    // console.log('.....redo....');
    if (!_this.enable || _this.stackIndex >= _this.stack.length - 1) {
      return;
    }

    var historyObj = _this.stack[++_this.stackIndex];
    if (historyObj.type === CONST.HISTORY.TYPE.CODE_MIRROR) {
      _this.restoreCodeMirror('redo', historyObj);
    } else {
      // 只有处理 CodeMirror 外的内容时才 save
      saveCmDocList();
      _this.restoreSnap(historyObj.snap);
    }

    env.event.call(CONST.EVENT.AFTER_RESTORE_HISTORY, {
      type: historyObj.type
    });
    _this.applyCallback();
    if (historyObj.type === CONST.HISTORY.TYPE.COMMON) {
      domUtils.focus();
    }
    // console.log('redo: ' + this.stackIndex);
  };

  this.removeCallback = function (callback) {
    for (var i = 0, j = _this.callback.length; i < j; i++) {
      if (_this.callback[i] === callback) {
        _this.callback.splice(i, 1);
        return;
      }
    }
  };

  this.restoreCodeMirror = function (restoreType, historyObj) {
    if (!_this.enable || !historyObj) {
      return;
    }
    var cmContainerId = void 0,
        cm = void 0;
    // console.log('restoreCodeMirror = ' + restoreType);
    // undo 操作 要看下一个改动由谁操作
    // redo 操作 要看当前由谁操作
    cmContainerId = restoreType === 'undo' ? historyObj.nextChange.cmContainerId : historyObj.cmContainerId;
    cm = getCm(env.body, cmContainerId);
    if (cm) {
      if (restoreType === 'redo') {
        cm.redo();
      } else {
        cm.undo();
      }
    }
  };

  /**
   * 根据指定的 快照 恢复页面内容
   */
  this.restoreSnap = function (snap) {
    if (!_this.enable || !snap) {
      return;
    }

    var start = void 0,
        end = void 0;
    env.body.innerHTML = snap.content;
    try {
      start = domUtils.getFromIndexList(snap.focus.start);
      rangeUtils.setRange(start.dom, start.offset);
      if (!snap.focus.isCollapsed) {
        end = domUtils.getFromIndexList(snap.focus.end);
        rangeUtils.setRange(start.dom, start.offset, end.dom, end.offset);
      } else {
        rangeUtils.setRange(start.dom, start.offset, start.dom, start.offset);
      }
      rangeUtils.caretFocus();
    } catch (e) {
      console.error(e);
    }
  };

  /**
   * 保存当前内容的快照
   * @param keepIndex （是否保存快照时不移动游标， 主要用于 undo 操作时保存最后的快照）
   * @param options （用于区分不同模块，目前主要是区分 CodeMirror）
   */
  this.saveSnap = function (keepIndex, options) {
    if (!_this.enable || env.compositionStart && (!options || options.type === CONST.HISTORY.TYPE.COMMON)) {
      // CodeMirror 不考虑是否中文输入法输入
      return;
    }

    env.event.call(CONST.EVENT.BEFORE_SAVESNAP);

    var nextChange = {
      type: CONST.HISTORY.TYPE.COMMON
    };
    if (options && options.type === CONST.HISTORY.TYPE.CODE_MIRROR) {
      nextChange.type = CONST.HISTORY.TYPE.CODE_MIRROR;
      nextChange.cmContainerId = options.cmContainerId;
    }
    // console.log(nextChange);

    var historyObj = {
      nextChange: nextChange
    };

    var canSave = void 0,
        cm = void 0,
        cmContainerId = void 0,
        prevCmContainerId = void 0,
        prevHistoryObj = void 0,
        snap = void 0,
        prevSnap = void 0;

    prevHistoryObj = _this.stackIndex > 0 ? _this.stack[_this.stackIndex - 1] : null;
    if (prevHistoryObj && prevHistoryObj.nextChange.type === CONST.HISTORY.TYPE.CODE_MIRROR) {
      // CodeMirror 的 History

      // console.log('history  ---- code mirror');

      prevCmContainerId = prevHistoryObj.cmContainerId;
      cmContainerId = prevHistoryObj.nextChange.cmContainerId;
      historyObj.type = CONST.HISTORY.TYPE.CODE_MIRROR;
      historyObj.cmContainerId = cmContainerId;
      cm = getCm(env.body, cmContainerId);
      if (cm) {
        // undo - redo 之间 操作时，直接清空 redo
        if (_this.stackIndex >= 0) {
          _this.stack.splice(_this.stackIndex, _this.stack.length - _this.stackIndex);
        }

        if (historyObj.nextChange.type === CONST.HISTORY.TYPE.COMMON) {
          // CodeMirror 转到 Common 时需要保存 快照 snap
          // 否则 undo 时 无法还原 Editor 输入前 的最后一次状态
          historyObj.snap = _this.snapshot();
        }

        historyObj.cmHistory = cm.historySize();

        // 检查 CodeMirror HistorySize，没有变化则不记录新的 history
        if (prevCmContainerId === cmContainerId && prevHistoryObj.cmHistory.undo === historyObj.cmHistory.undo && prevHistoryObj.cmHistory.redo === historyObj.cmHistory.redo) {
          // 不记录新的 history，但要更新 nextChange
          prevHistoryObj.nextChange = historyObj.nextChange;
          if (historyObj.snap) {
            prevHistoryObj.snap = historyObj.snap;
          }
          if (keepIndex) {
            _this.stackIndex--;
          }
          return;
        }

        _this.stack.push(historyObj);
        if (!keepIndex) {
          _this.stackIndex++;
        }
      }
    } else {
      // 普通正文编辑 的 History
      // console.log('history  ---- html');

      historyObj.type = CONST.HISTORY.TYPE.COMMON;

      canSave = { add: true, replace: false, direct: 0 };
      snap = _this.snapshot();
      // keepIndex 为 true 时， canSave.add 肯定为 true
      if (!keepIndex && prevHistoryObj && prevHistoryObj.type === CONST.HISTORY.TYPE.COMMON) {
        canSave = _this.canSave(snap, prevHistoryObj.snap);
      }

      if (canSave.add || canSave.replace) {
        //console.log('save snap.... stack: [' + this.stack.length + ']  index: [' + this.stackIndex + ']  keepIndex: [' + !!keepIndex + ']');
        //记录 光标移动方向，用于判断是删除还是添加字符
        snap.direct = canSave.direct;

        // undo - redo 之间 操作时，直接清空 redo
        if (_this.stackIndex >= 0) {
          _this.stack.splice(_this.stackIndex, _this.stack.length - _this.stackIndex);
        }
        // console.log(snap.content);
        if (canSave.add) {
          // console.log('save snap.add.... stack: [' + this.stack.length + ']  index: [' + this.stackIndex + ']  keepIndex: [' + !!keepIndex + ']');
          historyObj.snap = snap;
          _this.stack.push(historyObj);
          if (!keepIndex) {
            _this.stackIndex++;
          }
        } else if (canSave.replace) {
          //console.log('save snap.replace.... stack: [' + this.stack.length + ']  index: [' + this.stackIndex + ']  keepIndex: [' + !!keepIndex + ']');
          prevSnap = prevHistoryObj.snap;
          snap.focus.startOffset = prevSnap.focus.startOffset;
          prevHistoryObj.snap = snap;
        }
      }
    }

    if (_this.stack.length > MaxRedo) {
      _this.stack.shift();
      _this.stackIndex--;
    }

    _this.applyCallback();
    // console.log('stack.length = ' + this.stack.length + ', index: ' + this.stackIndex);

    // console.log(this.stack);
  };

  /**
   * 生成快照
   */
  this.snapshot = function () {
    var range = rangeUtils.getRange(),
        content = env.body.innerHTML,
        focus = {
      isCollapsed: true,
      start: [],
      end: [],
      lastChar: null,
      startOffset: -1
    },
        snap = {
      content: content,
      focus: focus
    };

    if (!range) {
      focus.start.push(0);
      return snap;
    }

    focus.start = domUtils.getIndexList(range.startContainer);
    focus.start.push(range.startOffset);
    focus.isCollapsed = range.collapsed;
    if (!range.collapsed) {
      focus.end = domUtils.getIndexList(range.endContainer);
      focus.end.push(range.endOffset);
    } else if (range.startContainer.nodeType === 3 && range.startOffset > 0) {
      // 判断是否正在输入单词
      focus.lastChar = range.startContainer.nodeValue.charAt(range.startOffset - 1);
      focus.startOffset = range.startOffset;
    }
    return snap;
  };

  /**
   * 开启 history 功能
   */
  this.start = function (maxRedo, callback) {
    if (maxRedo && maxRedo > 0) {
      MaxRedo = maxRedo;
    }
    _this.enable = true;
    historyEvent.bind();
    _this.addCallback(callback);
    _this.applyCallback();
  };

  /**
   * 关闭 history 功能
   */
  this.stop = function () {
    _this.enable = false;
    _this.init();
    historyEvent.unbind();
  };

  /**
   * undo 操作
   */
  this.undo = function () {
    // console.log('.....undo....');
    if (!_this.enable || _this.stackIndex <= 0 || _this.stack.length === 0) {
      _this.stackIndex = 0;
      return;
    }
    if (_this.stackIndex >= _this.stack.length) {
      // 专门用于 undo 之前把 editor 最后的状态保存
      _this.saveSnap(true);
    }
    //console.log('.....restoreSnap.....' + this.stack.length + ',' + this.stackIndex);
    var historyObj = _this.stack[--_this.stackIndex];
    if (historyObj.nextChange.type === CONST.HISTORY.TYPE.CODE_MIRROR) {
      _this.restoreCodeMirror('undo', historyObj);
    } else {
      // 只有处理 CodeMirror 外的内容时才 save
      saveCmDocList();

      _this.restoreSnap(historyObj.snap);
    }

    env.event.call(CONST.EVENT.AFTER_RESTORE_HISTORY, {
      type: historyObj.nextChange.type
    });
    _this.applyCallback();
    if (historyObj.type === CONST.HISTORY.TYPE.COMMON) {
      domUtils.focus();
    }
    // console.log('undo: ' + this.stackIndex);
  };
};

module.exports = HistoryUtils;

},{"../config/const":388,"../libs/utils":400}],346:[function(require,module,exports){
'use strict';

/**
 * 超链接操作基本方法集合
 */
var CONST = require('../config/const');
var utils = require('../libs/utils');

var LinkUtils = function LinkUtils() {
  var core = null;
  var env = null;
  var commandExtend = null;
  var domUtils = null;
  var historyUtils = null;
  var rangeUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    commandExtend = core.require.commandExtend;
    domUtils = core.require.domUtils;
    historyUtils = core.require.historyUtils;
    rangeUtils = core.require.rangeUtils;
  };

  var _event = {
    bind: function bind() {
      _event.unbind();
      env.event.add(CONST.EVENT.ON_KEY_DOWN, _event.handler.onKeyDown);
    },
    unbind: function unbind() {
      env.event.remove(CONST.EVENT.ON_KEY_DOWN, _event.handler.onKeyDown);
    },
    handler: {
      onKeyDown: function onKeyDown(e) {
        var keyCode = e.keyCode || e.which;
        var start = void 0,
            next = void 0;
        var sel = void 0,
            range = void 0,
            offset = void 0,
            charCode = void 0;
        if (keyCode === 32 || keyCode === 13) {
          historyUtils.saveSnap(false);

          range = rangeUtils.getRange();
          range = range.cloneRange();

          start = range.startContainer;
          while (start.nodeType === 1 && range.startOffset > 0) {
            start = range.startContainer.childNodes[range.startOffset - 1];
            if (!start) {
              break;
            }
            range.setStart(start, domUtils.getEndOffset(start));
            range.collapse(true);
            start = range.startContainer;
          }
          do {
            if (range.startOffset === 0) {
              start = range.startContainer.previousSibling;

              while (start && start.nodeType === 1) {
                start = start.lastChild;
              }
              if (!start || domUtils.isFillChar(start, false)) {
                break;
              }
              offset = start.nodeValue.length;
            } else {
              start = range.startContainer;
              offset = range.startOffset;
            }
            range.setStart(start, offset - 1);
            charCode = range.toString().charCodeAt(0);
          } while (charCode !== 160 && charCode !== 32);

          if (range.toString().replace(CONST.FILL_CHAR_REG, '').match(/(?:https?:\/\/|ssh:\/\/|ftp:\/\/|file:\/|www\.)/i)) {
            while (range.toString().length) {
              if (/^(?:https?:\/\/|ssh:\/\/|ftp:\/\/|file:\/|www\.)/i.test(range.toString())) {
                break;
              }
              try {
                range.setStart(range.startContainer, range.startOffset + 1);
              } catch (e) {
                //trace:2121
                start = range.startContainer;
                while (!(next = start.nextSibling)) {
                  if (domUtils.isBody(start)) {
                    return;
                  }
                  start = start.parentNode;
                }
                range.setStart(next, 0);
              }
            }
            //if is <a>, then return;
            if (domUtils.getParentByTagName(range.startContainer, 'a', true, null)) {
              return;
            }

            var a = env.doc.createElement('a'),
                text = env.doc.createTextNode(' '),
                href = void 0;
            var rangeText = range.extractContents();
            a.href = rangeText.textContent;
            a.appendChild(env.doc.createTextNode(rangeText.textContent));
            href = a.getAttribute("href").replace(CONST.FILL_CHAR_REG, '');
            href = /^(?:https?:\/\/)/ig.test(href) ? href : "http://" + href;
            a.href = href;

            range.insertNode(a);
            a.parentNode.insertBefore(text, a.nextSibling);
            range.setStart(text, 0);
            range.collapse(true);
            sel = rangeUtils.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
          }
        }
      }
    }
  };

  /**
   * 修正 选择范围，如果 rang 的 start 或 end 在 A 中间，则选中 A 的全部
   */
  var fixARange = function fixARange() {
    var range = rangeUtils.getRange(),
        start = void 0,
        startOffset = void 0,
        end = void 0,
        endOffset = void 0;
    if (!range) {
      return;
    }
    start = getA(range.startContainer, range.startOffset);
    if (start) {
      startOffset = 0;
    } else {
      start = range.startContainer;
      startOffset = range.startOffset;
    }
    if (range.collapsed) {
      end = start;
      endOffset = domUtils.getEndOffset(start);
    } else {
      end = getA(range.endContainer, range.endOffset);
      if (end) {
        endOffset = domUtils.getEndOffset(end);
      } else {
        end = range.endContainer;
        endOffset = range.endOffset;
      }
    }
    rangeUtils.setRange(start, startOffset, end, endOffset);
  };

  /**
   * 根据 Range 的 Container 和 Offset 获取 对应的 A
   */
  var getA = function getA(target, offset) {
    if (target.nodeType === 1 && target.childNodes.length > offset) {
      target = target.childNodes[offset];
    }
    return domUtils.getParentByTagName(target, 'a', true);
  };

  this.off = function () {
    _event.unbind();
  };
  this.on = function () {
    if (env.options.reader.type === CONST.NOTE_READER_TYPE.MARKDOWN) {
      return;
    }
    _event.bind();
  };
  this.getCurrentLink = function () {
    var range = rangeUtils.getRange();
    if (!range) {
      return '';
    }
    var currentNode = domUtils.getParentByTagName(range.startContainer, 'a', true);
    if (!currentNode) {
      return '';
    }
    return currentNode.href;
  };
  /**
   * 移除选中的 <a> 标签的超链接
   */
  this.removeSelectedLink = function () {
    fixARange();
    historyUtils.saveSnap(false);
    commandExtend.execCommand("unlink", false, false);
  };
  this.setCurrentLink = function (url) {
    if (!url) {
      return;
    }
    fixARange();
    historyUtils.saveSnap(false);
    commandExtend.execCommand("createLink", false, url);
  };

  this.hasLinkFromRange = function () {
    var range = rangeUtils.getRange();
    if (!range) {
      return false;
    }

    var a = void 0;
    if (range.collapsed) {
      a = domUtils.getParentByTagName(range.startContainer, ['a'], true);
    } else {
      var tmp = range.cloneContents();
      a = tmp.querySelector('a');
    }
    return !!a;
  };

  this.onClickLink = function (e) {
    var onlyDefault = true;
    var protocolReg = /^(http|https|wiz|wiznote|mailto|tel|ftp):/i;
    // 编辑时 支持 Ctrl or CmdKey 点击 超链接可以进行跳转
    if (env.readonly || !env.readonly && (e.ctrlKey || e.metaKey)) {
      var target = e.target;
      var a = domUtils.getParentByTagName(target, ['a'], true);
      var href = a && a.getAttribute('href') || '';
      if (!href) {
        return;
      }
      if (href.indexOf('javascript:') > -1) {
        utils.stopEvent(e, onlyDefault);
        return;
      }
      // 锚点 需要特殊处理
      if (/^#/.test(href)) {
        if (!env.client.type.isWeb) {
          // 非 Web 端 直接采用浏览器默认操作
          return;
        }

        var dom = env.doc.getElementById(href.substr(1));
        if (dom) {
          dom.scrollIntoView(true);
        }
        utils.stopEvent(e, onlyDefault);
        return;
      }

      if (!location.origin) {
        //fuck IE8
        location.origin = location.protocol + '//' + location.host;
      }
      if (href.indexOf('/') === 0) {
        href = location.origin + href;
      } else if (!protocolReg.test(href)) {
        href = location.origin + location.pathname + '/' + href;
      }

      if (protocolReg.test(href)) {
        if (!env.options.callback.onClickLink || env.options.callback.onClickLink(e, href, env.readonly)) {
          env.win.open(href);

          utils.stopEvent(e, onlyDefault);
        }
      }
    }
  };
};

module.exports = LinkUtils;

},{"../config/const":388,"../libs/utils":400}],347:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * markdown & mathjax 渲染处理
 */
var CONST = require('../config/const');
var utils = require('../libs/utils');
var markdownBase = require('../libs/Markdown.Converter');
var markdownExtra = require('../libs/Markdown.Extra');
var dependLoader = require('../libs/dependLoader');
var LoadController = require('../libs/LoadController');
var xssUtils = require('../libs/xssUtils');

var loadController = new LoadController();
var WizToc = '#wizToc';

/**
 * mdOptions
 * {win, doc, body, callback}
 * mdOptions.win
 */
var MarkdownRender = function MarkdownRender(mdOptions) {
  var _this = this;

  mdOptions = mdOptions || {};

  var core = null;
  var env = null;
  var codeCore = null;
  var codeUtils = null;
  var domUtils = null;

  var mdWin = void 0;
  var mdDoc = void 0;
  var mdContainer = void 0;
  var mdCallback = void 0;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    codeCore = core.require.codeCore;
    codeUtils = core.require.codeUtils;
    domUtils = core.require.domUtils;

    var MathJaxRender = core.require.MathJaxRender;
    if (MathJaxRender) {
      mathJaxRender = new MathJaxRender(mdOptions);
      mathJaxRender.initCore(core);
    }
    _this.init();
  };

  var isMathJax = false;
  var mathJaxRender = void 0;
  var markdownSrc = '';
  var hasMarkdownSrc = false;

  var defaultCB = function defaultCB() {
    if (mdWin.prettyPrint) {
      mdWin.prettyPrint();
    }
    Render.tocRender();
    Render.flowRender();
    Render.sequenceRender();
  };

  /**
   * 修正 safari innerText 的 bug
   * （math、semantics、annotation 等 tag 输出 innerText 会出现换行，而且 <math>...</math> 内的内容会被删除）
   */
  var patchForSafari = function patchForSafari() {
    var tmp = mdDoc.createElement('span');
    tmp.innerHTML = '<math>a</math>';
    tmp.style.opacity = '0';
    mdContainer.appendChild(tmp);
    var tmpText = tmp.innerText;
    domUtils.remove(tmp);
    if (tmpText) {
      return;
    }

    var tagList = mdDoc.getElementsByTagName('math');
    var tag = void 0,
        parent = void 0,
        span = void 0;
    while (tagList.length > 0) {
      tag = tagList[0];
      parent = tag.parentNode;
      span = mdDoc.createElement('span');
      span.innerText = tag.textContent;
      parent.insertBefore(span, tag);
      parent.removeChild(tag);
    }
  };

  var loadDependency = function loadDependency(callback) {
    loadController.addCallback(mdDoc, callback);
    if (loadController.getLoading(mdDoc)) {
      return;
    }
    if (!mdWin.$ || !mdWin.Diagram || !mdWin.flowchart || !mdWin.prettyPrint) {
      loadController.setLoading(mdDoc, true);
      dependLoader.loadJs(mdDoc, dependLoader.getDependencyFiles(env.dependency, 'js', 'markdown'), function () {
        loadController.setLoading(mdDoc, false);
        loadController.callback(mdDoc);
      });
    } else {
      loadController.callback(mdDoc);
    }
  };

  var markdownStart = function markdownStart(callback) {
    dependLoader.loadCss(mdDoc, dependLoader.getDependencyFiles(env.dependency, 'css', 'markdown'));

    Render.markdownConvert();
    defaultCB();
    if (codeCore) {
      codeCore.on({
        body: mdContainer,
        readOnly: true
      }, _callback);
    } else {
      _callback();
    }

    function _callback() {
      if (env.options.reader.callback.markdown) {
        env.options.reader.callback.markdown();
      }

      if (isMathJax && mathJaxRender) {
        mathJaxRender.do({ container: mdContainer }, callback);
      } else {
        callback();
      }
    }
  };

  var Render = {
    getBodyTxt: function getBodyTxt(body) {
      patchForSafari();

      var text = body.innerText;
      if (!text) {
        // FF自己解析innerText
        text = domUtils.getInnerText(body);
      } else {
        // chrome 的 innerText 会在最后增加 \n，需要清理
        if (text.charAt(text.length - 1) === '\n') {
          text = text.substr(0, text.length - 1);
        }
      }
      //清理特殊字符
      text = text.replace(String.fromCharCode(65279), '');

      // 替换unicode160的空格为unicode为32的空格，否则pagedown无法识别
      text = text.replace(/\u00a0/g, " ");

      return text;
    },
    markdownConvert: function markdownConvert() {
      var SPLIT = /(\$\$?|\\(?:begin|end){[a-z]*\*?}|\\[\\{}$]|[{}]|(?:\n\s*)+|@@\d+@@)/i;
      var start = void 0,
          end = void 0,
          last = void 0,
          blocks = void 0,
          math = void 0,
          braces = void 0,
          inline = false;
      var $body = mdWin.$(mdContainer);
      $body.addClass(CONST.CLASS.MARKDOWN_BODY);

      var converter = new markdownBase.Converter({
        nonAsciiLetters: true,
        asteriskIntraWordEmphasis: true,
        imgSrcFilter: function imgSrcFilter(src) {
          if (!env.options.reader.markdownPlugIn.imgSrcFilter) {
            return src;
          }
          return env.options.reader.markdownPlugIn.imgSrcFilter(src);
        },
        customBlockGamut: function customBlockGamut(text) {
          if (!env.options.reader.markdownPlugIn.customBlockGamut) {
            return text;
          }
          return env.options.reader.markdownPlugIn.customBlockGamut(text);
        }
      });
      var replaceMath = function replaceMath(text) {
        text = text.replace(/@@(\d+)@@/g, function (match, n) {
          return math[n];
        });
        math = null;
        return text;
      };
      var processMath = function processMath(i, j) {
        var block = blocks.slice(i, j + 1).join("");
        // 避免 “`$(...)` ... `$(...)`” 这种情况， 变为 “$(...)` ... `$(...)” 整个被处理为重点区块
        if (!block.match(/`/i)) {
          block = block.replace(/&/g, "&amp;") // use HTML entity for &
          .replace(/</g, "&lt;") // use HTML entity for <
          .replace(/>/g, "&gt;"); // use HTML entity for
          while (j > i) {
            blocks[j] = "";
            j--;
          }
          blocks[i] = "@@" + math.length + "@@";
          math.push(block);
        }
        start = end = last = null;
      };
      var removeMath = function removeMath(text) {
        start = end = last = null; // for tracking math delimiters
        math = []; // stores math strings for latter

        blocks = text.replace(/\r\n?/g, "\n").split(SPLIT);
        var block = void 0;
        for (var i = 1, m = blocks.length; i < m; i += 2) {
          block = blocks[i];
          if (inline && block.match(/[\n`]/)) {
            start = end = last = null;
          } else if (block.charAt(0) === "@") {

            blocks[i] = "@@" + math.length + "@@";
            math.push(block);
          } else if (start) {

            if (block === end) {
              if (braces) {
                last = i;
              } else {
                processMath(start, i);
              }
            } else if (block.match(/\n.*\n/)) {
              if (last) {
                i = last;
                processMath(start, i);
              }
              start = end = last = null;
              braces = 0;
            } else if (block === "{") {
              braces++;
            } else if (block === "}" && braces) {
              braces--;
            }
          } else {
            //
            // Look for math start delimiters and when
            // found, set up the end delimiter.
            //
            if (/^\$\$?$/.test(block)) {
              inline = block.length < 2;
              start = i;
              end = block;
              braces = 0;
            } else if (block.substr(1, 5) === "begin") {
              start = i;
              end = "\\end" + block.substr(6);
              braces = 0;
            }
          }
        }
        if (last) {
          processMath(start, last);
        }
        return blocks.join("");
      };

      try {
        var text = void 0;
        if (hasMarkdownSrc) {
          text = markdownSrc;
        } else {
          markdownSrc = mdContainer.innerHTML;
          text = _this.getMarkdownSrc(mdContainer);
        }
        text = Render.tocReady(text);
        // 判断代码段数量，超过 50个不使用 codeMirror
        var codeReg = /^```/gm;
        var codeCount = text.match(codeReg);
        if (codeCount) {
          codeCount = codeCount.length / 2;
        } else {
          codeCount = 0;
        }
        markdownExtra.init(converter, { extensions: "all", highlighter: codeCount > 50 ? "prettify" : "codeMirror" });
        // markdownExtra.init(converter, {extensions: "all", highlighter: "prettify"});
        // markdownExtra.init(converter, {extensions: "all", highlighter: "codeMirror"});

        // 判断是否含有mathjax语法
        var judgeMathjaxText = text.replace(/\n/g, '\\n').replace(/\r\n?/g, "\n").replace(/```(.*\n)+?```/gm, '');
        isMathJax = /(\$\$?)[^$\n]+\1/.test(judgeMathjaxText);

        if (isMathJax) {
          text = removeMath(text);
        }
        text = converter.makeHtml(text);
        text = Render.tocFixForCode(text);
        if (isMathJax) {
          text = replaceMath(text);
        }
        text = Render.xssFilter(text);
        $body[0].innerHTML = text;
      } catch (e) {
        console.error(e);
      }
    },
    /**
     * 对markdown的 html 内容进行预处理，已显示图片，todoList 等等
     * @param dom 传入的dom对象
     */
    markdownPreProcess: function markdownPreProcess(dom) {
      // 对于隐藏的对象，一律忽略

      //处理 table 容器
      utils.forEach(dom.querySelectorAll('.' + CONST.CLASS.TABLE_CONTAINER), function (target) {
        if (!domUtils.isVisible(target)) {
          return;
        }
        var span = mdDoc.createElement('span');
        span.appendChild(mdDoc.createTextNode(target.outerHTML));
        target.parentNode.insertBefore(span, target);
        target.parentNode.insertBefore(mdDoc.createElement('br'), target);
        target.parentNode.removeChild(target);
      });

      //处理 旧版本 todolist
      utils.forEach(dom.querySelectorAll('label.' + CONST.CLASS.TODO_LABEL_OLD), function (target) {
        if (!domUtils.isVisible(target)) {
          return;
        }
        //检测如果是遗留的 label 则不进行特殊处理
        var img = target.querySelector('.' + CONST.CLASS.TODO_CHECK_IMG_OLD);
        if (!img) {
          return;
        }

        var span = mdDoc.createElement('span');
        span.appendChild(mdDoc.createTextNode(target.outerHTML));
        target.parentNode.insertBefore(span, target);
        target.parentNode.removeChild(target);
      });

      //处理 todolist
      utils.forEach(dom.querySelectorAll('.' + CONST.CLASS.TODO_LAYER), function (target) {
        if (!domUtils.isVisible(target)) {
          return;
        }
        //检测如果是遗留的 todoList 则不进行特殊处理
        var checkbox = target.querySelector('.' + CONST.CLASS.TODO_CHECKBOX);
        if (!checkbox) {
          return;
        }

        var span = mdDoc.createElement('span');
        span.appendChild(mdDoc.createTextNode(target.outerHTML));
        target.parentNode.insertBefore(span, target);
        target.parentNode.removeChild(target);
      });

      //处理 a 超链接
      utils.forEach(dom.querySelectorAll('a'), function (target) {
        if (!domUtils.isVisible(target)) {
          return;
        }
        var href = target.getAttribute('href');
        // if (href && /^(wiz|wiznote):/.test(href)) {
        // 不应该按照 href 进行判断，应该按照 element 处理（即：纯文本的超链接不进行特殊处理）
        // wiz 内链必须要特殊处理，否则会丢失连接
        if (href && (/^(wiz|wiznote):/.test(href) || target.childElementCount > 0)) {
          var span = mdDoc.createElement('span');
          span.appendChild(mdDoc.createTextNode(target.outerHTML));
          target.parentNode.insertBefore(span, target);
          target.parentNode.removeChild(target);
        }
      });

      // 必须先处理 A 标签，后处理 Img，否则 A 标签包含 Img 后 会导致 Img 被转义为 html 源码
      //处理 img
      utils.forEach(dom.querySelectorAll('img'), function (target) {
        if (!domUtils.isVisible(target)) {
          return;
        }
        var span = mdDoc.createElement('span');
        span.appendChild(mdDoc.createTextNode(target.outerHTML));
        target.parentNode.insertBefore(span, target);
        target.parentNode.removeChild(target);
      });

      //处理段落 p
      utils.forEach(dom.querySelectorAll('p'), function (target) {
        if (!domUtils.isVisible(target)) {
          return;
        }
        var div = mdDoc.createElement('div');
        target.parentNode.insertBefore(div, target);
        while (target.firstChild) {
          div.appendChild(target.firstChild);
        }
        target.parentNode.removeChild(target);
      });
    },
    tocReady: function tocReady(markdownStr) {
      return markdownStr.replace(/(^[ ]*)(\[toc])([ ]*(\n|$))/igm, '$1$2(' + WizToc + ')$3');
    },
    tocFixForCode: function tocFixForCode(html) {
      var reg = new RegExp('(\\[toc])\\(' + WizToc + '\\)', 'ig');
      html = html.replace(/<textarea [^>]*>(.|\r?\n)*<\/textarea>/ig, function (str) {
        return str.replace(reg, '$1');
      });
      return html;
    },
    tocRender: function tocRender() {
      var idMap = {},
          tocHtml = [],
          maxH = 6;
      mdWin.$('h1,h2,h3,h4,h5,h6', mdContainer).each(function (index, item) {
        var n = parseInt(item.tagName.charAt(1), 10);
        maxH = Math.min(maxH, n);
      });
      mdWin.$('h1,h2,h3,h4,h5,h6', mdContainer).each(function (index, item) {
        var id = (item.textContent || item.innerText).replace(/[()<> '"\r\n]/g, '');
        if (!idMap[id]) {
          idMap[id] = 1;
        } else {
          ++idMap[id];
          id += '-' + idMap[id];
        }
        var n = parseInt(item.tagName.charAt(1), 10);
        var $item = mdWin.$(item);
        $item.attr('id', id);
        tocHtml.push('<a class="wiz_toc ' + 'h' + (n - maxH + 1) + '" href="#' + id + '">' + $item.text() + '</a>');
      });
      tocHtml = '<div class="wiz_toc_layer">' + tocHtml.join('<br/>') + '</div>';

      mdWin.$('a', mdContainer).each(function (index, item) {
        item = mdWin.$(item);
        if (item.attr('href') === WizToc) {
          item.before(tocHtml);
          item.css('display', 'none');
        }
      });
    },
    flowRender: function flowRender() {
      if (!mdWin.flowchart) {
        return;
      }
      var f = mdWin.$('.language-flow', mdContainer).parents('pre');
      f.each(function (fIndex, fObj) {
        var id = 'wiz-flow-' + fIndex;
        var flowStr = mdWin.$('textarea', fObj).val();
        if (flowStr.length > 0) {
          try {
            fObj.style.display = 'none';
            var diagram = mdWin.flowchart.parse(flowStr);
            var flowLayer = mdDoc.createElement('div');
            flowLayer.id = id;
            fObj.parentNode.insertBefore(flowLayer, fObj);
            diagram.drawSVG(id);

            //修正 svg 保证手机端自动适应大小
            if (env.client.type.isPhone) {
              //pc、mac 客户端 取消height 设置后， 会导致height 变为0，从而不显示
              var s = mdWin.$('svg', flowLayer);
              if (s.attr('width')) {
                s.css({
                  'max-width': s.attr('width')
                }).attr({
                  'height': null,
                  'width': '95%'
                });
              }
            }
          } catch (e) {
            console.error(e);
          }
        }
      });
    },
    sequenceRender: function sequenceRender() {
      if (!mdWin.Diagram) {
        return;
      }

      var _do = function _do(list) {
        list.each(function (fIndex, fObj) {
          var id = 'wiz-sequence-' + fIndex;
          var seqStr = mdWin.$('textarea', fObj).val();
          if (seqStr.length > 0) {
            try {
              fObj.style.display = 'none';
              var diagram = mdWin.Diagram.parse(seqStr);
              var seqLayer = mdDoc.createElement('div');
              seqLayer.id = id;
              fObj.parentNode.insertBefore(seqLayer, fObj);
              diagram.drawSVG(id, { theme: 'simple' });

              //修正 svg 保证手机端自动适应大小
              if (env.client.type.isPhone) {
                //pc、mac 客户端 取消height 设置后， 会导致height 变为0，从而不显示
                var s = mdWin.$('svg', seqLayer);
                if (s.attr('width')) {
                  domUtils.attr(s.get(0), { viewBox: '0 0 ' + s.attr('width') + ' ' + s.attr('height') });
                  s.css({
                    'max-width': s.attr('width')
                  }).attr({
                    'preserveAspectRatio': 'xMidYMid meet',
                    'height': null,
                    'width': '95%'
                  });
                }
              }
            } catch (e) {
              console.error(e);
            }
          }
        });
      };
      var f = mdWin.$('.language-sequence', mdContainer).parents('pre');
      _do(f);
      f = mdWin.$('.language-seq', mdContainer).parents('pre');
      _do(f);
    },
    xssFilter: xssUtils.xssFilter
  };

  this.getMarkdownSrcForEditor = function (options) {
    // 必须首先把 code 保存到 textarea 内部
    if (codeUtils) {
      codeUtils.saveToText();
    }

    options = options || {};

    var src = void 0;
    var html = void 0;
    if (env.readonly) {
      // 因为还需要将 img 等处理为 markdown 格式，所以采用编辑状态的处理方式，统一处理
      html = markdownSrc.replace(/\n/g, '<div><br/></div>');
    } else {
      html = env.body.innerHTML;
    }

    var tmp = env.doc.createElement('div');
    if (options.escapeHtml) {
      // 必须首先将之前的文本 < > 进行替换，
      // 否则 文本的 < > 会与 后面 markdownPreProcess 方法内处理的 脚本混淆
      html = html.replace(/&/g, '&amp;');
    }
    tmp.innerHTML = html;

    //将 img、a html 元素转化为 markdown 语法
    domUtils.html2Markdown(tmp, { noPureLink: true });

    domUtils.css(tmp, {
      opacity: 0,
      position: 'absolute',
      top: '-9999px',
      left: '-9999px',
      width: '1px',
      height: '1px',
      overflow: 'hidden'
    });
    env.body.appendChild(tmp);

    if (codeUtils) {
      codeUtils.clearCodeForMarkdown(tmp);
    }

    // 清理 临时 tag
    var wizTmpList = tmp.querySelectorAll(CONST.TAG.TMP_TAG);
    for (var i = wizTmpList.length - 1; i >= 0; i--) {
      domUtils.remove(wizTmpList[i]);
    }

    src = _this.getMarkdownSrc(tmp);
    src = domUtils.restoreImgPath(src);
    env.body.removeChild(tmp);
    tmp = null;
    return src;
  };

  this.getMarkdownSrc = function (container) {
    var $body = container ? container : mdContainer;
    Render.markdownPreProcess($body);
    return Render.getBodyTxt($body);
  };

  this.do = function (_options, callback) {
    if (_options.container) {
      mdContainer = _options.container;
    }
    if (typeof _options.markdownSrc === 'string') {
      markdownSrc = _options.markdownSrc;
      hasMarkdownSrc = true;
    } else {
      markdownSrc = '';
      hasMarkdownSrc = false;
    }

    var loadCallback = function loadCallback() {
      domUtils.addClass(mdContainer, CONST.CLASS.READONLY);

      var timeout = env.options.reader.timeout.markdown;
      callback = callback || mdCallback;
      var hasCalled = false;
      var cb = function cb() {
        if (callback && /^function$/i.test(typeof callback === 'undefined' ? 'undefined' : _typeof(callback)) && !hasCalled) {
          callback();
          hasCalled = true;
        }
      };

      setTimeout(cb, timeout);
      markdownStart(function () {
        cb();
      });
    };
    loadDependency(loadCallback);
  };

  this.init = function () {
    mdWin = mdOptions.win || env.win;
    mdDoc = mdOptions.doc || env.doc;
    mdContainer = mdOptions.container || env.body;
    mdCallback = mdOptions.callback;
    if (mathJaxRender) {
      mathJaxRender.init();
    }
  };
};

module.exports = MarkdownRender;

},{"../config/const":388,"../libs/LoadController":393,"../libs/Markdown.Converter":394,"../libs/Markdown.Extra":395,"../libs/dependLoader":397,"../libs/utils":400,"../libs/xssUtils":401}],348:[function(require,module,exports){
'use strict';

/**
 * markdown & mathjax 渲染处理
 */
var dependLoader = require('../libs/dependLoader'),
    scriptLoader = require('../libs/scriptLoader'),
    LoadController = require('../libs/LoadController');

var loadController = new LoadController();
var config = 'MathJax.Hub.Config({\n  skipStartupTypeset: true,\n  "HTML-CSS": {\n      preferredFont: "TeX",\n      availableFonts: [\n          "STIX",\n          "TeX"\n      ],\n      linebreaks: {\n          automatic: true\n      },\n      EqnChunk: 10,\n      imageFont: null\n  },\n  SVG: { linebreaks: { automatic: true } },\n  tex2jax: {\n      inlineMath: [["$","$"],["\\\\\\\\(","\\\\\\\\)"]],\n      displayMath: [["$$","$$"],["\\\\[","\\\\]"]],\n      processEscapes: true },\n  TeX: {\n      equationNumbers: {\n          autoNumber: "AMS"\n      },\n      noUndefined: {\n          attributes: {\n              mathcolor: "red",\n              mathbackground: "#FFEEEE",\n              mathsize: "90%"\n          }\n      },\n      Safe: {\n          allow: {\n              URLs: "safe",\n              classes: "safe",\n              cssIDs: "safe",\n              styles: "safe",\n              fontsize: "all"\n          }\n      }\n  },\n  messageStyle: "none"\n});';

var MathJaxRender = function MathJaxRender(mjOptions) {
  var _this = this;

  mjOptions = mjOptions || {};

  var core = null;
  var env = null;
  var domUtils = null;

  var mjWin = void 0;
  var mjDoc = void 0;
  var mjContainer = void 0;
  var mjCallback = void 0;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;

    _this.init();
  };

  var loadDependency = function loadDependency(callback) {
    loadController.addCallback(mjDoc, callback);
    if (loadController.getLoading(mjDoc)) {
      return;
    }
    // TODO MathJax 代码每次切换 编辑、阅读后，必须要重新加载，否则会导致 渲染失败
    // if (!mjWin.MathJax) {
    loadController.setLoading(mjDoc, true);
    scriptLoader.appendJsCode(mjDoc, 'MathJax = null', 'text/javascript');
    scriptLoader.appendJsCode(mjDoc, config, 'text/x-mathjax-config');
    var files = dependLoader.getDependencyFiles(env.dependency, 'js', 'mathJax');
    for (var i = 0; i < files.length; i++) {
      var groupFiles = files[i];
      for (var j = 0; j < groupFiles.length; j++) {
        var file = groupFiles[j];
        if (file.indexOf('MathJax.js') > -1) {
          var js = env.doc.getElementById('wiz_' + file);
          if (js) {
            domUtils.remove(js);
          }
        }
      }
    }
    dependLoader.loadJs(mjDoc, files, function () {
      loadController.setLoading(mjDoc, false);
      loadController.callback(mjDoc);
    });
    // } else {
    //   loadController.callback();
    // }
  };
  var mathJaxStart = function mathJaxStart(_callback) {
    mjWin.MathJax.Hub.Queue(["Typeset", mjWin.MathJax.Hub, mjContainer, function () {
      _callback();
    }]);
  };

  this.do = function (_options, callback) {
    if (_options.container) {
      mjContainer = _options.container;
    }
    var loadCallback = function loadCallback() {
      var timeout = env.options.reader.timeout.mathJax;
      callback = callback || mjCallback;
      var hasCalled = false,
          cb = function cb() {
        if (callback && !hasCalled) {
          callback();
          hasCalled = true;
        }
      };

      setTimeout(cb, timeout);
      mathJaxStart(function () {
        if (env.options.reader.callback.mathJax) {
          env.options.reader.callback.mathJax();
        }
        cb();
      });
    };
    loadDependency(loadCallback);
  };

  this.init = function () {
    mjWin = mjOptions.win || env.win;
    mjDoc = mjOptions.doc || env.doc;
    mjContainer = mjOptions.container || env.body;
    mjCallback = mjOptions.callback;
  };
};

module.exports = MathJaxRender;

},{"../libs/LoadController":393,"../libs/dependLoader":397,"../libs/scriptLoader":399}],349:[function(require,module,exports){
'use strict';

/**
 * 夜间模式的基本方法集合
 */
var CONST = require('../config/const');

var COLOR = '#7990b6',
    BG_COLOR = '#1f2126',
    BRIGHTNESS = '50%',
    BRIGHTNESS_SVG = '70%';

var NightModeUtils = function NightModeUtils() {
  var _this = this;

  var core = null;
  var env = null;
  var domUtils = null;
  var wizStyle = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
    wizStyle = core.require.wizStyle;
  };

  var styleId = 'wiz_night_mode_style';

  var addKeyToMap = function addKeyToMap(key, map) {
    //只保留 非数字开头的 且 全部内容为 数字、英文字母、. - _ 的 key
    if (!map[key] && !/^[.|#]?[\d]+/i.test(key) && /^[.|#]?[. \w-]+$/i.test(key)) {
      key = key.replace(/[.\-]/g, function (m1, index) {
        if (index > 0) {
          return '\\' + m1;
        } else {
          return m1;
        }
      });
      map[key] = "";
    }
  };
  var addItemAttrToMap = function addItemAttrToMap(pId, e, map) {
    if (!e) {
      return;
    }
    var tagName = e.tagName.toLowerCase();

    if (/^(style|script|link|meta|img)$/ig.test(tagName)) {
      return;
    }

    //todoList 的图片需要排除
    if (domUtils.hasClass(e, CONST.CLASS.TODO_CHECKBOX) || domUtils.hasClass(e, CONST.CLASS.TODO_AVATAR)) {
      return;
    }

    var className = e.className;
    if (className && className.length > 0) {
      var arr = className.split(" ");
      for (var i = 0; i < arr.length; i++) {
        var name = arr[i];
        if (name.length === 0) {
          continue;
        }
        //if (!!pId) {
        //    addKeyToMap('#' + pId + " ." + name, map);
        //} else {
        addKeyToMap("." + keyFilter(name), map);
        //}
      }
    }
    var id = e.id;
    if (id && id.length > 0) {
      addKeyToMap("#" + keyFilter(id), map);
    }
    //某些页面的控件给自己的特殊样式添加 !important，这些控件一般会在顶层 dom 设置 id ，所以都加上 id
    //为了减少 样式冗余，目前只给 tag 添加 id ， className 暂时不添加
    if (!!pId && !/wiz[\-_]/i.test(pId)) {
      addKeyToMap('#' + keyFilter(pId) + " " + tagName, map);
    } else {
      addKeyToMap(keyFilter(tagName), map);
    }
  };
  var checkElement = function checkElement(pId, e, map) {
    if (domUtils.hasClass(e, CONST.CLASS.TABLE_TOOLS) || pId === CONST.ID.TABLE_RANGE_BORDER || e.id === CONST.ID.TABLE_RANGE_BORDER ||
    // domUtils.hasClass(e, 'CodeMirror-selected') ||
    domUtils.hasClass(e, CONST.CLASS.CODE_CONTAINER)) {
      // wiz table/code 的样式不进行特殊处理，后面有特定样式注入
      return;
    }

    addItemAttrToMap(pId, e, map);
    var elements = e.children;
    for (var i = 0; i < elements.length; i++) {
      var child = elements[i];
      checkElement(e.id ? e.id : pId, child, map);
    }
  };
  var keyFilter = function keyFilter(key) {
    return key.replace(/ /g, '');
  };

  this.getBaseStyle = function (color, bgColor) {

    color = color || env.options.nightMode.color || COLOR;
    bgColor = bgColor || env.options.nightMode.bgColor || BG_COLOR;

    var map = { div: '', p: '' },
        arr = [];

    checkElement('', env.body, map);

    var baseStyle = '{' + 'color:' + color + ' !important; ' + 'background-color:' + bgColor + ' !important; ' + 'background-image: none !important; ' + 'box-shadow: none !important; ' + 'border-color:' + color + ' !important; ' + '}';

    for (var key in map) {
      if (map.hasOwnProperty(key)) {
        arr.push(key);
      }
    }

    var cssText = arr.join(", ");
    cssText += baseStyle;
    return cssText;
  };

  this.on = function (color, bgColor, brightness) {
    if (!env.options.nightMode.enable) {
      return;
    }
    brightness = brightness || env.options.nightMode.brightness || BRIGHTNESS;
    var brightnessSvg = BRIGHTNESS_SVG;

    var colorClient = {
      toc: {
        bg: '#2b2f38'
      }
    };
    if (env.client.type.isMac) {
      colorClient.toc.bg = '#2e2e2e';
    }

    _this.off();

    var cssText = _this.getBaseStyle(color, bgColor);
    //image brightness
    cssText += 'img {filter: brightness(' + brightness + ');-webkit-filter: brightness(' + brightness + ');}';
    cssText += 'svg, iframe {filter: brightness(' + brightnessSvg + ');-webkit-filter: brightness(' + brightnessSvg + ');}';
    cssText += 'iframe#wiz-content-iframe-viewer {filter:none;-webkit-filter:none;}';
    cssText += CONST.TAG.TMP_HIGHLIGHT_TAG + '{background-color: #50a9fb !important;  color: black !important;}';
    cssText += 'a, a:visited, a:active {color: #448aff !important;}';

    cssText += 'div.wiz-code-container .CodeMirror {border: 1px solid rgba(255, 255, 255, 0.2) !important; box-shadow: 0px 3px 6px rgba(0, 0, 0, 0.2) !important;}';
    cssText += 'div.CodeMirror-selected {background-color: #49483E !important;}';

    cssText += '.wiz-editor-body .wiz_toc_layer {background-color: ' + colorClient.toc.bg + ' !important;}';
    cssText += '.wiz-editor-body .wiz_toc_layer a, ' + '.wiz-editor-body .wiz_toc_layer a:visited, ' + '.wiz-editor-body .wiz_toc_layer a:active {background-color: ' + colorClient.toc.bg + ' !important; color: #448aff !important;}';

    cssText += '.wiz-table-tools {background-color:#22272F !important; border-color: #3E495B !important;}';
    cssText += '.wiz-table-tools i.editor-icon {color: #97A3B8;}';
    cssText += '.wiz-table-tools .wiz-table-menu-sub-item:hover {background-color: #2E353F !important;}';
    cssText += '.wiz-table-tools .wiz-table-menu-sub-item {color: #97A3B8 !important;}';
    cssText += '.wiz-table-tools .wiz-table-menu-sub-item.disabled {color: #484E5C !important;}';
    cssText += '.wiz-table-tools .wiz-table-menu-sub-item.split {border-top-color: #3E495B !important;}';
    cssText += '.wiz-table-tools .wiz-table-menu-sub, ' + '.wiz-table-tools .wiz-table-color-pad, ' + '.wiz-table-tools .wiz-table-cell-align' + ' {background-color: #22272F !important; border-color: #3E495B !important; box-shadow: none;}';
    cssText += '.wiz-table-tools .wiz-table-menu-sub:before ' + ' {display: none !important;}';
    cssText += '.wiz-table-tools .wiz-table-menu-sub:after ' + ' {border-bottom-color: #3E495B !important;top:-8px;}';
    cssText += '.wiz-table-tools .wiz-table-menu-sub > div, ' + '.wiz-table-tools .wiz-table-menu-sub-item.disabled:hover, ' + '.wiz-table-tools .wiz-table-menu-item .wiz-table-menu-button, ' + '.wiz-table-tools .wiz-table-cell-align .wiz-table-cell-align-item, ' + '.wiz-table-tools .wiz-table-color-pad .wiz-table-color-pad-item {background-color: transparent !important;}';

    cssText += '#wiz-table-col-line, #wiz-table-row-line, ' + '#wiz-table-range-border_start_top, #wiz-table-range-border_range_top, ' + '#wiz-table-range-border_start_right, #wiz-table-range-border_range_right, ' + '#wiz-table-range-border_start_bottom, #wiz-table-range-border_range_bottom, ' + '#wiz-table-range-border_start_left, #wiz-table-range-border_range_left,' + '#wiz-table-range-border_start_dot, #wiz-table-range-border_range_dot ' + ' {background-color: #448aff !important;}' + '';

    cssText += '.markdown-body table tr {background-color:transparent !important;}';
    cssText += '.markdown-body code, ' + '.markdown-body tt {background-color:#4c3d40 !important; color:#cf506f !important;}';

    cssText += '.wiz-editor-body .wiz-select-plugin-header ' + ' {background-color: transparent !important;}';
    cssText += '.wiz-editor-body .wiz-select-plugin-container, ' + '.wiz-editor-body .wiz-select-plugin-options ' + ' {background-color:#22272F !important; border-color: #3E495B !important;' + 'color: #97A3B8 !important;box-shadow:none;}';
    cssText += '.wiz-editor-body .wiz-select-plugin-header ' + ' {color: #97A3B8 !important;}';
    cssText += '.wiz-editor-body .wiz-select-plugin-options .wiz-select-plugin-options-item.selected, ' + '.wiz-editor-body .wiz-select-plugin-options .wiz-select-plugin-options-item:hover ' + ' {background-color: #2E353F !important;}';
    cssText += '.wiz-editor-body .wiz-select-plugin-header i ' + ' {border-left-color: #3E495B !important;}';
    cssText += '.wiz-editor-body .wiz-select-plugin-options .wiz-select-plugin-options-item div ' + ' {background-color: transparent !important;}';
    cssText += '.wiz-editor-body .wiz-select-plugin-options .wiz-select-plugin-options-item:hover div ' + ' {color: #FFFFFF !important;}';

    cssText += '.wiz-content-outer ' + ' {border-color: transparent !important;}';

    wizStyle.insertStyle({
      id: styleId,
      name: CONST.NAME.TMP_STYLE
    }, cssText);
  };
  this.off = function () {
    var style = env.doc.getElementById(styleId);
    if (style) {
      style.remove();
    }
  };
};

module.exports = NightModeUtils;

},{"../config/const":388}],350:[function(require,module,exports){
'use strict';

/**
 * paste 粘贴操作基本库
 */
var CONST = require('../config/const');
var utils = require('../libs/utils');
var xssUtils = require('../libs/xssUtils');

/**
 * 从剪切板粘贴内容
 */
var PasteUtils = function PasteUtils() {
  var _this = this;

  var core = null;
  var env = null;
  var amend = null;
  var amendUser = null;
  var amendUtils = null;
  var clipboardUtils = null;
  var codeCore = null;
  var codeUtils = null;
  var commandExtend = null;
  var domUtils = null;
  var historyUtils = null;
  var rangeUtils = null;
  var tableCore = null;
  var tableUtils = null;
  var tableZone = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    amend = core.require.amend;
    amendUser = core.require.amendUser;
    amendUtils = core.require.amendUtils;
    clipboardUtils = core.require.clipboardUtils;
    codeCore = core.require.codeCore;
    codeUtils = core.require.codeUtils;
    commandExtend = core.require.commandExtend;
    domUtils = core.require.domUtils;
    historyUtils = core.require.historyUtils;
    rangeUtils = core.require.rangeUtils;
    tableCore = core.require.tableCore;
    tableUtils = core.require.tableUtils;
    tableZone = core.require.tableZone;
  };

  var clearClipHtml = function clearClipHtml(html) {
    // excel 复制时， </html>后面有乱码，需要过滤
    // <html> <body> 之间会有 换行符，也必须要过滤
    // let startTag = ['<!--StartFragment-->', '<body>', '<html>'];
    // let endTag = ['<!--EndFragment-->', '</body>', '</html>'];

    // 不能只保留 StartFragment 内的东西， Excel 复制的表格 <table> 会处于外面
    // let fragmentReg = /<!--StartFragment-->((\r?\n|.)*)<!--EndFragment-->/gi;
    var fragmentReg = /<body[^>]*>([\s\S]*)<\/body>/gi;
    var headReg = /<head[^>]*>([\s\S]*)<\/head>/i;
    var styleReg = /<style[^>]*>[^<>]*<\/style>/ig;
    var classReg = /(<[^>]*)(class[ ]*=[ ]*(['"])[^>]*\3)([^>]*>)/ig;
    var idReg = /(<[^>]*)(id[ ]*=[ ]*(['"])[^>]*\3)([^>]*>)/ig;

    // 清理注释内容
    html = html.replace(/<!--.*?(-->)/ig, '');
    // 清理 meta
    html = html.replace(/<meta [^>]*>/ig, '');
    // 清理 iframe
    html = html.replace(/<iframe[^>]*>[\s\S]*?<\/iframe>/ig, '');
    html = html.replace(/<iframe[^>]*\/>/ig, '');
    // console.log(html);

    // 清理 style
    if (env.options.editor.type === CONST.NOTE_EDITOR_TYPE.MARKDOWN) {
      // markdown 编辑器必须清理样式
      html = html.replace(styleReg, '');
      html = html.replace(classReg, '$1$4');
      html = html.replace(idReg, '$1$4');
    }

    var body = void 0,
        head = void 0,
        m = void 0;
    try {
      body = fragmentReg.exec(html);
    } catch (e) {
      console.error(e);
    }

    if (body) {
      // xcode 复制的内容是标准的 html 页面， style 会存在于 head 内
      head = headReg.exec(html);
      html = '';
      if (head) {
        head = head[1];
        while ((m = styleReg.exec(head)) !== null) {
          if (m.index === styleReg.lastIndex) {
            styleReg.lastIndex++;
          }
          html += m[0];
        }
      }
      html += body[1];
    } else {
      var startTag = [/<body( [^<>]*)?>/i, /<html( [^<>]*)?>/i];
      var endTag = [/<\/body>/i, /<\/html>/i];

      for (var i = 0, j = startTag.length; i < j; i++) {
        var reg = startTag[i];
        var result = html.match(reg);
        if (result) {
          html = html.substr(result.index + result[0].length);
          break;
        }
      }
      for (var _i = 0, _j = endTag.length; _i < _j; _i++) {
        var _reg = endTag[_i];
        var _result = html.match(_reg);
        if (_result) {
          html = html.substr(0, _result.index);
        }
      }
    }
    // 清理前后换行
    html = html.replace(/(^(\r?\n)*)|((\r?\n)*$)/g, '');

    // 将文本内的 连续空格 替换为 &nbsp;
    html = html.replace(/\u00A0/ig, '&nbsp;');

    var styleWhiteList = [];
    if (env.options.editor.type === CONST.NOTE_EDITOR_TYPE.MARKDOWN) {
      // markdown 编辑模式下，目前只允许粘贴 table ，且 所有样式一律删除

    } else {
      // styleWhiteList = ['display', 'color', 'width',
      //   'font-family', 'font-size', 'font-style', 'font-weight',
      //   'text-align', 'text-indent',
      //   'background*', 'text-decoration*', 'padding*', 'margin*', 'list*', 'border*'];
      styleWhiteList = ['color', 'width', 'font-family', 'font-size', 'font-style', 'text-align', 'background*', 'text-decoration*'];
    }
    html = domUtils.clearStyleFromHtml(html, styleWhiteList);
    html = xssUtils.xssFilter(html);
    // 有时候复制部分表格，在剪贴板中没有table 只有 tr
    if (/^<tr/.test(html)) {
      html = '<table>' + html + '</table>';
    }
    return html;
  };

  var insertTxt = function insertTxt(txt) {
    var sel = rangeUtils.getSelection();
    var lineReg = /\n/g;
    var lineMatch = txt.match(lineReg);
    if (lineMatch && lineMatch.length > 400) {
      // 内容太多的情况下，需要优化性能(直接在 光标位置插入 html，不再考虑 li 等情况)
      var html = utils.txt2HTML(txt, { wizTableSaveDom: false });
      commandExtend.execCommand('insertparagraph');
      var range = rangeUtils.getRange();
      var dom = env.doc.createElement('div');
      range.insertNode(dom);
      dom.innerHTML = html;
      rangeUtils.setRangeToEnd(dom);
    } else {
      // 必须将 \r 删除，否则会导致 Chrome 插入时，直插入空的 <div></div>，从而在显示上空行丢失
      txt = txt.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      commandExtend.execCommand('insertText', false, txt);
    }
    sel.collapseToEnd();
  };

  var pasteWithStandard = function pasteWithStandard(html, txt) {
    var container = env.doc.createElement('div');
    var fixed = void 0;

    if (amend.isAmendEditing()) {
      //修订模式下， 表格外 粘贴
      amend.readyForPaste();
    } else {
      //非修订模式下， 表格外 粘贴
      fixed = amendUtils.fixedAmendRange();
      amend.splitAmendDomByRange(fixed);
    }
    var range = rangeUtils.getRange();
    var start = void 0,
        line = void 0;
    var tmpParent = void 0,
        tmpChild = void 0,
        pasteTag = void 0,
        targetBlock = void 0;
    var lastTag = null;

    if (html) {
      container.innerHTML = html;

      if (env.options.editor.type === CONST.NOTE_EDITOR_TYPE.MARKDOWN) {
        domUtils.html2Markdown(container, { noPureLink: false });
      }

      // 修正复制过来的 CodeMirror
      if (codeUtils) {
        codeUtils.pastePatch.ready(container);
      }

      // 清理外部 width 样式
      clearWidth(container);

      // 粘贴起始位置 是空行，则选中行内所有元素（主要用于减少 br）
      start = rangeUtils.getRangeDetail(range.startContainer, range.startOffset);
      line = domUtils.getParentByTagName(start.container, ['li', 'td', 'th'], true);
      if (domUtils.isEmptyDom(line)) {
        rangeUtils.setRange(line, 0, line, domUtils.getEndOffset(line));
        range = rangeUtils.getRange();
      } else if (domUtils.isTag(start.container, 'br')) {
        rangeUtils.setRange(start.container.parentNode, domUtils.getIndex(start.container));
        range = rangeUtils.getRange();
      }

      while (container.firstChild) {
        range = rangeUtils.getRange();
        start = rangeUtils.getRangeDetail(range.startContainer, range.startOffset);
        targetBlock = domUtils.getBlockParent(start.container, true);
        tmpParent = domUtils.getParentByTagName(targetBlock, ['pre'], true);
        if (tmpParent) {
          targetBlock = tmpParent;
        }
        pasteTag = container.firstChild;
        if (/^h[1-6]$/i.test(targetBlock.tagName) && (pasteTag.tagName === targetBlock.tagName || pasteTag.nodeType === 3 || domUtils.isTag(pasteTag, ['span']))) {
          // 如果 光标位置是 H1 - H6 且 粘贴的元素 是同样的 H1 - H6 或者 是 span 和 textNode
          // 则直接当作文本接入 H1 - H6
          tmpChild = env.doc.createElement('span');
          tmpChild.appendChild(env.doc.createTextNode(pasteTag.nodeType === 3 ? pasteTag.nodeValue : pasteTag.innerText));
          range.deleteContents();
          range.insertNode(tmpChild);
          container.removeChild(pasteTag);
          pasteTag = tmpChild;
        } else if (/^h[1-6]$/i.test(targetBlock.tagName) || /^h[1-6]$/i.test(pasteTag.tagName) && targetBlock !== env.body && !domUtils.isParent(targetBlock, lastTag)) {
          // 如果 光标位置 与 粘贴的元素 是不相同的 H1 - H6，
          // 或 光标位置不是 H1 - H6 且 粘贴的元素 是 H1 - H6，
          // 或 光标位置是 H1 - H6 且 粘贴的元素 是普通块元素
          // 则从光标位置拆分 光标位置的 Block，然后插入粘贴的元素
          tmpChild = env.doc.createElement('span');
          range.insertNode(tmpChild);
          targetBlock = domUtils.splitDomBeforeSub(targetBlock, tmpChild);
          domUtils.after(pasteTag, targetBlock);
          if (domUtils.isEmptyDom(targetBlock)) {
            domUtils.remove(targetBlock);
          } else {
            domUtils.remove(tmpChild);
          }
        } else if (lastTag) {
          // 当不满足以上条件，且是粘贴中非首个元素时，直接将 粘贴的元素放置到 last 后面
          domUtils.after(pasteTag, lastTag);
        } else {
          // 其他情况全部使用 insertNode 方法让浏览器自行处理
          range.insertNode(pasteTag);
        }

        if (env.options.editor.type === CONST.NOTE_EDITOR_TYPE.MARKDOWN) {
          // markdown 笔记粘贴时 td/th 内只保留 text
          clearTable(pasteTag);
          pasteTag = transformDomToSpan(pasteTag);
        }

        rangeUtils.setRangeToEnd(pasteTag);
        // console.log(pasteTag);
        lastTag = pasteTag;
      }
    } else {
      insertTxt(txt);
    }
  };

  var clearTable = function clearTable(container) {
    if (container.nodeType !== 1) {
      return;
    }
    var clearTd = function clearTd(tdList) {
      for (var i = 0; i < tdList.length; i++) {
        var td = tdList[i];
        clearDomInner(td);
        // td.innerText = td.innerText.trim();
      }
    };
    var clearDomInner = function clearDomInner(dom) {
      // 超链接、img 保持 dom 结构
      var aMap = {},
          imgMap = {};
      var imgList = dom.querySelectorAll('img');
      var index = 0;
      // <a> 里面可能会嵌套 <img>，所以先处理 img
      for (var i = imgList.length - 1; i >= 0; i--) {
        replaceDom(index++, imgList[i], imgMap);
      }
      var aList = dom.querySelectorAll('a');
      for (var _i2 = aList.length - 1; _i2 >= 0; _i2--) {
        replaceDom(index++, aList[_i2], aMap);
      }

      dom.innerText = dom.innerText.trim();
      var str = dom.innerHTML;
      //恢复时，先恢复 <a>，后恢复 <img>
      dom.innerHTML = restoreDom(restoreDom(str, aMap), imgMap);
    };
    var replaceDom = function replaceDom(id, dom, domMap) {
      id = '$$_WIZ_' + new Date().valueOf() + '_' + id + '_$$';
      domMap[id] = dom.outerHTML;
      var text = env.doc.createTextNode(id);
      domUtils.after(text, dom);
      domUtils.remove(dom);
    };
    var restoreDom = function restoreDom(str, domMap) {
      for (var k in domMap) {
        str = str.replace(k, domMap[k]);
      }
      return str;
    };
    clearTd(container.querySelectorAll('td'));
    clearTd(container.querySelectorAll('th'));
  };

  // 清理剩余的 外部 width 样式
  var clearWidth = function clearWidth(container) {
    var domList = container.querySelectorAll('[style]');
    for (var i = domList.length - 1; i >= 0; i--) {
      var dom = domList[i];
      if (dom.getAttribute(CONST.ATTR.SPAN) || domUtils.isTag(dom, ['td', 'table'])) {
        continue;
      }
      var width = dom.style.width;
      if (width) {
        dom.style.width = null;
      }
    }
  };

  // 专门处理 u i b strong
  var transformDomToSpan = function transformDomToSpan(container) {
    if (container.nodeType !== 1) {
      return container;
    }
    var trans = function trans(domList) {
      var result = [];
      for (var i = domList.length - 1; i >= 0; i--) {
        var dom = domList[i];
        var span = env.doc.createElement('span');
        while (dom.firstChild) {
          span.appendChild(dom.firstChild);
        }
        domUtils.before(span, dom);
        domUtils.remove(dom);
        result.push(span);
      }
      return result;
    };
    trans(container.querySelectorAll('strong'));
    trans(container.querySelectorAll('u'));
    trans(container.querySelectorAll('i'));
    trans(container.querySelectorAll('b'));
    if (domUtils.isTag(container, ['u', 'i', 'b', 'strong'])) {
      container = trans([container])[0];
    }
    return container;
  };

  var pasteWithTable = function pasteWithTable(html, txt) {
    // let fixed,
    var template = void 0,
        target = void 0,
        gridPaste = void 0,
        pasteCell = void 0,
        pasteColCount = void 0,
        pasteRowCount = void 0,
        addColCount = void 0,
        addRowCount = void 0,
        maxCol = void 0,
        maxRow = void 0,
        x = void 0,
        y = void 0,
        cell = void 0;

    var range = rangeUtils.getRange(),
        zone = tableZone.getZone();

    // 在表格内粘贴
    if (html) {
      template = tableUtils.getTemplateByHtmlForPaste(html);
      template.isHtml = true;
      // 修正复制过来的 CodeMirror
      if (codeUtils) {
        codeUtils.pastePatch.ready(template.pasteDom, true);
      }
    } else if (txt && !tableZone.isSingleCell()) {
      template = tableUtils.getTemplateByTxtForPaste(txt);
      template.isHtml = true;
    } else {
      template = {
        isTable: false,
        isHtml: false,
        pasteDom: env.doc.createElement('div')
      };
    }
    // console.log(template.isTable);
    // console.log(template.pasteDom);

    if (!template.isTable) {
      // 粘贴普通文本
      if (!range && zone.range) {
        //如果选择了多个单元格，则只粘贴到左上角的单元格内
        target = zone.grid[zone.range.minY][zone.range.minX].cell;
        tableZone.setStart(target).setEnd(target);
        rangeUtils.setRange(target, 0, target.lastChild, domUtils.getEndOffset(target.lastChild));
      }
      pasteWithStandard(html, txt);
    } else {
      // 粘贴表格

      // 清理外部 width 样式
      clearWidth(template.pasteDom);

      //分析剪切板内的表格范围
      gridPaste = tableUtils.getTableGrid(template.pasteDom);
      pasteRowCount = gridPaste.length;
      pasteColCount = gridPaste[0] ? gridPaste[0].length : 0;

      //从起始点 cellData 根据 剪切板内表格范围 判断是否需要增加 表格的列、行
      addRowCount = zone.grid.length - zone.range.minY - pasteRowCount;
      addColCount = zone.grid[0].length - zone.range.minX - pasteColCount;

      for (y = addRowCount; y < 0; y++) {
        tableCore.insertRow(false);
      }
      for (x = addColCount; x < 0; x++) {
        tableCore.insertCol(false);
      }

      //分析已选择的表格范围
      zone = tableZone.getZone();
      if (!html) {
        //从文本转义的 table 只复制一次，不允许反复被粘贴
        maxRow = zone.range.minY + pasteRowCount - 1;
        maxCol = zone.range.minX + pasteColCount - 1;
      } else {
        maxRow = Math.max(zone.range.minY + pasteRowCount - 1, zone.range.maxY);
        maxCol = Math.max(zone.range.minX + pasteColCount - 1, zone.range.maxX);
      }

      //从起始点 cellData 开始 循环粘贴剪切板单元格
      tableUtils.eachRange(zone.grid, {
        minY: zone.range.minY,
        maxY: maxRow,
        minX: zone.range.minX,
        maxX: maxCol
      }, function (cellData) {
        if (!cellData.fake) {
          cell = cellData.cell;
          pasteCell = gridPaste[(cellData.y - zone.range.minY) % pasteRowCount][(cellData.x - zone.range.minX) % pasteColCount];

          if (amend.isAmendEditing()) {
            //修订模式 预处理
            rangeUtils.setRange(cell, 0, cell.lastChild, domUtils.getEndOffset(cell.lastChild));
            amendUtils.removeSelection(amendUser.getCurUser());
            amendUtils.removeUserDel(cell, amendUser.getCurUser());

            if (pasteCell.fake) {
              return;
            }

            if (domUtils.isEmptyDom(cell)) {
              cell.innerHTML = pasteCell.cell.innerHTML;
            } else {
              while (pasteCell.cell.firstChild) {
                cell.appendChild(pasteCell.cell.firstChild);
              }
            }

            amend.fixPaste(cell.firstChild, cell.lastChild, amendUser.getCurUser());
          } else {
            cell.innerHTML = pasteCell.fake ? '' : pasteCell.cell.innerHTML;
          }
        }
      });
      //粘贴后，需要修订 range
      tableZone.setStart(zone.grid[zone.range.minY][zone.range.minX].cell).setEnd(zone.grid[maxRow][maxCol].cell);
    }
  };

  this.paste = function (html, txt) {
    // console.log('-------------- htmlSrc -----------------');
    // console.log(html);

    // let debugTimerId = 'PasteUtils';
    // window.wizDebugTimer.start(debugTimerId);

    html = clearClipHtml(html);
    // window.wizDebugTimer.add(debugTimerId, 'clearClipHtml');

    html = utils.replaceSpecialChar(html);
    // window.wizDebugTimer.add(debugTimerId, 'replaceSpecialChar html');

    txt = utils.replaceSpecialChar(txt);
    // window.wizDebugTimer.add(debugTimerId, 'replaceSpecialChar txt');

    // console.log('--------------   html   -----------------');
    // console.log(html);
    // console.log('--------------   txt   -----------------');
    // console.log(txt);

    var range = rangeUtils.getRange(),
        zone = tableZone.getZone();

    if (!range && !zone.table && !zone.range || !html && !txt) {
      return;
    }

    if (range) {
      var cmContainer = codeUtils && codeUtils.getContainerFromChild(range.startContainer);
      if (cmContainer) {
        // CodeMirror 内 粘贴操作只插入 txt
        codeUtils.insertCodeSrc(cmContainer, txt);
        return;
      }
    }

    historyUtils.saveSnap(false);

    // window.wizDebugTimer.add(debugTimerId, 'ready ...');

    if (!zone.table && !zone.range) {
      // 普通粘贴操作
      // if (!html) {
      //     // WizEditor 只干扰 html 粘贴， 纯文本使用浏览器默认功能
      //     return;
      // }
      // let time1 = new Date().valueOf();
      pasteWithStandard(html, txt);
      // let time2 = new Date().valueOf();
      // console.log(time2 - time1);
    } else {
      // 表格内粘贴
      // 表格内粘贴纯文本必须干预，否则会出现表格嵌套的情况
      pasteWithTable(html, txt);
    }
    // window.wizDebugTimer.add(debugTimerId, 'pasteWithStandard');

    domUtils.fixOrderList();
    // window.wizDebugTimer.add(debugTimerId, 'fixOrderList');

    var fixCodeInPasteArea = function fixCodeInPasteArea() {
      if (codeUtils) {
        rangeUtils.caretBackup();
        codeUtils.pastePatch.fix();
        rangeUtils.caretRestore();
      }
    };
    if (!codeCore.hasLoaded) {
      codeCore.on({}, fixCodeInPasteArea);
    } else {
      var codeList = codeUtils && codeUtils.oldPatch.fixOldCode();
      for (var i = 0; i < codeList.length; i++) {
        var codeContainer = codeList[i];
        codeUtils.fixCodeContainer({ container: codeContainer });
      }
      fixCodeInPasteArea();
    }

    // window.wizDebugTimer.add(debugTimerId, 'fixCode');
    // window.wizDebugTimer.end(debugTimerId);
  };
  /**
   * 专门针对 IOS 的粘贴 操作 补丁
   */
  this.pasteForIOS = function (e) {
    if (e) {
      utils.stopEvent(e);
    }
    var sel = rangeUtils.getSelection();

    //必须让 光标 消失然后再重新设置， 否则会导致 IOS 上一直显示 粘贴的 tooltip
    rangeUtils.caretBackup();
    sel.removeAllRanges();
    setTimeout(function () {
      rangeUtils.caretRestore();
      if (e) {
        env.client.sendCmdToWizClient(CONST.CLIENT_EVENT.WizEditorPaste);
      }
    }, 0);
  };
  this.pasteFromClient = function (html, txt) {
    _this.paste(html, txt);
  };
  this.pasteFromClipBoard = function (e, callback) {
    // console.log('pasteFromClipBoard');
    // console.log(e);

    // CodeMirror 内 粘贴操作全部忽略
    if (codeUtils && codeUtils.getContainerFromChild(e.target)) {
      callback(false);
      return;
    }

    // IOS 客户端自己处理粘贴事件
    if (env.client.type.isIOS) {
      _this.pasteForIOS(e);
      callback(false);
      return;
    }

    var _callback = function _callback(clipboard) {
      if (clipboard.files && env.options.editor.callback.onPasteFile) {
        env.options.editor.callback.onPasteFile(clipboard.files);
        utils.stopEvent(e);
        callback(true);
        return;
      }
      // console.log('files:');
      // console.log(clipboard.files);
      // console.log(clipboard.html);
      // console.log(clipboard.text);

      if (clipboard.html || clipboard.text) {
        _this.paste(clipboard.html, clipboard.text);
        utils.stopEvent(e);
        callback(true);
        return;
      }

      // Mac 客户端自己处理 粘贴图片 or 文件
      if (env.client.type.isMac && env.win.WizQtEditor) {
        // console.log('env.win.WizQtEditor.doPaste()');
        env.win.WizQtEditor.doPaste();
      }
      callback(false);
    };

    clipboardUtils.getData(e, _callback);
  };
};
module.exports = PasteUtils;

},{"../config/const":388,"../libs/utils":400,"../libs/xssUtils":401}],351:[function(require,module,exports){
'use strict';

/**
 * 范围操作的基本方法集合
 */
var CONST = require('../config/const');
var utils = require('../libs/utils');

//通用方法集合
var RangeUtils = function RangeUtils() {
  var _this = this;

  var core = null;
  var env = null;
  var codeUtils = null;
  var domUtils = null;
  var wizStyle = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
    codeUtils = core.require.codeUtils;
    wizStyle = core.require.wizStyle;
  };

  // var lastOrientation = -1;
  var fixScrollTimer = void 0;
  var rangeBackup = void 0;

  /**
   * 备份光标
   */
  this.caretBackup = function () {
    var range = _this.getRange();
    if (!range) {
      if (rangeBackup) {
        return true;
      }

      domUtils.focus();
      range = _this.getRange();
      if (!range) {
        return false;
      }
    }

    range = _this.getRange();
    rangeBackup = range ? {
      startContainer: range.startContainer,
      startOffset: range.startOffset,
      endContainer: range.endContainer,
      endOffset: range.endOffset
    } : null;
    return true;
    //rangeBackup.setEnd(rangeBackup.startContainer, rangeBackup.startOffset);
  };

  /**
   * 设置 光标到可视范围内（移动滚动条）
   */
  this.scrollTimer = null;
  this.clearScrollTimer = function () {
    if (_this.scrollTimer) {
      clearTimeout(_this.scrollTimer);
    }
    _this.scrollTimer = null;
  };
  this.caretFocus = function () {
    //getClientRects 方法 在 ios 的 safari 上 还有问题
    var range = _this.getRange(),
        rectList = range ? range.getClientRects() : null,
        rect = rectList && rectList.length > 0 ? rectList[0] : null,
        cH = env.doc.documentElement.clientHeight,
        cW = env.doc.documentElement.clientWidth;

    if (rectList && rectList.length === 0) {
      var target = range.startContainer;
      if (target.nodeType === 3) {
        target = target.parentNode;
      } else if (target.nodeType === 1 && target.childNodes.length > 0) {
        if (range.startOffset < target.childNodes.length) {
          target = target.childNodes[range.startOffset];
        } else {
          target = target.childNodes[target.childNodes.length - 1];
        }
        if (target.nodeType === 3) {
          target = range.startContainer;
        }
      }
      if (target) {
        rect = target.getBoundingClientRect();
      }
    }

    var scroll = domUtils.getPageScroll();
    // let bodyMarginBottom = parseInt(domUtils.getComputedStyle(env.body, 'margin-bottom'), 10) || 0;
    // let bodyPaddingBottom = parseInt(domUtils.getComputedStyle(env.body, 'padding-bottom'), 10) || 0;
    // let lineHeight = bodyMarginBottom + bodyPaddingBottom + 20;

    // pc 客户端 webview 编辑最后一行时，会自动将滚动条调整到 （最下位置 - 单行高度）的位置，
    // 从而导致使用微软输入法输入最底部的空行时，容易出现反复跳动
    var defaultLineHeight = parseInt(domUtils.getComputedStyle(env.doc.body, 'line-height'), 10) || 27;
    var lineHeight = defaultLineHeight + 8;
    var bodyBottom = 0;
    if (rect && rect.top < 0) {
      _this.clearScrollTimer();
      domUtils.setPageScrollTopAni(scroll.top + rect.top - 30);
    } else if (!env.isWizTemplate && rect && rect.top + rect.height > cH - lineHeight * 3) {
      _this.clearScrollTimer();
      // 需要向底部滚动时才设置 body 的 margin-bottom，可以有效避免 空文档时 出现滚动条
      bodyBottom = lineHeight * 3;
      var bottomStyle = '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' {margin-bottom: ' + bodyBottom + 'px;}';
      wizStyle.insertCustomStyle(CONST.ID.BODY_TMP_BOTTOM_STYLE, bottomStyle, true);
      _this.scrollTimer = setTimeout(function () {
        // console.log(scroll.top +' + '+ (rect.top + rect.height - cH + bodyBottom - lineHeight) + '=' + (scroll.top + (rect.top + rect.height - cH + bodyBottom - lineHeight)));
        domUtils.setPageScrollTopAni(scroll.top + (rect.top + rect.height - cH + bodyBottom));
      }, 200);
      // console.log('bodyBottom: ' + bodyBottom);
    }
    // 屏蔽 自动删除 bottom 临时样式的功能，因为会导致跳动
    // if (!bodyBottom && !env.compositionStart) {
    // 正在中文录入时，可能会导致计算错误，所以不删除 margin-bottom
    // wizStyle.removeStyleById(CONST.ID.BODY_TMP_BOTTOM_STYLE);
    // }

    if (rect && rect.left < 0) {
      domUtils.setPageScrollLeft(scroll.left + rect.left);
    } else if (rect && rect.left + rect.width > cW) {
      domUtils.setPageScrollLeft(scroll.left + (rect.left + rect.width - cW));
    }
  };

  /**
   * 恢复光标位置
   */
  this.caretRestore = function () {
    if (!rangeBackup) {
      return false;
    }
    var sel = _this.getSelection();
    if (sel.rangeCount === 0) {
      domUtils.focus();
    }
    _this.setRange(rangeBackup.startContainer, rangeBackup.startOffset, rangeBackup.endContainer, rangeBackup.endOffset);
    // sel.removeAllRanges();
    // sel.addRange(rangeBackup);
    rangeBackup = null;
    return true;
  };

  /**
   * 清除 光标位置的 空字符
   */
  this.clearFillCharByCollapsed = function () {
    var range = _this.getRange(),
        txtNode = void 0,
        txtPre = void 0,
        txtNext = void 0;
    if (range && range.collapsed && range.startContainer.nodeType === 3) {
      txtNode = range.startContainer;
      var txt = txtNode.nodeValue;
      // 不能没有任何判断就直接处理，否则每次 keyDown 都重新设置Range， 会导致 execCommand 指令异常
      // 如果 txt 只有 FILL_CHAR，则不能清除，否则会影响 光标位置
      if (!utils.isEmpty(txt) && txt.indexOf(CONST.FILL_CHAR) > -1) {
        txtPre = txt.substr(0, range.startOffset);
        txtNext = txt.substr(range.startOffset);
        txtPre = txtPre.replace(CONST.FILL_CHAR_REG, '');
        txtNext = txtNext.replace(CONST.FILL_CHAR_REG, '');
        txtNode.nodeValue = txtPre + txtNext;
        _this.setRange(txtNode, txtPre.length);
      }
    }
  };

  /**
   * 获取 RangeDomList 后修正 Range
   */
  this.fixRange = function (rangeResult) {
    //reset the selection's range
    //自闭合标签 需要特殊处理
    var isStartBak = !rangeResult.startDom.parentNode,
        isEndBak = !rangeResult.endDom.parentNode,
        isSelfCloseEnd = domUtils.isSelfClosingTag(rangeResult.endDom);
    //修正 Bak 的Dom
    if (isStartBak && domUtils.isSelfClosingTag(rangeResult.startDomBak)) {
      rangeResult.startDomBak = domUtils.getNextNode(rangeResult.startDomBak, false, rangeResult.endDomBak);
      rangeResult.startOffsetBak = 0;
    }
    _this.setRange(isStartBak ? rangeResult.startDomBak : rangeResult.startDom, isStartBak ? rangeResult.startOffsetBak : rangeResult.startOffset, isEndBak || isSelfCloseEnd ? rangeResult.endDomBak : rangeResult.endDom, isEndBak || isSelfCloseEnd ? rangeResult.endOffsetBak : rangeResult.endOffset);
  };

  /**
   * 修正滚动条，让光标进入可视区（避免 js 移动光标后，光标不在可视区）
   */
  this.fixScroll = function () {
    if (fixScrollTimer) {
      clearTimeout(fixScrollTimer);
    }
    var _fixScroll = function _fixScroll() {
      var rect = void 0,
          winSize = void 0,
          scrollTop = void 0,
          scrollLeft = void 0;
      var range = _this.getRange();
      // range 不存在 或 在 移动设备上有选择区域时（肯定在可视区），不进行修正
      if (!range || !range.collapsed && (env.client.type.isPhone || env.client.type.isPad)) {
        return;
      }

      // Iphone 键盘高度会变化（普通键盘 & 九宫格键盘）会导致光标计算错误，
      // 已经提供新方法 setWebViewSizeForFixScroll 所以此部分代码暂时屏蔽
      // var callbackId;
      // // IOS 获取的 数据不正常，需要从客户端获取 可视区高度范围进行修正
      // if (env.client.type.isIOS &&
      //     (!env.options.ios.webViewHeight || lastOrientation != window.orientation)) {
      //     callbackId = '_' + CONST.CLIENT_EVENT.WizGetWebViewSize + new Date().valueOf();
      //     env.win[callbackId] = (data) => {
      //         data = JSON.parse(base64.decode(data));
      //         env.options.ios.webViewHeight = data.height;
      //         env.options.ios.toolbarHeight = data.toolbarHeight;
      //         lastOrientation = window.orientation;
      //         delete env.win[callbackId];
      //         this.fixScroll();
      //     };
      //     env.client.sendCmdToWizClient(CONST.CLIENT_EVENT.WizGetWebViewSize, {
      //         callback: callbackId
      //     });
      //     return;
      // }

      // IOS 替换内核后，不再从外部传入 webViewHeight / toolbarHeight
      // var webViewHeight = env.options.ios.webViewHeight,
      //   toolbarHeight = env.options.ios.toolbarHeight;
      // console.log('webViewHeight: ' + webViewHeight + ', toolbarHeight: ' + toolbarHeight);

      // 修改 range 后，一定要让光标移动到可视范围内
      rect = _this.getRangeClientRect();
      if (!rect) {
        return;
      }
      winSize = domUtils.getWindowSize();
      var webViewHeight = winSize.height,
          toolbarHeight = 0;

      if (env.client.type.isIOS) {
        // winSize.height = webViewHeight - toolbarHeight;
        webViewHeight = winSize.height;
      }

      // 避免出现的光标在屏幕最下方，不明显
      var BottomSpace = 25;
      var pageScroll = domUtils.getPageScroll();
      scrollTop = pageScroll.top;
      scrollLeft = pageScroll.left;
      // console.log(rect.top + '+' + rect.height + '>' + winSize.height);
      // alert(rect.top + '+' + rect.height + '>' + winSize.height);
      var targetTop = null,
          targetLeft = null;
      if (env.client.type.isIOS && rect.top + toolbarHeight < 0) {
        targetTop = scrollTop + rect.top + toolbarHeight - 30;
      } else if (env.client.type.isIOS && rect.top + rect.height > webViewHeight - toolbarHeight) {
        // alert(rect.top + '+' + rect.height + '+' + toolbarHeight + '+' + webViewHeight + '>' + (webViewHeight - toolbarHeight));
        targetTop = scrollTop + rect.top + rect.height + toolbarHeight - webViewHeight + BottomSpace;
      } else if (!env.client.type.isIOS && rect.top < 0) {
        targetTop = scrollTop + rect.top - 30;
      } else if (!env.client.type.isIOS && rect.top + rect.height > winSize.height) {
        targetTop = scrollTop + rect.top + rect.height - winSize.height + BottomSpace;
      }
      if (rect.left < scrollLeft) {
        targetLeft = scrollLeft + rect.left;
      } else if (rect.left + rect.width > winSize.width) {
        targetLeft = scrollLeft + rect.left + rect.width - winSize.width;
      }

      // 兼容 各种浏览器
      if (targetTop !== null) {
        domUtils.setPageScrollTopAni(targetTop);
      }
      if (targetLeft !== null) {
        domUtils.setPageScrollLeft(targetLeft);
      }
    };

    fixScrollTimer = setTimeout(_fixScroll, 30);
  };

  /**
   * 为 复制/剪切 操作，准备 fragment
   */
  this.getFragmentForCopy = function () {
    var range = _this.getRange(),
        fragment = null;
    //无光标时， 不操作任何内容
    if (!range || range.collapsed) {
      return fragment;
    }

    fragment = env.doc.createElement('div');
    fragment.appendChild(range.cloneContents());
    domUtils.fragmentFilterForCopy(fragment);
    domUtils.css(fragment, {
      position: 'absolute',
      top: '-99999px',
      left: '-99999px',
      overflow: 'hidden'
    });
    // fragment 必须要加入 body 内，否则有可能会导致 换行符丢失
    env.body.appendChild(fragment);
    return fragment;
  };

  /**
   * 获取 Range 对象
   */
  this.getRange = function () {
    var sel = _this.getSelection();
    try {
      // ie11 会出现 sel.rangeCount 报错的情况
      if (!sel || sel.rangeCount === 0) {
        return null;
      }
    } catch (e) {
      return null;
    }
    var range = sel.getRangeAt(0);
    var emptyDiv = void 0;
    // 避免 env.body 内是空的
    if (range.startContainer === env.body && range.startOffset === 0 && range.collapsed && (!env.body.firstChild || domUtils.checkInTmp(env.body.firstChild))) {
      emptyDiv = env.doc.createElement('div');
      emptyDiv.appendChild(env.doc.createElement('br'));
      env.body.insertBefore(emptyDiv, env.body.firstChild);
      _this.setRange(emptyDiv, 0);
    }

    var rangeDetail = _this.getRangeDetail(range.startContainer, range.startOffset);
    if (!domUtils.isInWizBody(rangeDetail.container)) {
      range = null;
    }
    return range;
  };

  /**
   * 获取当前光标所在位置的dom元素
   * isCollapse = true 时 获取光标后面的第一个dom，如果当前在 textNode 内， 则直接返回 textNode
   * isCollapse = false， isBackward = false 获取 光标区间第一个 dom
   * isCollapse = false， isBackward = true 获取 光标区间最后一个 dom
   */
  this.getRangeAnchor = function (isBackward) {
    var range = _this.getRange();
    if (!range) {
      return null;
    }
    var rangeContainer = isBackward ? range.startContainer : range.endContainer,
        rangeOffset = isBackward ? range.startOffset : range.endOffset;

    if (!range.collapsed && !isBackward) {
      if (rangeContainer.nodeType === 3 && rangeOffset > 0) {
        return rangeContainer;
      } else if (rangeContainer.nodeType === 3) {
        return domUtils.getPreviousNode(rangeContainer, false, null);
      }

      if (rangeOffset > 0) {
        return domUtils.getLastDeepChild(rangeContainer.childNodes[rangeOffset - 1]);
      } else {
        return domUtils.getPreviousNode(rangeContainer, false, null);
      }
    }

    if (rangeContainer.nodeType === 3 && rangeOffset < rangeContainer.nodeValue.length) {
      return rangeContainer;
    } else if (rangeContainer.nodeType === 3) {
      return domUtils.getNextNode(rangeContainer, false, null);
    }

    if (rangeContainer.childNodes.length === 0) {
      return rangeContainer;
    } else if (rangeOffset === rangeContainer.childNodes.length) {
      return domUtils.getNextNode(rangeContainer.childNodes[rangeOffset - 1], false, null);
    } else {
      return domUtils.getFirstDeepChild(rangeContainer.childNodes[rangeOffset]);
    }
  };

  /**
   * 获取 光标矩形区域 & 位置
   */
  this.getRangeClientRect = function () {
    var range = _this.getRange();
    if (!range) {
      return null;
    }

    var rects = void 0,
        rect = range.getBoundingClientRect(),
        start = void 0;
    if (rect.width === 0 && rect.height === 0) {
      // mac and ios safari 使用 range.getBoundingClientRect 经常会得到 0
      rects = _this.getRange().getClientRects();
      if (rects.length > 0) {
        //修正 光标进入可视区 对于移动设备 只考虑光标折叠的情况
        rect = rects[0];
      }
    }

    // 光标在 input、image 等 DOM 后面时，得到的数据全部为 0 必须修正
    if (rect.width === 0 && rect.height === 0) {
      var startData = _this.getRangeDetail(range.startContainer, range.startOffset);
      start = startData.container;
      if (start.getBoundingClientRect) {
        rect = start.getBoundingClientRect();
        rect = {
          bottom: rect.bottom,
          height: rect.height,
          left: rect.left + rect.width,
          right: rect.right,
          top: rect.top,
          width: 0
        };
      }
    }
    return rect;
  };

  /**
   * 根据 startContainer 和 startOffset 获取最终 Dom 元素，
   * 避免 startContainer 为 Element 时，得到的 start 不准确
   */
  this.getRangeDetail = function (startContainer, startOffset) {
    // 必须要保留 isEnd 标志，不能强行设定 nextNode 当作 container
    // 不同的需求会导致有时候需要 光标当前位置的 dom，有时候需要 next dom
    var isEnd = false;
    if (startOffset > 0 && startOffset === domUtils.getEndOffset(startContainer)) {
      // 在 结尾
      if (startContainer.nodeType === 1) {
        startContainer = domUtils.getLastDeepChild(startContainer.childNodes[startOffset - 1]);
        startOffset = domUtils.getEndOffset(startContainer);
      }
      isEnd = true;
    } else if (startContainer.nodeType === 1) {
      if (startContainer.childNodes.length === 0) {
        // br
      } else if (startOffset < startContainer.childNodes.length) {
        startContainer = startContainer.childNodes[startOffset];
        startOffset = 0;
      }
    }

    return {
      container: startContainer,
      offset: startOffset,
      isEnd: isEnd
    };
  };

  /**
   * 根据 获取 光标选中范围内的 dom 集合
   * options {noSplit: Boolean}
   */
  this.getRangeDomList = function (options) {
    var range = _this.getRange();
    if (!range) {
      return null;
    }
    var startDom = range.startContainer,
        startOffset = range.startOffset,
        endDom = range.endContainer,
        endOffset = range.endOffset;
    return domUtils.getListA2B({
      startDom: startDom,
      startOffset: startOffset,
      endDom: endDom,
      endOffset: endOffset,
      noSplit: !!options.noSplit
    });
  };

  /**
   * 获取 光标范围内 Dom 共同的父节点
   */
  this.getRangeParentRoot = function () {
    var range = _this.getRange(),
        startDom = void 0,
        endDom = void 0;
    if (!range) {
      return null;
    }
    startDom = range.startContainer;
    endDom = range.endContainer;
    return domUtils.getParentRoot([startDom, endDom]);
  };

  this.getSelection = function () {
    return env.doc.getSelection();
  };

  /**
   * chrome
   * range.insertNode 会导致将 dom 插入到 <br>内，太奇葩了
   */
  this.insertNode = function (dom) {
    var range = _this.getRange();
    if (!range) {
      return null;
    }
    if (range.collapsed && domUtils.isTag(range.startContainer, 'br')) {
      var p = range.startContainer.parentNode;
      var index = domUtils.getIndex(range.startContainer);
      _this.setRange(p, index, p, index + 1);
      range = _this.getRange();
    }
    range.insertNode(dom);
  };

  /**
   * 检验 dom 是否为 selection 的 边缘
   */
  this.isRangeEdge = function (dom) {
    var result = {
      isStart: false,
      isEnd: false
    };

    var range = _this.getRange();
    if (!range) {
      return;
    }
    result.isCollapsed = range.collapsed;
    result.startDom = range.startContainer;
    result.startOffset = range.startOffset;
    result.endDom = range.endContainer;
    result.endOffset = range.endOffset;

    var tmpStartDom = void 0,
        tmpEndDom = void 0;
    if (result.startDom.nodeType === 1 && result.startOffset < result.startDom.childNodes.length) {
      tmpStartDom = domUtils.getFirstDeepChild(result.startDom.childNodes[result.startOffset]);
    } else if (result.startDom.nodeType === 1) {
      tmpStartDom = domUtils.getNextNode(result.startDom.childNodes[result.startOffset - 1], false, null);
    }
    if (result.endDom.nodeType === 1 && result.endOffset > 0) {
      tmpEndDom = domUtils.getLastDeepChild(result.endDom.childNodes[result.endOffset - 1]);
    } else if (result.endDom.nodeType === 1) {
      tmpEndDom = domUtils.getPreviousNode(result.endDom, false, null);
    }
    result.isStart = result.startDom === dom || result.startDom === tmpStartDom;

    result.isEnd = result.endDom === dom || result.endDom === tmpEndDom;

    return result;
  };

  /**
   * 在 光标（isCollapse=true）所在位置创建 指定样式的 span
   * make new span when selection's isCollapsed == true
   */
  this.modifyCaretStyle = function (style, attr) {
    var sel = _this.getSelection();
    var focusNode = sel.focusNode;
    var range = void 0,
        key = void 0,
        value = void 0,
        hasSameStyle = true,
        n = void 0;

    //get the focus's element.
    if (focusNode.nodeType === 3) {
      focusNode = focusNode.parentNode;
    }
    //check if the current dom is same as the style which is needed.
    for (key in style) {
      if (style.hasOwnProperty(key) && typeof key === 'string') {
        value = style[key];
        if (focusNode.style[key] !== value) {
          hasSameStyle = false;
        }
      }
    }
    if (hasSameStyle) {
      return;
    }

    //if current dom is empty, so don't create span.
    if (domUtils.isTag(focusNode, 'span') && domUtils.isEmptyDom(focusNode)) {
      domUtils.modifyStyle(focusNode, style, attr);
      n = focusNode;
    } else {
      range = sel.getRangeAt(0);
      range.deleteContents();
      n = domUtils.createSpan();
      n.innerHTML = CONST.FILL_CHAR;
      range.insertNode(n);
      domUtils.modifyStyle(n, style, attr);
    }

    //put the cursor's position to the target dom
    //range = env.doc.createRange();
    //range.setStart(n.childNodes[0], 1);
    //range.setEnd(n.childNodes[0], 1);

    //clear redundant span & TextNode
    //var p = focusNode;
    var p = focusNode.parentNode ? focusNode.parentNode : focusNode;
    domUtils.clearChildSpan(p, [n]);

    //reset the selection's range
    _this.setRange(n.childNodes[0], 1, n.childNodes[0], 1);
    //sel.removeAllRanges();
    //sel.addRange(range);
  };

  /**
   * 在 光标（isCollapse=false）选择范围内修改所有 dom内容，设置为指定样式
   * modify the style when selection's isCollapsed == false
   */
  this.modifyRangeStyle = function (style, attr) {
    var rangeResult = void 0,
        rangeList = void 0,
        rangeLength = void 0;
    //get the RangeList
    rangeResult = _this.getRangeDomList({
      noSplit: false
    });
    if (!rangeResult) {
      return;
    }
    // 不能修改 CodeMirror 内的样式，否则会导致代码异常
    rangeList = [];
    for (var _iterator = rangeResult.list, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var dom = _ref;

      var code = codeUtils && codeUtils.getContainerFromChild(dom);
      if (!code) {
        rangeList.push(dom);
      }
    }
    rangeLength = rangeList.length;
    if (rangeLength === 0) {
      return;
    }

    //modify style
    domUtils.modifyNodesStyleAndClear(rangeList, style, attr, [rangeResult.startDomBak, rangeResult.endDomBak]);

    _this.fixRange(rangeResult);
  };

  /**
   * 修改 光标范围内的 Dom 样式 & 属性
   */
  this.modifySelectionDom = function (style, attr) {
    var range = _this.getRange();
    if (!range) {
      return false;
    }
    if (range.collapsed) {
      _this.modifyCaretStyle(style, attr);
    } else {
      _this.modifyRangeStyle(style, attr);
    }
    return true;
  };

  /**
   * 根据 x，y 坐标移动光标到指定位置
   */
  this.moveToPoint = function (x, y) {
    var range = void 0,
        textNode = void 0,
        offset = void 0;
    if (env.doc.caretPositionFromPoint) {
      range = env.doc.caretPositionFromPoint(x, y);
      textNode = range.offsetNode;
      offset = range.offset;
    } else if (env.doc.caretRangeFromPoint) {
      range = env.doc.caretRangeFromPoint(x, y);
      textNode = range.startContainer;
      offset = range.startOffset;
    }
    _this.setRange(textNode, offset);
  };

  // /**
  //  * 选中指定的 dom 元素
  //  */
  // this.selectElementContents = (el) => {
  //   let range = env.doc.createRange();
  //   range.selectNodeContents(el);
  //   let sel = env.doc.getSelection();
  //   sel.removeAllRanges();
  //   sel.addRange(range);
  // };

  /**
   * 在光标位置选中单个字符，遇到 Fill-Char 特殊字符需要一直选取
   */
  this.selectCharIncludeFillChar = function (isBackward) {
    var sel = _this.getSelection(),
        range = sel.getRangeAt(0),
        direction = isBackward ? 'backward' : 'forward';

    if (!sel.modify) {
      return;
    }

    var tmpCurDom = void 0,
        tmpOffset = void 0,
        tmpNextDom = void 0,
        s = void 0;
    if (range.startContainer.nodeType === 1) {
      tmpCurDom = _this.getRangeAnchor(false);
      //range.startContainer !== tmpCurDom 的时候， 往往不是在空行的最前面，而是在 前一个 dom 的最后面
      if (range.startContainer === tmpCurDom && domUtils.isTag(tmpCurDom, 'br') && domUtils.isEmptyDom(tmpCurDom.parentNode)) {
        if (tmpCurDom.parentNode.nextSibling) {
          _this.setRange(tmpCurDom.parentNode, 0, tmpCurDom.parentNode.nextSibling, 0);
        } else {
          sel.modify('move', 'forward', 'character');
          sel.modify('extend', 'backward', 'character');
          if (tmpCurDom.nextSibling) {
            sel.modify('extend', 'backward', 'character');
          }
        }
        return;
      } else if (domUtils.isTag(tmpCurDom, 'br')) {
        sel.modify('extend', direction, 'character');
      }
    }

    sel.modify('extend', direction, 'character');
    range = sel.getRangeAt(0);
    s = range.toString();
    tmpCurDom = _this.getRangeAnchor(isBackward);

    if (!tmpCurDom) {
      //当没有文字，且只剩下空标签 和 自闭合标签时，有时候会不存在 tmpCurDom
      return;
    }
    if (isBackward && tmpCurDom === range.startContainer) {
      tmpOffset = range.startOffset;
    } else if (!isBackward && tmpCurDom === range.endContainer) {
      tmpOffset = range.endOffset;
    } else {
      //只要 tmpCurDom 不是range 的原始 dom ，就直接设置 tmpOffset 为 -1
      tmpOffset = -1;
    }

    //如果光标在某个 textNode 中间， 则前后都是当前这个 textNode
    if (tmpCurDom.nodeType === 3 && tmpOffset > 0 && tmpOffset < tmpCurDom.nodeValue.length) {
      tmpNextDom = tmpCurDom;
    } else {
      tmpNextDom = isBackward ? domUtils.getPreviousNode(tmpCurDom, false, null) : domUtils.getNextNode(tmpCurDom, false, null);
    }

    if (s.length === 0) {
      //如果当前未选中 自闭合标签（br）且下一个字符是 自闭合标签 则 扩展选中区域
      if (tmpCurDom && !domUtils.isSelfClosingTag(tmpCurDom) && tmpNextDom && (tmpNextDom.nodeType !== 1 || tmpNextDom.nodeType === 1 && domUtils.isSelfClosingTag(tmpNextDom))) {
        sel.modify('extend', direction, 'character');
      }
    } else if (s.indexOf(CONST.FILL_CHAR) > -1 && s.replace(CONST.FILL_CHAR_REG, '') === '') {
      //如果当前选中了 文本 但文本未占位字符，则扩展选中区域
      sel.modify('extend', direction, 'character');
    }
  };

  /**
   * 根据 起始 Dom 位置设定 光标选择范围
   */
  this.setRange = function (start, startOffset, end, endOffset) {
    if (!start && !end) {
      return;
    }
    var maxStart = domUtils.getEndOffset(start),
        maxEnd = domUtils.getEndOffset(end);
    if (startOffset < 0) {
      startOffset = 0;
    } else if (startOffset > maxStart) {
      startOffset = maxStart;
    }
    if (endOffset < 0) {
      endOffset = domUtils.getEndOffset(end);
    } else if (endOffset > maxEnd) {
      endOffset = maxEnd;
    }
    var sel = _this.getSelection();
    if (!start) {
      start = env.body;
      startOffset = 0;
    }
    var range = void 0;
    if (sel.rangeCount === 0) {
      range = env.doc.createRange();
      range.selectNode(start);
      try {
        sel.addRange(range);
      } catch (e) {
        // console.log(start);
        console.error(e);
        return;
      }
    }
    sel.collapse(start, startOffset);
    if (end && (end !== start || endOffset !== startOffset)) {
      sel.extend(end, endOffset);
    }
  };

  /**
   * 专门用于针对 PC 客户端 Chrome 处理 range.insertNode 光标异常
   */
  this.setRangeToEnd = function (dom) {
    var target = dom;
    var offset = domUtils.getEndOffset(dom);

    if (domUtils.isSelfClosingTag(target)) {
      target = target.parentNode;
      offset = domUtils.getIndex(dom) + 1;
    }
    _this.setRange(target, offset);
  };
};

module.exports = RangeUtils;

},{"../config/const":388,"../libs/utils":400}],352:[function(require,module,exports){
'use strict';

/**
 * 下拉框插件
 */
var CONST = require('../config/const');
var _class = {
  active: 'active',
  selected: 'selected'
};

var SelectPlugin = function SelectPlugin() {
  var core = null;
  var env = null;
  var domUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
  };

  var _event = {
    bind: function bind() {
      // 选项不采用 click 方式，主要为了避免 与 CodeMirror 抢焦点
      // 组件中不进行 阻止默认事件 的操作（具体实现中根据情况进行控制，例如：codeCore 中的 onMouseDown）
      _event.unbind();
      if (env.supportTouchEvent) {
        env.event.add(CONST.EVENT.ON_TOUCH_START, _event.handler.onMouseDown);
      } else {
        env.event.add(CONST.EVENT.ON_MOUSE_DOWN, _event.handler.onMouseDown);
      }
    },
    unbind: function unbind() {
      env.event.remove(CONST.EVENT.ON_TOUCH_START, _event.handler.onMouseDown);
      env.event.remove(CONST.EVENT.ON_MOUSE_DOWN, _event.handler.onMouseDown);
    },
    handler: {
      onMouseDown: function onMouseDown(e) {
        var target = e.target;
        var header = selectUtils.getHeaderFromDom(target);
        if (header) {
          selectUtils.showOptions(header);
          return;
        }
        var option = selectUtils.getOptionFromDom(target);
        if (option) {
          selectUtils.selectOption(option);
        }
        var container = selectUtils.getContainerFromDom(target);
        if (!container) {
          selectUtils.hideOptions();
        }
      }
    }
  };

  var selectUtils = {
    getContainerFromDom: function getContainerFromDom(dom) {
      return domUtils.getParentByClass(dom, CONST.CLASS.SELECT_PLUGIN_CONTAINER, true);
    },
    getHeaderFromDom: function getHeaderFromDom(dom) {
      return domUtils.getParentByClass(dom, CONST.CLASS.SELECT_PLUGIN_HEADER, true);
    },
    getHeaderText: function getHeaderText(container) {
      return container.querySelector('.' + CONST.CLASS.SELECT_PLUGIN_HEADER_TEXT);
    },
    getOptionFromDom: function getOptionFromDom(dom) {
      return domUtils.getParentByClass(dom, CONST.CLASS.SELECT_PLUGIN_OPTIONS_ITEM, true);
    },
    hideOptions: function hideOptions(container) {
      var containerList = void 0;
      if (!container) {
        containerList = env.body.querySelectorAll('.' + CONST.CLASS.SELECT_PLUGIN_CONTAINER + '.' + _class.active);
      } else {
        containerList = [container];
      }
      for (var i = containerList.length - 1; i >= 0; i--) {
        domUtils.removeClass(containerList[i], _class.active);
        env.event.call(CONST.EVENT.ON_SELECT_PLUGIN_HIDE, containerList[i]);
      }
    },
    selectOption: function selectOption(option) {
      var container = selectUtils.getContainerFromDom(option);
      if (!container || option.disabled) {
        return;
      }
      if (option.callbackOnClick && !option.callbackOnClick()) {
        // 允许自定义的 Options 控制 onClick 后的状态
        return;
      }
      var isMore = container.selectType === CONST.SELECT_PLUGIN.TYPE.More;

      if (!isMore) {
        var selectedItem = container.querySelector('.' + CONST.CLASS.SELECT_PLUGIN_OPTIONS_ITEM + '.' + _class.selected);
        if (selectedItem === option) {
          return;
        }
        domUtils.removeClass(selectedItem, _class.selected);
        domUtils.addClass(option, _class.selected);
        var headerText = selectUtils.getHeaderText(container);
        if (headerText) {
          headerText.textContent = option.textContent;
        }
      }
      container.value = option.getAttribute('value');

      selectUtils.hideOptions(container);

      env.event.call(CONST.EVENT.ON_SELECT_PLUGIN_CHANGE, container);
    },
    showOptions: function showOptions(header) {
      var container = selectUtils.getContainerFromDom(header);
      if (domUtils.hasClass(container, _class.active)) {
        selectUtils.hideOptions(container);
        return;
      }
      selectUtils.hideOptions();
      domUtils.addClass(container, _class.active);

      var selectedTarget = container.querySelector('.' + CONST.CLASS.SELECT_PLUGIN_OPTIONS_ITEM + '.' + _class.selected);
      if (selectedTarget) {
        if (selectedTarget.scrollIntoViewIfNeeded) {
          selectedTarget.scrollIntoViewIfNeeded();
        } else {
          selectedTarget.scrollIntoView(true);
        }
      }
      env.event.call(CONST.EVENT.ON_SELECT_PLUGIN_SHOW, container);
    }
  };

  this.on = function () {
    _event.bind();
  };

  this.off = function () {
    _event.unbind();
  };

  this.create = function (options) {
    var optionsData = options.optionsData;
    var className = options.className;
    var defaultValue = options.defaultValue;
    var selectType = options.type;
    var isMore = selectType === CONST.SELECT_PLUGIN.TYPE.More;

    var container = env.doc.createElement('div');
    var header = env.doc.createElement('div');
    var headerText = isMore ? null : env.doc.createElement('span');
    var headerIcon = env.doc.createElement('i');
    var optionsContainer = env.doc.createElement('ul');

    if (headerText) {
      header.appendChild(headerText);
    }
    header.appendChild(headerIcon);
    container.appendChild(header);
    container.appendChild(optionsContainer);
    container.selectType = selectType;
    container.hideOptions = function () {
      selectUtils.hideOptions(container);
    };

    for (var i = 0, j = optionsData.length; i < j; i++) {
      var data = optionsData[i];
      var obj = data.obj;
      var text = data.text;
      var value = data.value;
      var mockOption = env.doc.createElement('li');
      if (obj) {
        mockOption.appendChild(obj);
      } else {
        mockOption.textContent = text;
      }
      mockOption.callbackOnClick = data.onClick;
      domUtils.attr(mockOption, { 'value': value, 'data-index': i });
      if (value === defaultValue) {
        if (headerText) {
          headerText.textContent = text;
        }
        container.value = value;
        domUtils.addClass(mockOption, _class.selected);
      }
      domUtils.addClass(mockOption, CONST.CLASS.SELECT_PLUGIN_OPTIONS_ITEM);
      if (data.disabled) {
        domUtils.addClass(mockOption, 'disabled');
        mockOption.disabled = true;
      }
      if (data.style) {
        domUtils.css(mockOption, data.style);
      }
      optionsContainer.appendChild(mockOption);
    }

    var headerIconClass = isMore ? 'icon-more editor-icon' : 'icon-down_arrow editor-icon';
    domUtils.addClass(headerIcon, headerIconClass);
    if (headerText) {
      domUtils.addClass(headerText, CONST.CLASS.SELECT_PLUGIN_HEADER_TEXT);
    }
    domUtils.addClass(header, CONST.CLASS.SELECT_PLUGIN_HEADER);
    domUtils.addClass(optionsContainer, CONST.CLASS.SELECT_PLUGIN_OPTIONS);
    domUtils.addClass(container, CONST.CLASS.SELECT_PLUGIN_CONTAINER + ' ' + className + ' ' + selectType);
    domUtils.attr(container, {
      'onselectstart': 'return false;'
    });
    return container;
  };

  this.destory = function () {};
};

module.exports = SelectPlugin;

},{"../config/const":388}],353:[function(require,module,exports){
'use strict';

/**
 * tab 键操作处理
 */
var CONST = require('../config/const');
var utils = require('../libs/utils');

var TabKey = function TabKey() {
  var core = null;
  var env = null;
  var commandExtend = null;
  var domUtils = null;
  var historyUtils = null;
  var rangeUtils = null;
  var tableZone = null;
  var todoUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    commandExtend = core.require.commandExtend;
    domUtils = core.require.domUtils;
    historyUtils = core.require.historyUtils;
    rangeUtils = core.require.rangeUtils;
    tableZone = core.require.tableZone;
    todoUtils = core.require.todoUtils;
  };

  var tabHtml = '&nbsp; &nbsp;&nbsp;';
  var processTab = function processTab(prev) {
    var range = rangeUtils.getRange(),
        zone = tableZone.getZone();
    if (!range || zone.range) {
      return false;
    }

    if (prev) {
      historyUtils.saveSnap(false);
      // mac 客户端 必须setTimeout 否则会导致崩溃
      if (env.client.type.isMac) {
        setTimeout(function () {
          commandExtend.execCommand("outdent");
        }, 10);
      } else {
        commandExtend.execCommand("outdent");
      }
      return true;
    }

    var dom = range.startContainer,
        startOffset = range.startOffset,
        startDetail = rangeUtils.getRangeDetail(dom, startOffset),
        isListDom = domUtils.isTag(dom, ['ul', 'ol', 'li']),
        isTodoStart = todoUtils && todoUtils.isCaretAfterCheckbox(),
        parent = domUtils.getParentByTagName(dom, ['ul', 'ol', 'li'], false),
        isListStart = false;

    var tmp = startDetail.container;
    if (parent && startDetail.offset === 0) {
      while (tmp !== env.body) {
        if (!!tmp.previousSibling) {
          isListStart = false;
          break;
        } else {
          isListStart = true;
        }
        tmp = tmp.parentNode;
        if (tmp === parent) {
          break;
        }
      }
    }

    if (domUtils.isTag(dom, ['td', 'th'])) {
      return false;
    } else if (!range.collapsed || isTodoStart || isListStart || isListDom) {
      // 在 空列表、列表头部、todoList 头部 时， tab 键进行缩进操作
      historyUtils.saveSnap(false);
      if (env.client.type.isMac) {
        setTimeout(function () {
          commandExtend.execCommand("indent");
        }, 10);
      } else {
        commandExtend.execCommand("indent");
      }
      return true;
    } else if (dom.nodeType === 3 || domUtils.getParentByTagName(dom, ['a', 'b', 'body', 'div', 'font', 'html', 'i', 'p', 'span', 'strong', 'u'])) {
      historyUtils.saveSnap(false);
      commandExtend.execCommand("insertHTML", false, tabHtml);
      return true;
    }
    return false;
  };
  var _event = {
    bind: function bind() {
      _event.unbind();
      env.event.add(CONST.EVENT.ON_KEY_DOWN, _event.handler.onKeyDown);
    },
    unbind: function unbind() {
      env.event.remove(CONST.EVENT.ON_KEY_DOWN, _event.handler.onKeyDown);
    },
    handler: {
      onKeyDown: function onKeyDown(e) {
        var keyCode = e.keyCode || e.which;
        if (keyCode !== 9) {
          return;
        }

        if (processTab(e.shiftKey)) {
          utils.stopEvent(e);
        }
      }
    }
  };

  this.init = function (html) {
    tabHtml = html;
  };
  this.on = function () {
    _event.bind();
  };
  this.off = function () {
    _event.unbind();
  };
};

module.exports = TabKey;

},{"../config/const":388,"../libs/utils":400}],354:[function(require,module,exports){
'use strict';

/**
 * 默认的样式集合
 */
var CONST = require('../config/const');

var TmpEditorStyle = {
  iosPhone: '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' {' + 'overflow-y:scroll;' + '-webkit-overflow-scrolling: touch;' + '-webkit-tap-highlight-color: rgba(0, 0, 0, 0);' + '}' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + '[contenteditable=true], ' + '.' + CONST.CLASS.TEMPLATE_EDITABLE + '.need-editor-padding-bottom {' + 'padding-bottom: 44px !important;' + '}' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' td,' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' th {position:static;}' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' th:before,' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' td:before,' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' th:after,' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' td:after {display:none;}',
  iosPad: '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' {' + 'min-width: 90%;' + 'max-width: 100%;' + 'min-height: 100%;' + 'background: #ffffff;' + 'overflow-y:scroll;' + '-webkit-overflow-scrolling: touch;' + '-webkit-tap-highlight-color: rgba(0, 0, 0, 0);' + '}' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + '[contenteditable=true], ' + '.' + CONST.CLASS.TEMPLATE_EDITABLE + '.need-editor-padding-bottom {' + 'padding-bottom: 44px !important;' + '}' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' td,' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' th {position:static;}' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' th:before,' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' td:before,' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' th:after,' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' td:after {display:none;}',
  code: '.' + CONST.CLASS.WIZ_BODY + ' .' + CONST.CLASS.CODE_CONTAINER_PASTE + ' textarea {visibility: hidden;}',
  imageResize: '.wiz-img-resize-handle {position: absolute;z-index: 1000;border: 1px solid black;background-color: white;}' + '.wiz-img-resize-handle {width:5px;height:5px;margin:0 !important;}' + '.wiz-img-resize-handle.lt {cursor: nw-resize;}' + '.wiz-img-resize-handle.tm {cursor: n-resize;}' + '.wiz-img-resize-handle.rt {cursor: ne-resize;}' + '.wiz-img-resize-handle.lm {cursor: w-resize;}' + '.wiz-img-resize-handle.rm {cursor: e-resize;}' + '.wiz-img-resize-handle.lb {cursor: sw-resize;}' + '.wiz-img-resize-handle.bm {cursor: s-resize;}' + '.wiz-img-resize-handle.rb {cursor: se-resize;}',
  tableInMarkdown: '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' table tr {background-color:white;}' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' table tr:nth-child(2n) {background-color:#f8f8f8;}',
  table: '.' + CONST.CLASS.EDITING + ' .' + CONST.CLASS.TABLE_BODY + '.' + CONST.CLASS.TABLE_MOVING + ' *,' + ' .' + CONST.CLASS.EDITING + ' .' + CONST.CLASS.TABLE_BODY + '.' + CONST.CLASS.TABLE_MOVING + ' *:before,' + ' .' + CONST.CLASS.EDITING + ' .' + CONST.CLASS.TABLE_BODY + '.' + CONST.CLASS.TABLE_MOVING + ' *:after {cursor:default !important;}' + ' .' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' td,' + ' .' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' th {position:relative;}' + '#wiz-table-range-border {display: none;width: 0;height: 0;position: absolute;top: 0;left: 0; z-index:' + CONST.CSS.Z_INDEX.tableBorder + '}' + '#wiz-table-col-line, #wiz-table-row-line {display: none;background-color: #448aff;position: absolute;z-index:' + CONST.CSS.Z_INDEX.tableColRowLine + ';}' + '#wiz-table-col-line {width: 1px;cursor:col-resize;}' + '#wiz-table-row-line {height: 1px;cursor:row-resize;}' + '#wiz-table-range-border_start, #wiz-table-range-border_range {display: none;width: 0;height: 0;margin: 0;position: absolute;}' + '#wiz-table-range-border_start div, #wiz-table-range-border_range div {margin: 0;}' + '#wiz-table-range-border_start_top, #wiz-table-range-border_range_top {height: 2px;background-color: #448aff;position: absolute;top: 0;left: 0;}' + '#wiz-table-range-border_range_top {height: 1px;}' + '#wiz-table-range-border_start_right, #wiz-table-range-border_range_right {width: 2px;background-color: #448aff;position: absolute;top: 0;}' + '#wiz-table-range-border_range_right {width: 1px;}' + '#wiz-table-range-border_start_bottom, #wiz-table-range-border_range_bottom {height: 2px;background-color: #448aff;position: absolute;top: 0;}' + '#wiz-table-range-border_range_bottom {height: 1px;}' + '#wiz-table-range-border_start_left, #wiz-table-range-border_range_left {width: 2px;background-color: #448aff;position: absolute;top: 0;left: 0;}' + '#wiz-table-range-border_range_left {width: 1px;}' + '#wiz-table-range-border_start_dot, #wiz-table-range-border_range_dot {width: 5px;height: 5px;border: 2px solid rgb(255, 255, 255);background-color: #448aff;cursor: crosshair;position: absolute;z-index:' + CONST.CSS.Z_INDEX.tableRangeDot + ';}' + '.wiz-table-tools {display: block;background-color:#fff;position: absolute;left: 0px;border: 1px solid #ddd;-webkit-border-radius: 5px;-moz-border-radius: 5px;border-radius: 5px;z-index:' + CONST.CSS.Z_INDEX.tableTools + ';}' + '.wiz-table-tools ul {margin:0 !important;}' + '.wiz-table-tools ul {list-style: none !important;padding: 0;width:auto;}' + '.wiz-table-tools .wiz-table-menu-item {position: relative;float: left;margin:4px 2px 2px 8px;clear: initial;}' + '.wiz-table-tools .wiz-table-menu-item .wiz-table-menu-button {margin:0; font-size:15px;width:20px;height:20px;line-height:20px;cursor: pointer;position:relative;}' + '.wiz-table-tools i.editor-icon{font-size: 15px;color: #455a64;}' + '.wiz-table-tools .wiz-table-menu-item .wiz-table-menu-button i#wiz-menu-bg-demo{position: absolute;top:1px;left:0;}' + '.wiz-table-tools .wiz-table-menu-sub {position: absolute;display: none;width: 125px;padding: 5px 0;background: #fff;border-radius: 3px;border: 1px solid #E0E0E0;top:28px;left:-9px;box-shadow: 1px 1px 5px #d0d0d0;max-width: none;}' + '.wiz-table-tools .wiz-table-menu-sub > div{ font-size:15px;min-width:63px;}' + '.wiz-table-tools .wiz-table-menu-sub div {margin:0;}' + '.wiz-table-tools .wiz-table-menu-item.active .wiz-table-menu-sub {display: block}' + '.wiz-table-tools .wiz-table-menu-sub:before, .wiz-table-tools .wiz-table-menu-sub:after {position: absolute;content: " ";border-style: solid;border-color: transparent;border-bottom-color: #cccccc;left: 22px;margin-left: -14px;top: -8px;border-width: 0 8px 8px 8px;z-index:' + CONST.CSS.Z_INDEX.tableToolsArrow + ';}' + '.wiz-table-tools .wiz-table-menu-sub:after {border-bottom-color: #ffffff;top: -7px;}' + '.wiz-table-tools .wiz-table-menu-sub-item {margin:0;padding: 4px 12px;font-size: 14px;}' + '.wiz-table-tools .wiz-table-menu-sub-item.split {border-top: 1px solid #E0E0E0;}' + '.wiz-table-tools .wiz-table-menu-sub-item:hover {background-color: #ececec;}' + '.wiz-table-tools .wiz-table-menu-sub-item.disabled {color: #bbbbbb;cursor: default;}' + '.wiz-table-tools .wiz-table-menu-sub-item.disabled:hover {background-color: transparent;}' + '.wiz-table-tools .wiz-table-menu-item.wiz-table-cell-bg:hover .wiz-table-color-pad {display: block;}' + '.wiz-table-tools .wiz-table-color-pad {display: none;padding: 10px;box-sizing: border-box;width: 85px;height: 88px;background-color: #fff;cursor: default;}' + '.wiz-table-tools .wiz-table-color-pad > div{font-size:15px;}' + '.wiz-table-tools .wiz-table-color-pad .wiz-table-color-pad-item {display: inline-block;width: 15px;height: 15px;margin-right: 9px;position: relative;}' + '.wiz-table-tools .wiz-table-color-pad .wiz-table-color-pad-item i.pad-demo {position: absolute;top:3px;left:0;}' + '.wiz-table-tools .wiz-table-color-pad .wiz-table-color-pad-item .icon-oblique_line{color: #cc0000;}' + '.wiz-table-tools .wiz-table-color-pad .wiz-table-color-pad-item:last-child {margin-right: 0;}' + '.wiz-table-tools .wiz-table-color-pad .wiz-table-color-pad-item.active i.editor-icon.icon-box {color: #448aff;}' + '.wiz-table-tools .wiz-table-cell-align {display: none;padding: 10px;box-sizing: border-box;width: 85px;height: 65px;background-color: #fff;cursor: default;}' + '.wiz-table-tools .wiz-table-cell-align .wiz-table-cell-align-item {display: inline-block;width: 15px;height: 15px;margin-right: 9px;position: relative;}' + '.wiz-table-tools .wiz-table-cell-align .wiz-table-cell-align-item[data-align-type=align] {margin-right:8px}' + '.wiz-table-tools .wiz-table-cell-align .wiz-table-cell-align-item:last-child {margin-right:0}' + '.wiz-table-tools .wiz-table-cell-align .wiz-table-cell-align-item i.valign{position: absolute;top:3px;left:0;color: #d2d2d2;}' + '.wiz-table-tools .wiz-table-cell-align-item i.editor-icon.align {font-size:17px;}' + '.wiz-table-tools .wiz-table-cell-align-item.active i.editor-icon.valign {color: #a1c4ff;}' + '.wiz-table-tools .wiz-table-cell-align-item.active i.editor-icon.icon-box,' + '.wiz-table-tools .wiz-table-cell-align-item.active i.editor-icon.align {color: #448aff;}' + '.wiz-table-tools .wiz-table-color-pad .wiz-table-color-pad-item:last-child,' + '.wiz-table-tools .wiz-table-cell-align .wiz-table-cell-align-item:last-child {margin-right: 0;}' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' th.wiz-selected-cell-multi,' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' td.wiz-selected-cell-multi {background: rgba(0,102,255,.05);}' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' th:before,' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' td:before,' + '#wiz-table-col-line:before,#wiz-table-range-border_start_right:before,' + '#wiz-table-range-border_range_right:before {content: " ";position: absolute;top: 0;bottom: 0;right: -5px;width: 9px;cursor: col-resize;background: transparent;z-index:' + CONST.CSS.Z_INDEX.tableTDBefore + ';}' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' th:after,' + '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.WIZ_BODY + ' td:after,' + '#wiz-table-row-line:before,#wiz-table-range-border_start_bottom:before,' + '#wiz-table-range-border_range_bottom:before {content: " ";position: absolute;left: 0;right: 0;bottom: -5px;height: 9px;cursor: row-resize;background: transparent;z-index:' + CONST.CSS.Z_INDEX.tableTDBefore + ';}'
};
var TmpReaderStyle = {
  ios: '.' + CONST.CLASS.READONLY + '.' + CONST.CLASS.WIZ_BODY + ' img {' + 'max-width: 100%;' + 'height: auto !important;' + 'margin: 0px auto;' + 'cursor: pointer;' + //专门用于 ios 点击 img 触发 click 事件
  '}'
};
var TmpCommonStyle = {
  bodyForFrame: 'html, body {min-width: 0; max-width: 100%;}',
  body: 'html {height:100%;} ' +
  // 专门用于避免 ios 内 绑定 click 事件后，点击区域时显示阴影遮罩
  'body, .' + CONST.CLASS.WIZ_BODY + ' {-webkit-tap-highlight-color:rgba(255,255,255,0);}' + '.' + CONST.CLASS.WIZ_BODY + ' {min-height:100%;box-sizing:border-box;word-wrap: break-word !important;outline:none;position:relative;}' + '.' + CONST.CLASS.WIZ_BODY + ' img::selection {background-color: rgba(0, 0, 255, 0.3);}' + '.' + CONST.CLASS.WIZ_BODY + ' input:disabled, ' + '.' + CONST.CLASS.WIZ_BODY + ' textarea:disabled {opacity: 1;}',
  blockScroll: '.wiz-block-scroll::-webkit-scrollbar {width: 7px;height: 7px;}' + '.wiz-block-scroll::-webkit-scrollbar-thumb {background-color: #7f7f7f;border-radius: 7px;}' + '.wiz-block-scroll::-webkit-scrollbar-button {display: none;}',
  selectPlugin: '.' + CONST.CLASS.WIZ_BODY + ' .wiz-select-plugin-container {position:relative;display:inline-block;width:160px;height:28px;border-radius:4px;padding:0;margin-left:5px;cursor:pointer;}' + '.' + CONST.CLASS.WIZ_BODY + ' .wiz-select-plugin-container.more {width:28px;}' + '.' + CONST.CLASS.WIZ_BODY + ' .wiz-select-plugin-container,' + ' .' + CONST.CLASS.WIZ_BODY + ' .wiz-select-plugin-options {box-sizing:border-box;background:white;border:1px solid #e7e7e7;color:#333;box-shadow: 1px 1px 5px #d0d0d0;}' + '.' + CONST.CLASS.WIZ_BODY + ' .wiz-select-plugin-header {line-height:28px;font-size:14px;padding: 0 0 0 5px;overflow:hidden;margin-right:27px;white-space:nowrap;}' + '.' + CONST.CLASS.WIZ_BODY + ' .wiz-select-plugin-header i {position:absolute;top:0;right:0;line-height:26px;padding:0;text-align:center;min-width:27px;border-left:1px solid #e7e7e7;box-sizing:border-box;}' + '.' + CONST.CLASS.WIZ_BODY + ' .wiz-select-plugin-header i.icon-more {font-size:16px;border:0;width:100%;height:100%}' + '.' + CONST.CLASS.WIZ_BODY + ' .wiz-select-plugin-options {display:none;background:white;list-style:none;padding:0;margin:0;white-space:nowrap;max-height:200px;min-width:160px;max-width:260px;overflow-x:hidden;overflow-y:auto;position:absolute;top:30px;right:-1px;}' +
  // '.' + CONST.CLASS.WIZ_BODY + ' .wiz-select-plugin-options:hover .wiz-select-plugin-options-item.selected {background:white;color:inherit;}' +
  '.' + CONST.CLASS.WIZ_BODY + ' .wiz-select-plugin-options-item {font-size:14px;padding:2px 20px;line-height:normal;margin-top: 8px !important;}' + '.' + CONST.CLASS.WIZ_BODY + ' .wiz-select-plugin-options-item.disabled {font-size:12px; color:#aaaaaa;}' + '.' + CONST.CLASS.WIZ_BODY + ' .wiz-select-plugin-options-item.selected {background:#448aff;color:white;}' + '.' + CONST.CLASS.WIZ_BODY + ' .wiz-select-plugin-options-item:hover {background:#448aff !important;color:white !important;}' + '.' + CONST.CLASS.WIZ_BODY + ' .wiz-select-plugin-options-item .icon-checkmark {visibility: hidden}' + '.' + CONST.CLASS.WIZ_BODY + ' .wiz-select-plugin-options-item .icon-checkmark.active {visibility: visible}' + '.' + CONST.CLASS.WIZ_BODY + ' .wiz-select-plugin-container.active .wiz-select-plugin-options {display:block;}',
  table: '.' + CONST.CLASS.WIZ_BODY + ' .' + CONST.CLASS.TABLE_CONTAINER + ' {border:0px !important;}' + '.' + CONST.CLASS.WIZ_BODY + ' .' + CONST.CLASS.TABLE_BODY + ' {border:0px !important;position:relative;margin:10px 0;overflow-x:auto;overflow-y:hidden;-webkit-overflow-scrolling:touch;outline:none;}' + '.' + CONST.CLASS.WIZ_BODY + ' .' + CONST.CLASS.TABLE_BODY + ' table {margin:0;outline:none;}' + '.' + CONST.CLASS.WIZ_BODY + ' td,' + '.' + CONST.CLASS.WIZ_BODY + ' th {outline:none;}'
};
var DefaultStyle = {
  common: 'html, .' + CONST.CLASS.WIZ_BODY + ' {' + 'font-size: 12pt;' + '}' + '.' + CONST.CLASS.WIZ_BODY + ' {' + 'font-family: ' + CONST.CSS.DEFAULT_FONT + ';' + 'line-height: 1.7;' + 'margin: 0 auto;' + 'padding: 20px 16px;padding: 1.25rem 1rem;' + '}' + '.' + CONST.CLASS.WIZ_BODY + ' h1,' + '.' + CONST.CLASS.WIZ_BODY + ' h2,' + '.' + CONST.CLASS.WIZ_BODY + ' h3,' + '.' + CONST.CLASS.WIZ_BODY + ' h4,' + '.' + CONST.CLASS.WIZ_BODY + ' h5,' + '.' + CONST.CLASS.WIZ_BODY + ' h6 {margin:20px 0 10px;margin:1.25rem 0 0.625rem;padding: 0;font-weight: bold;}' + '.' + CONST.CLASS.WIZ_BODY + ' h1 {font-size:20pt;font-size:1.67rem;}' + '.' + CONST.CLASS.WIZ_BODY + ' h2 {font-size:18pt;font-size:1.5rem;}' + '.' + CONST.CLASS.WIZ_BODY + ' h3 {font-size:15pt;font-size:1.25rem;}' + '.' + CONST.CLASS.WIZ_BODY + ' h4 {font-size:14pt;font-size:1.17rem;}' + '.' + CONST.CLASS.WIZ_BODY + ' h5 {font-size:12pt;font-size:1rem;}' + '.' + CONST.CLASS.WIZ_BODY + ' h6 {font-size:12pt;font-size:1rem;color: #777777;margin: 1rem 0;}' + '.' + CONST.CLASS.WIZ_BODY + ' div,' + '.' + CONST.CLASS.WIZ_BODY + ' p,' + '.' + CONST.CLASS.WIZ_BODY + ' ul,' + '.' + CONST.CLASS.WIZ_BODY + ' ol,' + '.' + CONST.CLASS.WIZ_BODY + ' dl,' + '.' + CONST.CLASS.WIZ_BODY + ' li {margin:8px 0;}' + '.' + CONST.CLASS.WIZ_BODY + ' blockquote,' + '.' + CONST.CLASS.WIZ_BODY + ' table,' + '.' + CONST.CLASS.WIZ_BODY + ' pre,' + '.' + CONST.CLASS.WIZ_BODY + ' code {margin:8px 0;}' + '.' + CONST.CLASS.WIZ_BODY + ' .' + CONST.CLASS.CODE_MIRROR + ' pre {margin:0;}' + '.' + CONST.CLASS.WIZ_BODY + ' a {word-wrap: break-word;text-decoration-skip-ink: none;}' + '.' + CONST.CLASS.WIZ_BODY + ' ul,' + '.' + CONST.CLASS.WIZ_BODY + ' ol {padding-left:32px;padding-left:2rem;}' + '.' + CONST.CLASS.WIZ_BODY + ' ol.wiz-list-level1 > li {list-style-type:decimal;}' + '.' + CONST.CLASS.WIZ_BODY + ' ol.wiz-list-level2 > li {list-style-type:lower-latin;}' + '.' + CONST.CLASS.WIZ_BODY + ' ol.wiz-list-level3 > li {list-style-type:lower-roman;}' +
  // 历史原因，段落缩进 与 引用使用的是同一个 tag，所以不能设置颜色
  // '.' + CONST.CLASS.WIZ_BODY + ' blockquote {border-left:4px solid #dddddd;padding: 0 12px;color: #aaa;}' +
  '.' + CONST.CLASS.WIZ_BODY + ' blockquote {padding: 0 12px;}' + '.' + CONST.CLASS.WIZ_BODY + ' blockquote > :first-child {margin-top:0;}' + '.' + CONST.CLASS.WIZ_BODY + ' blockquote > :last-child {margin-bottom:0;}' + '.' + CONST.CLASS.WIZ_BODY + ' img {border:0;max-width:100%;height:auto !important;margin:2px 0;}' + '.' + CONST.CLASS.WIZ_BODY + ' table {border-collapse:collapse;border:1px solid #bbbbbb;}' + '.' + CONST.CLASS.WIZ_BODY + ' td,' + '.' + CONST.CLASS.WIZ_BODY + ' th {padding:4px 8px;border-collapse:collapse;border:1px solid #bbbbbb;min-height:28px;word-break:break-word;box-sizing: border-box;}' + '.' + CONST.CLASS.WIZ_BODY + ' td > div:first-child {margin-top:0;}' + '.' + CONST.CLASS.WIZ_BODY + ' td > div:last-child {margin-bottom:0;}' + '.wiz-hide {display:none !important;}'
};

// console.log(DefaultStyle.common);


var WizStyle = function WizStyle() {
  var _this = this;

  var core = null;
  var env = null;
  var domUtils = null;

  var clearBodyInlineStyle = function clearBodyInlineStyle() {
    //首先清理多余的 body 样式
    if (env.body === env.doc.body) {
      env.body.style.height = '';
      env.body.style.width = '';
    }
  };

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
  };

  this.insertDefaultStyle = function (isReplace, customCss) {
    _this.replaceStyleById(CONST.ID.WIZ_DEFAULT_STYLE, DefaultStyle.common, isReplace);
    if (!customCss) {
      return;
    }
    var css = void 0,
        hasCustomCss = false;
    if (typeof customCss === 'string') {
      css = customCss;
      hasCustomCss = true;
    } else {
      css = 'html, body{';
      for (var k in customCss) {
        if (customCss.hasOwnProperty(k)) {
          if (k.toLowerCase() === 'font-family') {
            css += k + ':' + customCss[k] + ',' + CONST.CSS.DEFAULT_FONT + ';';
          } else {
            css += k + ':' + customCss[k] + ';';
          }
          hasCustomCss = true;
        }
      }
      css += '}';
    }

    if (hasCustomCss) {
      _this.insertStyle({
        id: CONST.ID.TMP_STYLE_PRE + 'default_custom',
        name: CONST.NAME.TMP_STYLE
      }, css);
    }
  };
  this.insertCustomStyle = function (id, customCss, isTemp) {
    if (!id || !customCss) {
      return;
    }
    var options = { id: id };
    if (isTemp) {
      options.name = CONST.NAME.TMP_STYLE;
    }
    _this.insertStyle(options, customCss);
  };
  this.insertStyle = function (options, css) {
    var s = env.doc.createElement('style');
    if (options.name) {
      domUtils.attr(s, { name: options.name });
    }
    // 旧的样式需要先修改id，最后删除，否则大篇幅的笔记会由于删除样式导致屏幕闪动
    var oldS = null,
        tmpId = null;
    if (options.id) {
      tmpId = options.id + '_tmp';
      oldS = _this.getStyleById(options.id);
      if (oldS) {
        domUtils.attr(oldS, { id: tmpId });
      }
      domUtils.attr(s, { id: options.id });
    }
    s.innerHTML = css;
    env.doc.getElementsByTagName('HEAD')[0].insertBefore(s, null);
    _this.removeStyleById(tmpId);
    return s;
  };
  this.insertTmpEditorStyle = function () {
    clearBodyInlineStyle();

    var css = TmpCommonStyle.body + TmpCommonStyle.table + TmpCommonStyle.selectPlugin + TmpEditorStyle.code + TmpEditorStyle.imageResize + TmpEditorStyle.table;
    if (env.options.useFrame) {
      css += TmpCommonStyle.bodyForFrame;
    }
    if (env.options.editor.type === CONST.NOTE_EDITOR_TYPE.MARKDOWN) {
      css += TmpEditorStyle.tableInMarkdown;
    }

    _this.insertStyle({
      id: CONST.ID.TMP_STYLE_PRE + 'editor_common',
      name: CONST.NAME.TMP_STYLE
    }, css);

    if (env.client.type.isIOS && env.client.type.isPhone) {
      _this.insertStyle({
        id: CONST.ID.TMP_STYLE_PRE + 'editor_ios_phone',
        name: CONST.NAME.TMP_STYLE
      }, TmpEditorStyle.iosPhone);
    } else if (env.client.type.isIOS && env.client.type.isPad) {
      _this.insertStyle({
        id: CONST.ID.TMP_STYLE_PRE + 'editor_ios_pad',
        name: CONST.NAME.TMP_STYLE
      }, TmpEditorStyle.iosPad);
    }
    if (env.client.type.isMac) {
      _this.insertStyle({
        id: CONST.ID.TMP_STYLE_PRE + 'editor_block_scroll',
        name: CONST.NAME.TMP_STYLE
      }, TmpCommonStyle.blockScroll);
    }
  };
  this.insertTmpReaderStyle = function () {
    clearBodyInlineStyle();

    var css = TmpCommonStyle.body + TmpCommonStyle.table + TmpCommonStyle.selectPlugin;
    if (env.options.useFrame) {
      css += TmpCommonStyle.bodyForFrame;
    }

    _this.insertStyle({
      id: CONST.ID.TMP_STYLE_PRE + 'reader_common',
      name: CONST.NAME.TMP_STYLE
    }, css);

    if (env.client.type.isIOS) {
      _this.insertStyle({
        id: CONST.ID.TMP_STYLE_PRE + 'reader_ios',
        name: CONST.NAME.TMP_STYLE
      }, TmpReaderStyle.ios);
    }
    if (env.client.type.isMac) {
      _this.insertStyle({
        id: CONST.ID.TMP_STYLE_PRE + 'reader_block_scroll',
        name: CONST.NAME.TMP_STYLE
      }, TmpCommonStyle.blockScroll);
    }
  };

  this.removeFormat = function (removeAll, isRemoveColor, isRemoveAllStyles) {
    var isWizDom = function isWizDom(dom) {
      return !!dom && dom.nodeType === 1 && (domUtils.isTag(dom, [CONST.TAG.TMP_TAG, CONST.TAG.TMP_PLUGIN_TAG]) || dom.getAttribute('name') === CONST.NAME.TMP_STYLE || /^wiz[_-]/i.test(dom.id) || /(^| )wiz[_-]/i.test(dom.className));
    };
    var removeStyle = function removeStyle(elem) {
      if (!elem) {
        return;
      }
      if (domUtils.hasClass(elem, CONST.CLASS.CODE_CONTAINER)) {
        return;
      }
      if (!isWizDom(elem)) {
        domUtils.attr(elem, { style: null });
        if (!!elem.style.cssText) {
          elem.style.cssText = '';
        }
      }
      var children = elem.children;
      if (!children) {
        return;
      }
      for (var i = 0; i < children.length; i++) {
        if (children[i].nodeType === 1) {
          removeStyle(children[i]);
        }
      }
    };
    var removeClass = function removeClass(elem) {
      if (!elem) {
        return;
      }
      if (domUtils.hasClass(elem, CONST.CLASS.CODE_CONTAINER)) {
        return;
      }
      if (!isWizDom(elem)) {
        domUtils.attr(elem, { "class": null });
      }
      var children = elem.children;
      if (!children) {
        return;
      }
      for (var i = 0; i < children.length; i++) {
        if (children[i].nodeType === 1) {
          removeClass(children[i]);
        }
      }
    };

    var element = void 0,
        links = void 0,
        link = void 0,
        styles = void 0,
        style = void 0;
    try {
      if (removeAll) {
        env.doc.execCommand('SelectAll');
      }
      if (isRemoveColor) {
        env.doc.execCommand('RemoveFormat');
      }
      if (removeAll) {
        element = env.doc.documentElement;
        if (element) {
          if (isRemoveAllStyles) {
            removeClass(element);
            removeStyle(element);
          }
        }
      }
      if (isRemoveAllStyles) {
        links = env.doc.getElementsByTagName("link");
        for (var i = links.length - 1; i >= 0; i--) {
          link = links[i];
          if (link.getAttribute("rel") === "stylesheet" && !isWizDom(link)) {
            link.remove();
          }
        }
        styles = env.doc.getElementsByTagName("style");
        for (var _i = styles.length - 1; _i >= 0; _i--) {
          style = styles[_i];
          if (!isWizDom(style)) {
            style.remove();
          }
        }
      }
    } catch (err) {
      console.error(err);
      return;
    }
  };
  this.getStyleById = function (id) {
    var s = env.doc.getElementById(id);
    if (s && domUtils.isTag(s, ['style', 'link'])) {
      return s;
    }
    return null;
  };
  this.removeStyleById = function (id) {
    if (!id) {
      return;
    }
    var s = _this.getStyleById(id);
    if (s) {
      domUtils.remove(s);
    }
  };
  this.removeStyleByName = function (name) {
    var sList = env.doc.getElementsByName(name);
    for (var i = sList.length - 1; i >= 0; i--) {
      var s = sList[i];
      if (s && domUtils.isTag(s, ['style', 'link'])) {
        domUtils.remove(s);
      }
    }
  };
  this.replaceStyleById = function (id, css, onlyReplace) {
    //onlyReplace = true 则 只进行替换， 如无同id 的元素，不进行任何操作
    onlyReplace = !!onlyReplace;

    var s = env.doc.getElementById(id);
    if (!s && !onlyReplace) {
      s = env.doc.createElement('style');
      s.id = id;
      env.doc.getElementsByTagName('HEAD')[0].insertBefore(s, null);
    }
    if (s) {
      s.innerHTML = css;
    }
  };
};

module.exports = WizStyle;

},{"../config/const":388}],355:[function(require,module,exports){
'use strict';

/**
 * 修订功能 专用工具包
 */
var CONST = require('../../config/const'),
    utils = require('../../libs/utils');

var Amend = function Amend() {
  var _this = this;

  var core = null;
  var env = null;
  var lang = null;
  var amendInfo = null;
  var amendUser = null;
  var amendUtils = null;
  var blockUtils = null;
  var codeCore = null;
  var domUtils = null;
  var historyUtils = null;
  var rangeUtils = null;
  var tableCore = null;
  var tableUtils = null;
  var todoCore = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    lang = core.lang;
    amendInfo = core.require.amendInfo;
    amendUser = core.require.amendUser;
    amendUtils = core.require.amendUtils;
    blockUtils = core.require.blockUtils;
    codeCore = core.require.codeCore;
    domUtils = core.require.domUtils;
    historyUtils = core.require.historyUtils;
    rangeUtils = core.require.rangeUtils;
    tableCore = core.require.tableCore;
    tableUtils = core.require.tableUtils;
    todoCore = core.require.todoCore;

    //为 domUtils 打补丁
    (function () {
      var modifyNodeStyle = domUtils.modifyNodeStyle;
      //针对 修订特殊处理 image
      domUtils.modifyNodeStyle = function (item, style, attr, isLast) {
        var p = void 0;
        if (item.nodeType === 1 && attr && attr[CONST.ATTR.SPAN_DELETE] && domUtils.isTag(item, 'img')) {
          amendUtils.deleteImg(item, amendUser.getCurUser());
          return item;
        } else if (item.nodeType === 1 && attr && attr[CONST.ATTR.SPAN_DELETE] && domUtils.isEmptyDom(item)) {
          //TODO 需要提取 判断br 的方法
          // 只能删除 被父节点内单独存在的 br
          p = item.parentNode;
          p.removeChild(item);
          domUtils.removeEmptyParent(p);
          return item;
        } else if (item.nodeType === 1 && attr && attr[CONST.ATTR.SPAN_DELETE] && domUtils.isSelfClosingTag(item)) {
          return item;
        } else if (attr && attr[CONST.ATTR.SPAN_DELETE] && amendUtils.getWizDeleteParent(item)) {
          return item;
        } else {
          return modifyNodeStyle(item, style, attr, isLast);
        }
      };
      var addDomForGetDomList = domUtils.addDomForGetDomList;
      //忽略 在修订模式下 已经删除的内容
      domUtils.addDomForGetDomList = function (main, sub) {
        //忽略 在修订模式下 已经删除的内容
        if (amendUtils.isWizDelete(sub) ||
        //td tr 之间不能添加 span!!
        sub.nodeType === 3 && !domUtils.getParentByTagName(sub, ['td', 'th'], false, null) && domUtils.getParentByTagName(sub, 'table', false, null)) {
          return;
        }
        addDomForGetDomList(main, sub);
      };
    })();
  };

  var h6Patch = function h6Patch() {
    var range = void 0,
        block = void 0,
        hObj = void 0,
        newLine = void 0,
        isLast = false;

    var isLastDom = function isLastDom(parent, dom) {
      if (!parent) {
        return false;
      }
      var lastDom = domUtils.getLastDeepChild(parent);
      var p = domUtils.getParentByFilter(lastDom, function (obj) {
        return obj === dom;
      }, true);

      return !!p;
    };

    // 对于 h6 在行尾 换行会导致下一行还是 h6
    range = rangeUtils.getRange();
    block = env.doc.queryCommandValue("formatBlock");
    if (/^h[1-6]+$/i.test(block) && range && range.startOffset === domUtils.getEndOffset(range.startContainer)) {
      hObj = domUtils.getParentByTagName(range.startContainer, block, true);
      isLast = isLastDom(hObj, range.startContainer);
    }
    if (isLast && hObj) {
      newLine = env.doc.createElement('div');
      newLine.appendChild(env.doc.createElement('br'));
      domUtils.after(newLine, hObj);
      rangeUtils.setRange(newLine, 0);
      return true;
    }
    return false;
  };

  var isAmendEditing = false;

  /**
   * 修订操作的 事件处理
   */
  var amendEvent = {
    /**
     * 初始化时，绑定修订相关的必要事件
     */
    bind: function bind() {
      amendEvent.unbind();
      env.event.add(CONST.EVENT.ON_KEY_DOWN, amendEvent.onKeyDown);
      env.event.add(CONST.EVENT.ON_COMPOSITION_START, amendEvent.onCompositionStart);
      env.event.add(CONST.EVENT.ON_COMPOSITION_END, amendEvent.onCompositionEnd);

      if (!(env.client.type.isIOS || env.client.type.isAndroid)) {
        env.event.add(CONST.EVENT.ON_MOUSE_DOWN, amendEvent.onMouseDown);
        env.event.add(CONST.EVENT.ON_MOUSE_UP, amendEvent.onMouseUp);
      } else {
        env.event.add(CONST.EVENT.ON_TOUCH_START, amendEvent.onTouchStart);
      }
      env.event.add(CONST.EVENT.ON_DRAG_START, amendEvent.onDragDrop);
      env.event.add(CONST.EVENT.ON_DRAG_ENTER, amendEvent.onDragDrop);
      env.event.add(CONST.EVENT.ON_DROP, amendEvent.onDragDrop);
    },
    /**
     * 解绑修订相关的必要事件
     */
    unbind: function unbind() {
      env.event.remove(CONST.EVENT.ON_KEY_DOWN, amendEvent.onKeyDown);
      env.event.remove(CONST.EVENT.ON_COMPOSITION_START, amendEvent.onCompositionStart);
      env.event.remove(CONST.EVENT.ON_COMPOSITION_END, amendEvent.onCompositionEnd);
      env.event.remove(CONST.EVENT.ON_MOUSE_DOWN, amendEvent.onMouseDown);
      env.event.remove(CONST.EVENT.ON_MOUSE_UP, amendEvent.onMouseUp);
      env.event.remove(CONST.EVENT.ON_TOUCH_START, amendEvent.onTouchStart);

      env.event.remove(CONST.EVENT.ON_DRAG_START, amendEvent.onDragDrop);
      env.event.remove(CONST.EVENT.ON_DRAG_ENTER, amendEvent.onDragDrop);
      env.event.remove(CONST.EVENT.ON_DROP, amendEvent.onDragDrop);
    },
    /**
     * 绑定反转修订相关的必要事件
     */
    bindReverse: function bindReverse() {
      amendEvent.unbindReverse();
      env.event.add(CONST.EVENT.ON_KEY_DOWN, amendEvent.onKeyDown);
      env.event.add(CONST.EVENT.ON_COMPOSITION_START, amendEvent.onCompositionStart);
      env.event.add(CONST.EVENT.ON_COMPOSITION_END, amendEvent.onCompositionEnd);
      if (!env.client.type.isIOS && !env.client.type.isAndroid) {
        env.event.add(CONST.EVENT.ON_MOUSE_DOWN, amendEvent.onMouseDown);
        env.event.add(CONST.EVENT.ON_MOUSE_UP, amendEvent.onMouseUp);
      }
    },
    /**
     * 解绑反转修订相关的必要事件
     */
    unbindReverse: function unbindReverse() {
      env.event.remove(CONST.EVENT.ON_KEY_DOWN, amendEvent.onKeyDown);
      env.event.remove(CONST.EVENT.ON_COMPOSITION_START, amendEvent.onCompositionStart);
      env.event.remove(CONST.EVENT.ON_COMPOSITION_END, amendEvent.onCompositionEnd);
      env.event.remove(CONST.EVENT.ON_MOUSE_DOWN, amendEvent.onMouseDown);
      env.event.remove(CONST.EVENT.ON_MOUSE_UP, amendEvent.onMouseUp);
    },
    /**
     * 点击 修订信息图层的 接受修订按钮 回调
     */
    onAccept: function onAccept(target) {
      _this.accept(target);
    },
    /**
     * 点击 修订信息图层的 拒绝修订按钮 回调
     */
    onRefuse: function onRefuse(target) {
      _this.refuse(target);
    },
    /**
     * history 控件  beforeSaveSnap 保存快照之前的回调，用于在保存快照前执行必要操作
     */
    onBeforeSaveSnap: function onBeforeSaveSnap() {
      //隐藏 修订信息浮动图层，避免 undo 保存多余的图层数据
      amendInfo.hide(true);
    },
    /**
     * history 控件  afterRestoreHistory 保存快照之后的回调，用于在保存快照后执行必要操作
     */
    onAfterRestoreHistory: function onAfterRestoreHistory() {
      //重新设置 amendInfo 的图层对象
      _this.startAmendInfo();
    },
    /**
     * 中文输入开始
     */
    onCompositionStart: function onCompositionStart() {
      env.compositionStart = true;
    },
    /**
     * 中文输入结束
     */
    onCompositionEnd: function onCompositionEnd() {
      env.compositionStart = false;
      //必须要延迟处理， 否则输入中文后按下 ESC 执行取消操作，触发此事件时，页面上还存在输入的中文拼音
      setTimeout(function () {
        historyUtils.saveSnap(true);
      }, 0);
    },
    /**
     * 拖拽 文件 或 文本
     */
    onDragDrop: function onDragDrop(e) {
      //修订编辑时 禁用 拖拽操作，否则无法控制输入的内容
      utils.stopEvent(e);
      return false;
    },
    /**
     * 按下键盘
     */
    onKeyDown: function onKeyDown(e) {
      // let keyCode = e.keyCode || e.which;
      var range = rangeUtils.getRange();

      // 只有删除时才清理 特殊字符，避免 输入内容时 清空特殊字符导致光标跑到 span 外
      // if (keyCode === 8 || keyCode === 46) {
      // 新的修正规则，只要不是在中文输入期间都立刻清理特殊字符
      if (!env.compositionStart) {
        rangeUtils.clearFillCharByCollapsed();
      }

      if (codeCore && !codeCore.onKeyDown(e) || !tableCore.onKeyDown(e) || todoCore && !todoCore.onKeyDown(e)) {
        return;
      }

      //无光标时，或输入法开始后 不操作任何内容
      if (!range || env.compositionStart) {
        return;
      }

      if (_this.isAmendEditing()) {
        amendEvent.onKeyDownAmend(e);
      } else {
        amendEvent.onKeyDownReverse(e);
      }
    },
    /**
     * 按下键盘 for Amend
     */
    onKeyDownAmend: function onKeyDownAmend(e) {
      var keyCode = e.keyCode || e.which;
      // console.info(e);
      var sel = rangeUtils.getSelection(),
          range = void 0,
          endDom = void 0,
          endOffset = void 0,
          nSpan = void 0,
          nSpanNext = void 0,
          nA = void 0,
          tmpA = void 0,
          tmpNext = void 0,
          tmpSplitStr = void 0,
          tmpSplit = void 0,
          tmpParentRoot = void 0;

      /**
       * Backspace
       */
      if (keyCode === 8) {
        historyUtils.saveSnap(false);

        if (!sel.isCollapsed) {
          amendUtils.removeSelection(amendUser.getCurUser());
          amendUtils.removeUserDel(null, amendUser.getCurUser());
          sel.collapseToStart();
        } else {
          //                  console.log(endDom.nodeValue);
          rangeUtils.selectCharIncludeFillChar(true);
          amendUtils.removeSelection(amendUser.getCurUser());
          tmpParentRoot = rangeUtils.getRangeParentRoot();
          sel.collapseToStart();

          // 屏蔽无用代码
          // range = sel.getRangeAt(0);
          // endDom = range.startContainer;
          // if (endDom.nodeType === 3) {
          //     endDom = endDom.parentNode;
          // }

          //保证光标移动正确， isCollapsed 的时候，必须先移动光标再做删除操作
          amendUtils.removeUserDel(tmpParentRoot, amendUser.getCurUser());

          sel.collapseToStart();
        }
        rangeUtils.caretFocus();
        utils.stopEvent(e);
        return;
      }
      /**
       * Delete
       */
      if (keyCode === 46) {
        historyUtils.saveSnap(false);

        if (sel.isCollapsed) {
          rangeUtils.selectCharIncludeFillChar(false);
        }
        amendUtils.removeSelection(amendUser.getCurUser());
        amendUtils.removeUserDel(null, amendUser.getCurUser());
        sel.collapseToEnd();

        rangeUtils.caretFocus();
        utils.stopEvent(e);
        return;
      }

      /**
       * 其他功能键一概忽略
       */
      if (utils.checkNonTxtKey(e)) {
        return;
      }

      /**
       * 普通字符
       */

      /**
       * 先执行 execCommand， 后操作 range ， 执行 execCommand 之后， endDom 会发生改变
       * 先操作 range 后执行 execCommand， 无法控制当前选中的 endDom，一旦修改里面内容， execCommand 执行的结果就出现异常
       * 使用 自己的方法直接操作 dom，放弃 execCommand
       */
      var splitInsert = void 0,
          amendImg = void 0;
      historyUtils.saveSnap(false);
      if (!sel.isCollapsed) {
        amendUtils.removeSelection(amendUser.getCurUser());
        amendUtils.removeUserDel(null, amendUser.getCurUser());
      }
      range = sel.getRangeAt(0);
      endDom = range.endContainer;
      endOffset = range.endOffset;

      /**
       * Enter
       */
      if (keyCode === 13) {
        var delDom = amendUtils.getWizDeleteParent(endDom),
            insertDom = amendUtils.getWizInsertParent(endDom),
            isImg = !!insertDom ? amendUtils.getWizAmendImgParent(endDom) : false,
            aDom = delDom || insertDom;
        if (aDom && aDom.childNodes.length === 1 && (!domUtils.isUsableTextNode(aDom.childNodes[0]) || aDom.childNodes[0].nodeType === 1 && domUtils.isTag(aDom.childNodes[0], 'br'))) {
          //如果按下 Enter 键 时， 光标处于空白的 wizspan 标签内时，立刻删除该 span，避免span 的样式被 浏览器默认转换为 font 标签
          (function () {
            var p = aDom.parentNode,
                b = env.doc.createElement('br');
            p.insertBefore(b, aDom);
            p.removeChild(aDom);
            rangeUtils.setRange(b, 1, b, 1);
          })();
        } else if (insertDom && isImg) {
          //按下 Enter 键时，如果处于 IMG SPAN 区域内， 则直接在该区域最后添加span，避免 浏览器默认继承 样式
          (function () {
            var s = domUtils.createSpan();
            s.innerHTML = CONST.FILL_CHAR;
            domUtils.after(s, insertDom);
            rangeUtils.setRange(s, 1, s, 1);
          })();
        } else if (insertDom) {
          (function () {
            var s = domUtils.createSpan();
            s.innerHTML = CONST.FILL_CHAR;
            splitInsert = amendUtils.splitInsertDom(endDom, endOffset, true, amendUser.getCurUser());
            if (splitInsert.isInsert && splitInsert.split) {
              domUtils.after(s, insertDom);
              rangeUtils.setRange(s, 1, s, 1);
            } else if (splitInsert.isInsert) {
              domUtils.before(s, insertDom, endOffset > 0);
              rangeUtils.setRange(s, 1, s, 1);
            }
          })();
        } else if (delDom) {
          (function () {
            var s = domUtils.createSpan();
            s.innerHTML = CONST.FILL_CHAR;
            splitInsert = amendUtils.splitDeletedDom(endDom, endOffset);
            if (splitInsert) {
              domUtils.after(s, delDom);
              rangeUtils.setRange(s, 1, s, 1);
            } else {
              domUtils.before(s, delDom, endOffset > 0);
              rangeUtils.setRange(s, 1, s, 1);
            }
          })();
        } else if (h6Patch()) {
          utils.stopEvent(e);
          return;
        }

        sel.collapseToEnd();
        return;
      }

      splitInsert = amendUtils.splitInsertDom(endDom, endOffset, false, amendUser.getCurUser());
      amendImg = amendUtils.getWizAmendImgParent(endDom);
      if (splitInsert.isInsert && !splitInsert.split && !amendImg) {
        if (endOffset === 0 && splitInsert.insertDom.nodeType === 1) {
          //添加空字符，避免录入的字符被放到 已删除的后面
          domUtils.before(env.doc.createTextNode(CONST.FILL_CHAR), splitInsert.insertDom.childNodes[0]);
          rangeUtils.setRange(splitInsert.insertDom, 1, null, null);
        } else {
          rangeUtils.setRange(endDom, endOffset, null, null);
        }

        range = sel.getRangeAt(0);
        /**
         * Tab == 4 * ' '
         */
        if (keyCode === 9) {
          range.insertNode(domUtils.getTab());
          sel.modify('move', 'forward', 'character');
          sel.modify('move', 'forward', 'character');
          sel.modify('move', 'forward', 'character');
          sel.modify('move', 'forward', 'character');
          utils.stopEvent(e);
        }
        return;
      }

      nSpan = amendUtils.createDomForInsert(amendUser.getCurUser());
      if (splitInsert.split) {
        //如果在 用户新增的 span 内操作， 则在span 拆分后，添加到 两个 span 之间
        if (endDom.nodeType === 3) {
          endDom = endDom.parentNode;
        }
        domUtils.before(nSpan, endDom, endOffset > 0);
      } else if (amendImg) {
        //如果 光标处于 已修订的图片内， 则添加在 图片 容器 后面
        domUtils.after(nSpan, amendImg);
      } else if (endDom.nodeType === 1) {
        // endDom nodeType == 1 时， 光标应该是在 childNodes[endOffset] 元素的前面
        if (endOffset < endDom.childNodes.length) {
          //避免嵌套 span ，如果 endDom 为 wizSpan 并且 内容为空或 br 时，直接删除该span
          if (endDom.getAttribute(CONST.ATTR.SPAN) && (endDom.childNodes.length === 0 || endDom.childNodes.length === 1 && domUtils.isTag(endDom.childNodes[0], 'br'))) {
            domUtils.before(nSpan, endDom);
            domUtils.remove(endDom);
          } else {
            domUtils.before(nSpan, endDom.childNodes[endOffset]);
          }
        } else if (domUtils.isTag(endDom, ['td', 'th']) || domUtils.hasClass(endDom, CONST.CLASS.TODO_MAIN)) {
          //如果光标处于 表格内部，不能直接把 nSpan 放到 td 的 后面
          //也不能把 nSpan 放到 todoList Main 的后面
          if (domUtils.isEmptyDom(endDom)) {
            endDom.innerHTML = '';
          }
          endDom.appendChild(nSpan);
        } else {
          domUtils.after(nSpan, endDom);
        }
      } else if (endDom.nodeType === 3) {
        if (amendUtils.splitDeletedDom(endDom, endOffset)) {
          domUtils.after(nSpan, endDom.parentNode);
        } else if (endOffset < endDom.nodeValue.length) {
          tmpSplitStr = endDom.nodeValue.substr(endOffset);
          tmpSplit = env.doc.createTextNode(tmpSplitStr);
          endDom.nodeValue = endDom.nodeValue.substr(0, endOffset);
          domUtils.after([nSpan, tmpSplit], endDom);
        } else {
          nA = domUtils.getParentByTagName(endDom, 'a', true, null);
          tmpNext = nA ? domUtils.getNextNode(endDom) : null;
          tmpA = tmpNext ? domUtils.getParentByTagName(tmpNext, 'a', true, null) : null;
          nSpanNext = endDom.nextSibling;
          if (nA && nA !== tmpA) {
            //光标在 <A> 标签结尾的时候，一定要让光标进入 <A> 下一个Dom
            domUtils.after(nSpan, nA);
          } else if (nSpanNext) {
            domUtils.before(nSpan, nSpanNext);
          } else {
            endDom.parentNode.insertBefore(nSpan, null);
          }
        }
      }

      /**
       * Tab == 4 * ' '
       */
      if (keyCode === 9) {
        nSpan.appendChild(domUtils.getTab());
        rangeUtils.setRange(nSpan, 2, null, null);
        utils.stopEvent(e);
      } else {
        rangeUtils.setRange(nSpan.childNodes[0], 1, null, null);
      }

      //不能使用 selectAllChildren ，否则 输入 空格时 浏览器会自动复制前一个 span 的所有样式
      // sel.selectAllChildren(nSpan);
      //此方法会导致 Mac 的搜狗输入法 第一个字母被吃掉
      // rangeUtils.setRange(nSpan.childNodes[0], 0, nSpan.childNodes[0], nSpan.childNodes[0].nodeValue.length);
    },
    /**
     * 按下键盘 for 逆修订
     */
    onKeyDownReverse: function onKeyDownReverse(e) {
      var keyCode = e.keyCode || e.which;
      // console.info(e);
      var range = rangeUtils.getRange();
      var fixed = amendUtils.fixedAmendRange();

      var fixClearLine = function fixClearLine(dom, direct) {
        //从右往左 Backspace  direct = -1
        //从左往右 Delete  direct = 1
        if (!dom) {
          return;
        }
        var tmpDom = void 0,
            wizDom = void 0;
        //专门处理 删除一行文字后， 浏览器默认记住最后删除文字样式的特性
        //此特性导致删除修订内容后， 重新输入的文字会带有修订的样式
        wizDom = amendUtils.getWizAmendParent(dom);
        if (wizDom && wizDom.childNodes.length === 1) {
          tmpDom = domUtils.createSpan();
          tmpDom.innerHTML = CONST.FILL_CHAR + CONST.FILL_CHAR;
          domUtils.before(tmpDom, wizDom, direct > 0);
          domUtils.remove(wizDom);
          rangeUtils.setRange(tmpDom, direct > 0 ? 0 : 2, tmpDom, 1);
        }
      };

      /**
       * Backspace
       */
      if (keyCode === 8) {
        historyUtils.saveSnap(false);

        if (range && range.collapsed && fixed && fixed.leftDom) {
          // // 如果前一个是 table，则 delete 键直接移动光标
          // cell = domUtils.getParentByTagName(fixed.leftDom, ['td', 'th'], true, null);
          // console.log(sel.getRangeAt(0).endContainer.outerHTML);
          // console.log(sel.getRangeAt(0).endOffset);
          // console.log(fixed.leftDom);
          // if (!curCell && cell) {
          //     console.log('prev is table, stop event....')
          //     rangeUtils.setRange(cell, domUtils.getEndOffset(cell));
          //     utils.stopEvent(e);
          //     return;
          // }
          fixed.startImg = amendUtils.getWizAmendImgParent(fixed.leftDom);
          if (fixed.startImg) {
            fixed.startDom = fixed.startImg;
            fixed.startOffset = 0;
            rangeUtils.setRange(fixed.startDom, fixed.startOffset, fixed.endDom, fixed.endOffset);
          } else if (fixed.leftDom.nodeType === 3 && fixed.leftDom.nodeValue.length === 1) {
            fixClearLine(fixed.leftDom, -1);
          }
        }
        return;
      }
      /**
       * Delete
       */
      if (keyCode === 46) {
        historyUtils.saveSnap(false);
        if (range && range.collapsed && fixed && fixed.rightDom) {
          // // 如果下一个是 table，则 delete 键直接移动光标
          // var cell = domUtils.getParentByTagName(fixed.rightDom, ['td', 'th'], true, null);
          // if (!curCell && cell) {
          //     console.log('next is table, stop event....')
          //     rangeUtils.setRange(cell, 0);
          //     utils.stopEvent(e);
          //     return;
          // }
          fixed.endImg = amendUtils.getWizAmendImgParent(fixed.rightDom);
          if (fixed.endImg) {
            fixed.endDom = fixed.endImg;
            fixed.endOffset = fixed.endImg.childNodes.length;
            rangeUtils.setRange(fixed.startDom, fixed.startOffset, fixed.endDom, fixed.endOffset);
          } else if (fixed.rightDom.nodeType === 3 && fixed.rightDom.nodeValue.length === 1) {
            fixClearLine(fixed.rightDom, 1);
          }
        }
        return;
      }

      /**
       * 其他功能键一概忽略
       */
      if (utils.checkNonTxtKey(e)) {
        return;
      }

      /**
       * 普通字符
       */
      historyUtils.saveSnap(false);
      _this.splitAmendDomByRange(fixed);
      //删除 range 选中区域后，必须要避免光标进入 table 容器内
      var check = tableUtils.checkCaretInTableContainer();
      blockUtils.insertEmptyLine(check.tableContainer, check.after);

      if (keyCode === 13 && h6Patch()) {
        utils.stopEvent(e);
        // return;
      }
    },
    /**
     * 避免 修订信息图层被编辑  & 鼠标按下后 暂停 amendInfo 显示
     */
    onMouseDown: function onMouseDown(e) {
      var isInfo = amendInfo.isInfo(e.target);
      if (isInfo) {
        utils.stopEvent(e);
        return;
      }
      amendInfo.stop();
    },
    /**
     *  鼠标按下后 恢复 amendInfo 显示
     */
    onMouseUp: function onMouseUp() {
      amendInfo.start();
      //var amendDoms = amendUtils.getSelectedAmendDoms();
      //
      //if (amendDoms) {
      //    console.log(amendDoms)
      //
      //    //amendInfo.showAmendsInfo(amendDoms);
      //}
    },
    onTouchStart: function onTouchStart(e) {}
  };

  /**
   * 接受 修订内容
   */
  this.accept = function (target) {
    var sel = rangeUtils.getSelection(),
        options = {},
        amendDoms = void 0;

    if (target.total) {
      options.selection = true;
      options.selectAll = true;
    } else if (target.dom && !target.isSelection) {
      options.domList = amendUtils.getSameTimeStampDom(target.dom);
      options.selection = false;
    } else {
      //TODO 无光标焦点时，跳转到下一个修订内容
      if (sel.rangeCount === 0) {
        return;
      }

      options.selection = true;
      options.selectAll = false;
    }

    //先保存 内容快照，便于 undo
    historyUtils.saveSnap(false);

    if (options.selection && !options.selectAll) {
      amendDoms = amendUtils.getSelectedAmendDoms();
    } else {
      amendDoms = amendUtils.getAmendDoms(options);
    }

    if (amendDoms) {
      amendUtils.splitSelectedAmendDoms(amendDoms);

      //删除 已删除的
      amendUtils.wizAmendDelete(amendDoms.deleteList);
      amendUtils.wizAmendDelete(amendDoms.deletedInsertList);
      //保留 新添加的
      amendUtils.wizAmendSave(amendDoms.insertList);
    }

    //合并文档， 清除冗余html
    domUtils.clearChildSpan(env.body, []);
  };

  this.changeCurUser = function (user) {
    env.options.userInfo = user;
    amendUser.initUser();
  };

  this.fixPaste = function (start, end, user) {
    amendUtils.modifyDomForPaste(start, end, user);
  };

  /**
   * 复制时 根据 fragment 过滤修订内容
   */
  this.fragmentFilter = function (fragment) {
    if (!fragment) {
      return false;
    }

    var delDom = fragment.querySelectorAll('.' + CONST.CLASS.WIZ_BODY + ' span[' + CONST.ATTR.SPAN_DELETE + '="' + amendUser.getCurUser().hash + '"]');
    for (var i = delDom.length - 1; i >= 0; i--) {
      var delDomItem = delDom[i];
      domUtils.remove(delDomItem);
    }
  };

  /**
   * 隐藏显示 修订信息（主要用于保存笔记前处理）
   */
  this.hideAmendInfo = function () {
    amendInfo.hide(true);
  };

  /**
   * 判断笔记是否存在 被修订的痕迹
   */
  this.isAmendEdited = function () {
    return amendUtils.isAmendEdited();
  };

  this.isAmendEditing = function () {
    return isAmendEditing;
  };

  this.hasAmendSpanByCursor = function () {
    var amendDoms = amendUtils.getAmendDoms({
      selection: true,
      selectAll: false
    });

    return amendDoms.insertList.length > 0 || amendDoms.deleteList.length > 0 || amendDoms.deletedInsertList.length > 0;
  };

  this.readyForPaste = function () {
    var range = rangeUtils.getRange(),
        endDomBak = void 0,
        endDom = void 0,
        endOffset = void 0,
        id = void 0,
        newDom = void 0,
        nSpanStart = void 0,
        nSpanContent = void 0,
        nSpanEnd = void 0,
        nSpanNext = void 0,
        nA = void 0,
        p = void 0,
        tmpSplit = void 0,
        splitInsert = void 0,
        amendImg = void 0,
        isTd = void 0;

    //无光标时， 不操作任何内容
    if (!range) {
      return;
    }

    if (!range.collapsed) {
      endDomBak = domUtils.getParentByTagName(range.endContainer, ['td', 'th'], true, null);
      amendUtils.removeSelection(amendUser.getCurUser());
      amendUtils.removeUserDel(null, amendUser.getCurUser());
    }

    range = rangeUtils.getRange();
    endDom = range.endContainer;
    endOffset = range.endOffset;

    if (domUtils.isTag(endDom, ['td', 'th']) && endOffset === 0 && endDomBak !== endDom) {
      //清理 用户已删除内容时，可能会导致 光标进入到下一个 td 内，所以必须修正
      endDom = endDomBak;
      endOffset = domUtils.getEndOffset(endDom);
    }

    splitInsert = amendUtils.splitInsertDom(endDom, endOffset, true, amendUser.getCurUser());

    id = new Date().valueOf();
    newDom = amendUtils.createDomForPaste(id);
    nSpanStart = newDom.start;
    nSpanContent = newDom.content;
    nSpanEnd = newDom.end;
    amendImg = amendUtils.getWizAmendImgParent(endDom);

    if (splitInsert.split) {
      //如果在 用户新增的 span 内操作， 则在span 拆分后，添加到 两个 span 之间
      if (endDom.nodeType === 3) {
        endDom = endDom.parentNode;
      }
      domUtils.before([nSpanStart, nSpanContent, nSpanEnd], endDom, endOffset > 0);
    } else if (amendImg) {
      domUtils.after([nSpanStart, nSpanContent, nSpanEnd], amendImg);
    } else if (endDom.nodeType === 1) {
      // endDom nodeType == 1 时， 光标应该是在 childNodes[endOffset] 元素的前面
      isTd = false;
      if (domUtils.isTag(endDom, ['td', 'th'])) {
        //如果 target 是 td 则必须在 td内建立 span，避免插入到 td 后面
        if (domUtils.isEmptyDom(endDom)) {
          endDom.innerHTML = '';
          endDom.appendChild(domUtils.createSpan());
        }
        isTd = true;
      }

      if (endOffset < endDom.childNodes.length) {
        domUtils.before([nSpanStart, nSpanContent, nSpanEnd], endDom.childNodes[endOffset]);
      } else if (isTd) {
        endDom.appendChild(nSpanStart);
        endDom.appendChild(nSpanContent);
        endDom.appendChild(nSpanEnd);
      } else {
        domUtils.after([nSpanStart, nSpanContent, nSpanEnd], endDom);
      }
    } else if (endDom.nodeType === 3) {
      if (amendUtils.splitDeletedDom(endDom, endOffset)) {
        domUtils.after([nSpanStart, nSpanContent, nSpanEnd], endDom.parentNode);
      } else if (endOffset < endDom.nodeValue.length) {
        tmpSplit = env.doc.createTextNode(endDom.nodeValue.substr(endOffset));
        endDom.nodeValue = endDom.nodeValue.substr(0, endOffset);
        domUtils.after([nSpanStart, nSpanContent, nSpanEnd, tmpSplit], endDom);
      } else {
        nA = domUtils.getParentByTagName(endDom, 'a', true, null);
        nSpanNext = endDom.nextSibling;
        if (nA) {
          //光标在 <A> 标签结尾的时候，一定要让光标进入 <A> 下一个Dom
          domUtils.after([nSpanStart, nSpanContent, nSpanEnd], nA);
        } else if (nSpanNext) {
          domUtils.before([nSpanStart, nSpanContent, nSpanEnd], nSpanNext);
        } else {
          p = endDom.parentNode;
          p.insertBefore(nSpanStart, null);
          p.insertBefore(nSpanContent, null);
          p.insertBefore(nSpanEnd, null);
        }
      }
    }

    //不能使用 selectAllChildren ，否则 输入 空格时 浏览器会自动复制前一个 span 的所有样式
    //        sel.selectAllChildren(nSpanStart);
    rangeUtils.setRange(nSpanContent.childNodes[0], 0, nSpanContent.childNodes[0], 1);

    setTimeout(function () {
      //有时候 nSpanEnd 的 DOM 在 粘贴操作后会自动变成新的 DOM 导致处理异常，
      //所以必须重新获取 nSpanEnd
      nSpanEnd = env.body.querySelector(' span[' + CONST.ATTR.SPAN_PASTE_TYPE + '="' + CONST.TYPE.PASTE.END + '"][' + CONST.ATTR.SPAN_PASTE_ID + '="' + nSpanEnd.getAttribute(CONST.ATTR.SPAN_PASTE_ID) + '"]');
      _this.fixPaste(nSpanStart, nSpanEnd, amendUser.getCurUser());
    }, 200);
  };

  /**
   *  拒绝 修订内容
   */
  this.refuse = function (target) {
    var sel = rangeUtils.getSelection(),
        options = {},
        amendDoms = void 0;

    if (target.total) {
      options.selection = true;
      options.selectAll = true;
    } else if (target.dom && !target.isSelection) {
      options.domList = amendUtils.getSameTimeStampDom(target.dom);
      options.selection = false;
    } else {
      //TODO 无光标焦点时，跳转到下一个修订内容
      if (sel.rangeCount === 0) {
        return;
      }

      options.selection = true;
      options.selectAll = false;
    }

    //先保存 内容快照，便于 undo
    historyUtils.saveSnap(false);

    if (options.selection && !options.selectAll) {
      amendDoms = amendUtils.getSelectedAmendDoms();
    } else {
      amendDoms = amendUtils.getAmendDoms(options);
    }

    if (amendDoms) {
      amendUtils.splitSelectedAmendDoms(amendDoms);

      //对于 用户B 删除了用户A 新增的内容，只有单独选中该 dom 拒绝修订时， 才还原为 用户A 新增的内容，
      //否则拒绝时，一律当作 用户A 新增的内容进行删除操作
      var saveDeletedInsert = amendDoms.deletedInsertList.length > 0 && amendDoms.deleteList.length === 0 && amendDoms.insertList.length === 0;

      //保留 已删除的
      amendUtils.wizAmendSave(amendDoms.deleteList);
      if (saveDeletedInsert) {
        amendUtils.wizAmendSave(amendDoms.deletedInsertList);
      }
      //删除 新添加的
      amendUtils.wizAmendDelete(amendDoms.insertList);
      if (!saveDeletedInsert) {
        amendUtils.wizAmendDelete(amendDoms.deletedInsertList);
      }
    }

    //合并文档， 清除冗余html
    domUtils.clearChildSpan(env.body, []);
  };

  /**
   * 参考 amendUtils.splitAmendDomByRange
   */
  this.splitAmendDomByRange = function (fixed) {
    return amendUtils.splitAmendDomByRange(fixed);
  };

  /**
   * 开启 修订功能
   */
  this.start = function () {
    isAmendEditing = true;
    _this.stopReverse();
    amendEvent.bind();
    _this.startAmendInfo();
    env.event.add(CONST.EVENT.BEFORE_SAVESNAP, amendEvent.onBeforeSaveSnap);
    env.event.add(CONST.EVENT.AFTER_RESTORE_HISTORY, amendEvent.onAfterRestoreHistory);
  };

  /**
   * 开启 反转修订功能
   */
  this.startReverse = function () {
    _this.stop();

    amendEvent.bindReverse();
    _this.startAmendInfo();
  };

  /**
   * 开启显示 修订信息
   */
  this.startAmendInfo = function (options) {
    amendInfo.init(options, {
      onAccept: amendEvent.onAccept,
      onRefuse: amendEvent.onRefuse
    });
  };

  /**
   * 关闭 修订功能
   */
  this.stop = function () {
    isAmendEditing = false;
    amendEvent.unbind();
    amendInfo.remove();
    if (!_this.isAmendEdited()) {
      //删除 所有修订者 信息
      //amendUser.removeAllUserInfo();
    }
    env.event.remove(CONST.EVENT.BEFORE_SAVESNAP, amendEvent.onBeforeSaveSnap);
    env.event.remove(CONST.EVENT.AFTER_RESTORE_HISTORY, amendEvent.onAfterRestoreHistory);
  };

  /**
   * 关闭 反转修订功能
   */
  this.stopReverse = function () {
    amendEvent.unbindReverse();
    amendInfo.remove();
    if (!_this.isAmendEdited()) {
      //删除 所有修订者 信息
      //amendUser.removeAllUserInfo();
    }
  };

  /**
   * 关闭显示 修订信息
   */
  this.stopAmendInfo = function () {
    amendInfo.remove();
  };
};

module.exports = Amend;

},{"../../config/const":388,"../../libs/utils":400}],356:[function(require,module,exports){
'use strict';

/**
 * 修订信息显示图层 相关对象
 */
var CONST = require('../../config/const');
var utils = require('../../libs/utils');

var AmendInfo = function AmendInfo() {
  var _this = this;

  var core = null;
  var env = null;
  var lang = null;
  var amendUser = null;
  var amendUserAction = null;
  var amendUtils = null;
  var domUtils = null;
  var rangeUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    lang = core.lang;
    amendUser = core.require.amendUser;
    amendUserAction = core.require.amendUserAction;
    amendUtils = core.require.amendUtils;
    domUtils = core.require.domUtils;
    rangeUtils = core.require.rangeUtils;
  };

  var callback = {
    onAccept: null,
    onRefuse: null
  };
  // 暂停显示的标志
  var pause = false;
  // 记录最后一次鼠标移动的位置
  var lastMousePos = { x: null, y: null };

  var _event = {
    bind: function bind() {
      if (env.client.type.isIOS || env.client.type.isAndroid) {
        env.event.add(CONST.EVENT.ON_TOUCH_START, _event.handler.onTouchstart);
        env.event.add(CONST.EVENT.ON_TOUCH_END, _event.handler.onMouseMove);
      } else {
        env.event.add(CONST.EVENT.ON_MOUSE_MOVE, _event.handler.onMouseMove);
      }
    },
    unbind: function unbind() {
      env.event.remove(CONST.EVENT.ON_TOUCH_START, _event.handler.onTouchstart);
      env.event.remove(CONST.EVENT.ON_TOUCH_END, _event.handler.onMouseMove);
      env.event.remove(CONST.EVENT.ON_MOUSE_MOVE, _event.handler.onMouseMove);
    },
    bindInfoBtn: function bindInfoBtn() {
      _event.unbindInfoBtn();
      if (env.client.type.isIOS || env.client.type.isAndroid) {
        _this.main.addEventListener('touchend', _event.handler.onClick);
      } else {
        _this.main.addEventListener('click', _event.handler.onClick);
      }
    },
    unbindInfoBtn: function unbindInfoBtn() {
      if (env.client.type.isIOS || env.client.type.isAndroid) {
        _this.main.removeEventListener('touchend', _event.handler.onClick);
      } else {
        _this.main.removeEventListener('click', _event.handler.onClick);
      }
    },

    handler: {
      onAccept: function onAccept(e) {
        if (callback.onAccept) {
          callback.onAccept(getCallbackParams());
        }
        _this.hide(true);
        amendUserAction.save(amendUserAction.ActionId.ClickAcceptFromAmendInfo);
      },
      onClick: function onClick(e) {
        var target = void 0;
        if (e.changedTouches) {
          target = e.changedTouches[0].target;
        } else {
          target = e.target;
        }
        if (target.id === CONST.ID.AMEND_INFO_ACCEPT) {
          _event.handler.onAccept(e);
        } else if (target.id === CONST.ID.AMEND_INFO_REFUSE) {
          _event.handler.onRefuse(e);
        }
        utils.stopEvent(e);
      },
      /**
       * 检测 鼠标移动到的 dom 对象，是否需要显示 或 隐藏 amendInfo
       */
      onMouseMove: function onMouseMove(e) {
        //console.log('onMouseMove....')
        var eventClient = utils.getEventClientPos(e);
        //如果鼠标没有移动， 仅仅输入文字导致触发mousemove事件时，不弹出信息框
        if (lastMousePos.x === eventClient.x && lastMousePos.y === eventClient.y) {
          return;
        }
        lastMousePos = eventClient;
        if (pause) {
          return;
        }
        var target = e.target,
            isInfo = _this.isInfo(target),
            scroll = void 0,
            pos = {
          width: 20,
          height: 20
        };

        //在 修订信息图层内移动， 不进行任何操作
        if (isInfo) {
          clearTimeout(_this.showTimer);
          clearTimeout(_this.hideTimer);
          return;
        }

        var sel = rangeUtils.getSelection(),
            selectedDoms = void 0,
            targetDom = amendUtils.getWizDeleteParent(target) || amendUtils.getWizInsertParent(target);

        if (!sel.isCollapsed && targetDom && sel.containsNode(targetDom, true)) {
          //有选择区域， 且 target 在选择区域内
          selectedDoms = sel.isCollapsed ? null : amendUtils.getAmendDoms({
            selection: true,
            selectAll: false
          });
        }

        //校验选择区域内是否有多个dom
        if (selectedDoms) {
          selectedDoms = selectedDoms.deletedInsertList.concat(selectedDoms.insertList, selectedDoms.deleteList);
          //选择多个修订内容时，不显示详细信息
          if (selectedDoms.length === 0) {
            selectedDoms = null;
            //} else if (selectedDoms.length == 1) {
            //    targetDom = selectedDoms[0];
            //    selectedDoms = null;
          }
        }
        var fontSize = void 0;
        if (selectedDoms || targetDom) {
          fontSize = parseInt(env.win.getComputedStyle(targetDom)['font-size']);
          if (isNaN(fontSize)) {
            fontSize = 14;
          }
          scroll = domUtils.getPageScroll();
          pos.left = eventClient.x + scroll.left;
          pos.top = eventClient.y + scroll.top - fontSize;
          if (pos.top < targetDom.offsetTop) {
            pos.top = targetDom.offsetTop;
          }
          _this.show(selectedDoms || targetDom, pos);
        } else {
          _this.hide(false);
        }
      },
      onTouchstart: function onTouchstart(e) {
        //console.log('onTouchstart....')
        var target = e.target,
            isInfo = _this.isInfo(target);
        if (isInfo) {
          return;
        }
        _this.hide(false);
      },
      onRefuse: function onRefuse(e) {
        if (callback.onRefuse) {
          callback.onRefuse(getCallbackParams());
        }
        _this.hide(true);
        amendUserAction.save(amendUserAction.ActionId.ClickRefuseFromAmendInfo);
      }
    }
  };

  /**
   * 创建 修订信息 图层
   */
  var createAmendInfo = function createAmendInfo() {
    var mask = env.body.querySelector('#' + CONST.ID.AMEND_INFO),
        container = void 0;
    domUtils.remove(mask);

    mask = env.doc.createElement('div');
    container = env.doc.createElement('div');
    domUtils.setContenteditable(container, false);
    mask.appendChild(container);
    mask.id = CONST.ID.AMEND_INFO;
    domUtils.css(mask, {
      'position': 'absolute',
      'z-index': CONST.CSS.Z_INDEX.amendInfo,
      'display': 'none',
      'padding': '6px',
      'font-family': '"Microsoft Yahei","微软雅黑",Helvetica,SimSun,SimHei'
    });
    container.innerHTML = getInfoTemplate();

    domUtils.css(container, {
      'background-color': 'white',
      'padding': '0px',
      'font-size': '12px',
      'border': '1px solid #D8D8D8',
      '-webkit-border-radius': '4px',
      '-moz-border-radius': '4px',
      '-border-radius': '4px',
      '-webkit-box-shadow': 'rgba(0, 0, 0, 0.24) 0px 3px 3px',
      '-moz-box-shadow': 'rgba(0, 0, 0, 0.24) 0px 3px 3px',
      'box-shadow': 'rgba(0, 0, 0, 0.24) 0px 3px 3px',
      'min-width': '160px',
      'max-width': '280px',
      'min-height': '50px'
    });

    _this.template.appendChild(mask);

    return mask;
  };
  var getInfoTemplate = function getInfoTemplate() {
    if (env.client.type.isIOS || env.client.type.isMac || env.client.type.isAndroid) {
      return '<div id="' + CONST.ID.AMEND_INFO_SINGLE + '" style="display:none; padding: 8px 16px;">' + '<img id="' + CONST.ID.AMEND_INFO_IMG + '" class="' + CONST.CLASS.IMG_NOT_DRAG + '" style="width: 40px; height: 40px !important; position: absolute; -webkit-border-radius: 40px;-moz-border-radius:40px;border-radius:40px;">' + '<ul style="list-style-type: none;margin: 4px 0 0 50px;padding-left: 0;"><li style="line-height: 18px;white-space: nowrap;padding: 2px 0;">' + '<span id="' + CONST.ID.AMEND_INFO_NAME + '" style="color:#000;font-size:12px;font-weight:bold;max-width:90px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:inline-block;"></span>' + '<span id="' + CONST.ID.AMEND_INFO_CONTENT + '" style="color:#000;font-size:12px;margin-left:.5em;display:inline-block;overflow:hidden;float:right"></span>' + '</li><li style="line-height: 18px;text-align: right;">' + '<span id="' + CONST.ID.AMEND_INFO_TIME + '" style="color:#A3A3A3;font-size:12px;"></span></li></ul>' + '</div>' + '<div id="' + CONST.ID.AMEND_INFO_MULTI + '" style="display:none; padding: 8px 16px;">' + '<p style="margin: 4px 16px;">' + lang.Amend.MultiInfo + '</p>' + '</div>' + '<div id="' + CONST.ID.AMEND_INFO_TOOLS + '" style="padding:0;margin:0;box-sizing: border-box;">' + '<div style="line-height: 26px;width: 50%;display:inline-block;text-align: center;padding:0 8px;margin:0;box-sizing: border-box;">' + '<a id="' + CONST.ID.AMEND_INFO_REFUSE + '" href="javascript:void(0);" style="font-size:12px;display:block;cursor:pointer;color:#447BD8;text-decoration: blink;">' + lang.Amend.BtnRefuse + '</a></div>' + '<div style="line-height: 26px;width: 50%;display:inline-block;text-align: center;padding:0 8px;margin:0;box-sizing: border-box;">' + '<a id="' + CONST.ID.AMEND_INFO_ACCEPT + '" href="javascript:void(0);" style="font-size:12px;display:block;cursor:pointer;color:#447BD8;text-decoration: blink;">' + lang.Amend.BtnAccept + '</a></div>' + '</div>';
    }

    //if (env.client.type.isWeb || env.client.type.isWin) {
    return '<div id="' + CONST.ID.AMEND_INFO_SINGLE + '" style="display:none; padding: 8px 16px;">' + '<img id="' + CONST.ID.AMEND_INFO_IMG + '" class="' + CONST.CLASS.IMG_NOT_DRAG + '" style="width: 40px; height: 40px !important; position: absolute;">' + '<ul style="list-style-type: none;margin: 4px 0 0 50px;padding-left: 0;"><li style="line-height: 18px;white-space: nowrap;padding: 2px 0;">' + '<span id="' + CONST.ID.AMEND_INFO_NAME + '" style="color:#000;font-size:12px;font-weight:bold;max-width:90px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:inline-block;"></span>' + '<span id="' + CONST.ID.AMEND_INFO_CONTENT + '" style="color:#000;font-size:12px;margin-left:.5em;display:inline-block;overflow:hidden;float:right"></span>' + '</li><li style="line-height: 18px;text-align: right;">' + '<span id="' + CONST.ID.AMEND_INFO_TIME + '" style="color:#A3A3A3;font-size:12px;"></span></li></ul>' + '</div>' + '<div id="' + CONST.ID.AMEND_INFO_MULTI + '" style="display:none; padding: 8px 16px;">' + '<p style="margin: 4px 16px;">' + lang.Amend.MultiInfo + '</p>' + '</div>' + '<div id="' + CONST.ID.AMEND_INFO_TOOLS + '" style="padding:0;margin:0;box-sizing:border-box;border-top:1px solid #D8D8D8">' + '<div style="line-height: 26px;width: 50%;display:inline-block;text-align: center;padding:0 8px;margin:0;box-sizing: border-box;border-right: 1px solid #D8D8D8">' + '<a id="' + CONST.ID.AMEND_INFO_ACCEPT + '" href="javascript:void(0);" style="font-size:12px;display:block;cursor:pointer;color:#447BD8;text-decoration: blink;">' + lang.Amend.BtnAccept + '</a></div>' + '<div style="line-height: 26px;width: 50%;display:inline-block;text-align: center;padding:0 8px;margin:0;box-sizing: border-box;">' + '<a id="' + CONST.ID.AMEND_INFO_REFUSE + '" href="javascript:void(0);" style="font-size:12px;display:block;cursor:pointer;color:#447BD8;text-decoration: blink;">' + lang.Amend.BtnRefuse + '</a></div>' + '</div>';
    //}

  };
  var getCallbackParams = function getCallbackParams() {
    return {
      dom: _this.cur,
      isSelection: !!_this.isSelection
    };
  };
  var hideInfo = function hideInfo() {
    if (_this.main) {
      _event.unbindInfoBtn();
      _this.cur = null;
      _this.curPos = null;
      _this.isMulti = false;
      _this.isSelection = false;
      _this.img.src = '';
      _this.name.innerText = '';
      domUtils.attr(_this.name, { title: '' });
      _this.content.innerText = '';
      domUtils.css(_this.main, {
        'display': 'none'
      });
      _this.template.appendChild(_this.main);
    }
  };
  var initMultiInfo = function initMultiInfo(pos) {
    _this.curPos = pos;
    _this.singleUser.style.display = 'none';
    _this.multiUser.style.display = 'block';
  };
  var initUserInfo = function initUserInfo(pos) {
    var dom = _this.cur,
        guid = dom.getAttribute(CONST.ATTR.SPAN_USERID),
        user = amendUser.getUserByGuid(guid),
        name = user ? user.name : lang.Amend.UserNameDefault,
        time = dom.getAttribute(CONST.ATTR.SPAN_TIMESTAMP),
        isDelete = !!dom.getAttribute(CONST.ATTR.SPAN_DELETE);
    time = time.substring(0, time.length - 3);

    _this.curPos = pos;
    _this.img.src = user ? user.imgUrl : '';
    _this.name.innerText = name;
    domUtils.attr(_this.name, { title: name });
    _this.content.innerText = isDelete ? lang.Amend.Delete : lang.Amend.Edit;
    _this.time.innerText = time;

    _this.multiUser.style.display = 'none';
    _this.singleUser.style.display = 'block';
  };
  /**
   * 删除 修订信息 图层
   */
  var removeAmendInfo = function removeAmendInfo() {
    domUtils.remove(env.body.querySelector('#' + CONST.ID.AMEND_INFO));
  };
  var showInfo = function showInfo(pos) {
    if (_this.main.parentNode === _this.template) {
      env.body.appendChild(_this.main);
      _this.singleUser = env.body.querySelector('#' + CONST.ID.AMEND_INFO_SINGLE);
      _this.multiUser = env.body.querySelector('#' + CONST.ID.AMEND_INFO_MULTI);
      _this.img = env.body.querySelector('#' + CONST.ID.AMEND_INFO_IMG);
      _this.name = env.body.querySelector('#' + CONST.ID.AMEND_INFO_NAME);
      _this.content = env.body.querySelector('#' + CONST.ID.AMEND_INFO_CONTENT);
      _this.time = env.body.querySelector('#' + CONST.ID.AMEND_INFO_TIME);
      _this.tools = env.body.querySelector('#' + CONST.ID.AMEND_INFO_TOOLS);
      _this.btnAccept = env.body.querySelector('#' + CONST.ID.AMEND_INFO_ACCEPT);
      _this.btnRefuse = env.body.querySelector('#' + CONST.ID.AMEND_INFO_REFUSE);
    }

    if (_this.cur) {
      initUserInfo(pos);
    } else {
      initMultiInfo(pos);
    }

    _event.bindInfoBtn();

    if (_this.readonly) {
      _this.tools.style.display = 'none';
    } else {
      _this.tools.style.display = 'block';
    }

    domUtils.css(_this.main, {
      'top': '0px',
      'left': '0px',
      'display': 'block',
      'visibility': 'hidden'
    });
    domUtils.setLayout({
      layerObj: _this.main,
      target: pos,
      layout: CONST.TYPE.POS.upLeft,
      fixed: false,
      noSpace: false,
      reverse: true
      //reverse: !env.client.type.isPhone
    });
    domUtils.css(_this.main, {
      'display': 'block',
      'visibility': 'visible'
    });
  };

  this.btnAccept = null;
  this.btnRefuse = null;
  this.content = null;
  this.cur = null;
  this.curPos = null;
  this.img = null;
  this.isMulti = false;
  this.isSelection = false;
  this.main = null;
  this.name = null;
  this.template = null;
  this.time = null;

  /**
   * 隐藏 修订信息
   */
  this.hide = function (quick) {
    clearTimeout(_this.showTimer);
    clearTimeout(_this.hideTimer);
    if (!_this.cur && !_this.isMulti) {
      return;
    }

    if (quick) {
      hideInfo();
    } else {
      _this.hideTimer = setTimeout(hideInfo, CONST.AMEND.INFO_TIMER);
    }
  };
  /**
   * 修订信息 显示图层 初始化
   * options  {readonly: boolean,  cb: {onAccept: function, onRefuse: function}}
   */
  this.init = function (options, cb) {
    _this.template = env.doc.createElement('div');
    _this.main = createAmendInfo();
    _this.readonly = !!(options && options.readonly);

    domUtils.setContenteditable(_this.main, false);

    if (cb && cb.onAccept) {
      callback.onAccept = cb.onAccept;
    }
    if (cb && cb.onRefuse) {
      callback.onRefuse = cb.onRefuse;
    }
    _event.unbind();
    _event.bind();
  };
  /**
   * 判断 dom 是否 amendInfo layer 内的元素（包括layer）
   */
  this.isInfo = function (dom) {
    var amendInfoMain = domUtils.getParentByFilter(dom, function (node) {
      return node === _this.main;
    }, true);
    return !!amendInfoMain;
  };

  /**
   * 删除 修订信息 图层
   */
  this.remove = function () {
    _event.unbind();
    removeAmendInfo();
    _this.main = null;
    _this.img = null;
    _this.name = null;
    _this.content = null;
    _this.time = null;
    _this.btnAccept = null;
    _this.btnRefuse = null;
  };

  /**
   * 显示 修订信息
   */
  this.show = function (dom, pos) {
    clearTimeout(_this.showTimer);
    clearTimeout(_this.hideTimer);

    var isSelection = utils.isArray(dom);
    var isMulti = isSelection && dom.length > 1;
    var cur = !isSelection ? dom : isMulti ? null : dom[0];
    var showFlag = false;

    _this.isSelection = isSelection;
    if (_this.isMulti !== isMulti || cur !== _this.cur) {

      //移动到不同的 dom 时，立刻隐藏当前标签， 等待固定时间后再显示信息
      _this.hide(true);

      showFlag = true;
    } else if (!_this.curPos || Math.abs(_this.curPos.left - pos.left) > 75 || Math.abs(_this.curPos.top - pos.top) > 24) {
      //在同一个 dom 内移动距离较远后， 更换信息图层位置
      showFlag = true;
    }

    if (showFlag) {
      _this.showTimer = setTimeout(function () {
        _this.isMulti = isMulti;
        _this.cur = cur;
        showInfo(pos);
      }, CONST.AMEND.INFO_TIMER * 2);
    }
  };
  /**
   * 恢复 info 的显示
   */
  this.start = function () {
    pause = false;
  };
  /**
   * 暂停 info 的显示
   */
  this.stop = function () {
    _this.hide(true);
    pause = true;
  };
};

module.exports = AmendInfo;

},{"../../config/const":388,"../../libs/utils":400}],357:[function(require,module,exports){
'use strict';

/**
 * 用于记录 当前操作者的信息
 */

var CONST = require('../../config/const');
var DefaultImg = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAExUlEQVRYR9WZz08bRxTHvya1CHbUSHXCiZzCIaaBBOUUEveQSORWYwwRxRCpqtIqjZL8XQkEUppAbQMX6hgh5UetRiFV4MABQXoK2AgUx1vNzs7u7Hpmf3m3Vc3Blm2Gz/vOd95784goiqLgf/aIhAVdrVaxu7sLKomC7u7uwKQJBPrFi5eoVvfx6VMdZONOnIhjf78KBQoINQEnrwcuD+DkyS9bhvcNfXR0hFKppEKqWqp8BE0l1N7XgPXvKOjq6kJfX29L4L6hCfDh4aEnYBbQjRuD+PhxD4nEV77gfUEvLy/rXm1S2GIJQ3VtJ9TdoFtDfuKxOK5fv+YJ3jM0BfZmCd4y5tcUPp3+Njzo1dVV1Go1X5Yw+Z1oTOLWVI91HMfg4KBrcE9KLy0tq+mrVUvwwGSxzs5ODAxcDgt6yXWWcLIEVd5QezgzFA704iKBdk5rQmCLJdRzwYEPD2fCgS4WF408LMkSooOmhsl5mBYcTmlFQTY7HA50oVi0LRxeLcHDj4QGXShKK50jsGpfsyWY2uR5dCQbjtL5QsHUSzgVDidL8AcxNOiVlRXUagdccTEfSqGfLVmCt4RRpBTcHB0JR+lS6Tn29va04iIBdsgSvCVoxlMQ/SKKTCYdPPT29jb+qFSEB5HvJbxYgnqctq2958+jpyfpCtx1RVxY+M1eYUsKYyrqAWmf85ZgwAx+bOxm8ND0D4rLOK+wXZbQg+F6bALfQAOj2Syi0agjuGul5+cXTA1+EJbg7UFeZ4bS6OjoCA762fy87udWsoTMHkT43PiYIzD5gmul19bW8OHD36Yy7tUSVg/T8q6VeCjIjX8XLDRZ/OkzojZNdX6zhNUSzOPEGrFYLFhotlpxcQkHBwdaZTS3l7LCYWeJeDyGoTBvLgy8XC5jl1jFppeQZQm/luC3wLWn+V9qNBqYm/u1qb3kewmZDXjVe5JJ9PdfdGWJlqHJAk9+mQOBl1nC6dCRTZrIuTt41qh8Kc0WmZmZ1dXmFbTzMCtOly71I3nunGeVPaU80eo7Ozv4vfRcvzY1WULrK8wBqW7HRG7cF3DL0GSBqenHRk9iKc3WQ8eGka0ABwZtpzADNZ4VTE7kfKscCPSjqWm9vZRnDGoJVv1uTf7H0A8fTen24DOGSGH23q3JiX9f6Xq9jnfv/sKfb954BmbTqYsX+nDmTBcSiYTnAFynvK2tLZDhef3zZ60S0huHLNXxHrZTnXwWiUTQffYsUqkrrgKQQpMLbD6fF+ZhN4WD9zB/cTC/ZsN3YwysN1CZNE6fOiUMwgT99u061tfXjRmb4IrkpnCIgOVBNAObdg/A1z1JfJO6qgegQ5fLqyDFwnqnY/M2L4WD75GZh5nCIqWlFqOyq7sdaWvDnZ9uq+A69Ozsk1AUtt4rhd2fNkpg4wWzULT9JZ/d/uF7tLe3U+iNjU1tPGAMBu1uzbJKZ1W4FUuIhpQX+nqRSl2l0O/fb6BSqZhbTX32xmUJm14iVGCN5VjbMfx850cK/erVa2xuburb4LaBl6U1mSVE6zpZwphhE4s0cP/eXQqdzxewX61Kcy6bS9ComPLm0ixKa34PXXMyoMDkoUNPP56Rt5fcITGUEgMH6mGLPdl/fh/cv4t/ANultPKz243RAAAAAElFTkSuQmCC';

var AmendUser = function AmendUser() {
  var core = null;
  var env = null;
  var domUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
  };

  var addUser = function addUser(user) {
    //如果已经存在，则替换数据
    users[user.guid] = user;
    usersForSave[user.guid] = {
      color: user.color,
      name: user.name
    };
  };
  /**
   * 根据 user 信息生成 修订颜色
   */
  var createUserColor = function createUserColor(user) {
    var userKey = user.hash,
        colorCount = CONST.COLOR.length,
        tmpColors = {};

    loadUsers();
    //如果该用户已有修订记录，直接使用
    if (users[userKey]) {
      return users[userKey].color;
    }

    //初始化 颜色列表，确认哪些颜色已被使用
    for (var i in users) {
      if (users.hasOwnProperty(i)) {
        var c = users[i].color;
        tmpColors[c] = true;
      }
    }

    for (var _i = 0; _i < colorCount; _i++) {
      var _c = CONST.COLOR[_i];
      if (!tmpColors[_c]) {
        return _c;
      }
    }
    //如果所有颜色都被使用， 则直接使用第一种颜色
    return CONST.COLOR[0];
  };
  var createUserDom = function createUserDom() {
    userDom = env.doc.createElement('meta');
    userDom.id = CONST.ID.AMEND_USER_INFO;
    userDom.name = CONST.ID.AMEND_USER_INFO;
    env.doc.getElementsByTagName('HEAD')[0].insertBefore(userDom, null);
  };
  var getHash = function getHash(guid) {
    //hash = util.getHash(userInfo.user_guid);
    //hash = '_w' + hash;
    return guid;
  };
  var getImgUrl = function getImgUrl(guid) {
    if (env.client.type.isWeb) {
      return '/as/user/avatar/' + guid + '?default=true&_' + new Date().valueOf();
    } else if (env.client.type.isWin) {
      try {
        var avatarFileName = external.GetAvatarByUserGUID(guid);
        return avatarFileName ? avatarFileName : DefaultImg;
      } catch (e) {
        console.error(e);
      }
    } else if (env.client.type.isMac) {} else if (env.client.type.isIOS) {} else if (env.client.type.isAndroid) {}

    return DefaultImg;
  };
  var getUserDom = function getUserDom() {
    if (userDom) {
      return userDom;
    }
    userDom = env.doc.getElementById(CONST.ID.AMEND_USER_INFO);
    return userDom;
  };
  /**
   * 从客户端根据 guid 获取最新的用户昵称， 保证显示最新的用户昵称
   */
  var getUserNameFromClient = function getUserNameFromClient(guid) {
    if (env.client.type.isWeb) {} else if (env.client.type.isWin) {
      try {
        return external.GetAliasByUserGUID(guid);
      } catch (e) {
        console.error(e);
      }
    } else if (env.client.type.isMac) {} else if (env.client.type.isIOS) {} else if (env.client.type.isAndroid) {}

    return null;
  };
  var loadUsers = function loadUsers() {
    if (users) {
      return;
    }
    users = {};
    usersForSave = {};

    userDom = getUserDom();
    if (!userDom) {
      return;
    }

    try {
      //根据已有数据获取曾经修订过的用户信息
      usersForSave = JSON.parse(userDom.content);

      for (var i in usersForSave) {
        if (usersForSave.hasOwnProperty(i)) {
          var u = usersForSave[i];
          u.user_guid = i;
          var tmpName = getUserNameFromClient(i);
          if (tmpName) {
            u.user_name = tmpName;
          } else {
            u.user_name = u.name;
          }

          users[i] = new AmendUserClass(u);
        }
      }
    } catch (e) {}
  };
  var saveUser = function saveUser() {
    if (!userDom) {
      createUserDom();
    }
    userDom.content = JSON.stringify(usersForSave);
  };

  var AmendUserClass = function AmendUserClass(userInfo) {
    if (!userInfo) {
      userInfo = {};
    }
    this.guid = userInfo.user_guid || '';
    this.hash = getHash(this.guid);
    this.name = userInfo.user_name || '';
    this.imgUrl = userInfo.img_url ? userInfo.img_url : getImgUrl(this.guid);
    this.color = userInfo.color || createUserColor(this);
  };

  var curAmendUser = null;
  var userDom = null;
  var users = null; //用户 AmendUserClass 对象集合，用于 修订功能
  var usersForSave = null; //用户 保存数据，用于保存到 meta 内


  this.initUser = function () {
    //初始化用户信息， 保证第一个修订用户的信息能被正常保存
    loadUsers();

    var userInfo = env.options.userInfo;
    if (!userInfo) {
      return null;
    }

    curAmendUser = new AmendUserClass(userInfo);
    addUser(curAmendUser);
  };

  this.getCurUser = function () {
    saveUser();
    return curAmendUser;
  };
  this.getUserByGuid = function (guid) {
    if (curAmendUser && guid === curAmendUser.guid) {
      return curAmendUser;
    }
    if (users && users[guid]) {
      return users[guid];
    }
    loadUsers();
    return users[guid];
  };
  // /**
  //  * 删除 修订颜色数据（用于确认修订）
  //  */
  // this.removeAllUserInfo = () => {
  //     var d = env.doc.getElementById(CONST.ID.AMEND_USER_INFO);
  //     domUtils.remove(d);
  //
  //     userDom = null;
  //     users = null;
  //     usersForSave = null;
  // };
  this.setUsersData = function () {
    var _usersData = env.options.usersData;
    if (!_usersData) {
      return;
    }
    for (var i = 0, j = _usersData.length; i < j; i++) {
      var u = _usersData[i];
      var u1 = users[u.user_guid];
      var u2 = usersForSave[u.user_guid];
      if (u1 && u.user_name) {
        u1.name = u.user_name;
      }
      if (u1 && u.img_url) {
        u1.imgUrl = u.img_url;
      }
      if (u2 && u.user_name) {
        u2.name = u.user_name;
      }
    }
  };
};

module.exports = AmendUser;

},{"../../config/const":388}],358:[function(require,module,exports){
'use strict';

/**
 * 专门用于记录用户行为的 log
 */

var ActionId = {
  ClickAcceptFromAmendInfo: 'ClickAcceptFromAmendInfo',
  ClickRefuseFromAmendInfo: 'ClickRefuseFromAmendInfo'
};

var AmendUserAction = function AmendUserAction() {
  var core = null;
  var env = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
  };

  var userAction = {
    save: function save(id) {
      if (env.client.type.isWin) {
        try {
          if (external && external.LogAction) {
            external.LogAction(id);
          }
        } catch (e) {
          console.error(e.toString());
        }
      }
    }
  };

  this.ActionId = ActionId;
  this.save = userAction.save;
};

module.exports = AmendUserAction;

},{}],359:[function(require,module,exports){
'use strict';

/**
 * amend 中通用的基本方法集合（基础操作，以读取为主）
 *
 */
var CONST = require('../../config/const');
var utils = require('../../libs/utils');

var AmendUtils = function AmendUtils() {
  var _this = this;

  var core = null;
  var env = null;
  var amendUser = null;
  var commandExtend = null;
  var domUtils = null;
  var rangeUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    amendUser = core.require.amendUser;
    commandExtend = core.require.commandExtend;
    domUtils = core.require.domUtils;
    rangeUtils = core.require.rangeUtils;
  };

  /**
   * 添加 dom 到 getSelectedAmendDoms 或 getAmendDoms 方法得到的数据
   */
  this.add2SelectedAmendDoms = function (amendDoms, dom) {
    if (!dom) {
      return;
    }
    if (dom.getAttribute(CONST.ATTR.SPAN_INSERT) && dom.getAttribute(CONST.ATTR.SPAN_DELETE)) {
      amendDoms.deletedInsertList.push(dom);
    } else if (dom.getAttribute(CONST.ATTR.SPAN_INSERT)) {
      amendDoms.insertList.push(dom);
    } else if (dom.getAttribute(CONST.ATTR.SPAN_DELETE)) {
      amendDoms.deleteList.push(dom);
    }
  };
  /**
   * 创建用于 修订内容中 封装 img 的 span
   */
  this.createDomForImg = function (type, user) {
    var tmp = env.doc.createElement('span');
    _this.setDefaultAttr(tmp, user);
    var attr = {};
    attr[CONST.ATTR.IMG] = '1';
    if (type === CONST.TYPE.IMG_DELETE) {
      attr[CONST.ATTR.SPAN_INSERT] = null;
      attr[CONST.ATTR.SPAN_DELETE] = user.hash;
    }
    domUtils.attr(tmp, attr);
    _this.setUserImgContainerStyle(tmp);

    return tmp;
  };
  /**
   * 创建用于 新建内容的 span
   */
  this.createDomForInsert = function (user) {
    var tmp = env.doc.createElement('span');
    _this.setDefaultAttr(tmp, user);
    _this.setUserInsertStyle(tmp, user);
    tmp.innerHTML = CONST.FILL_CHAR;
    return tmp;
  };
  /**
   * 创建用于 反转修订时 新建内容的 span
   */
  this.createDomForReverse = function () {
    var tmp = env.doc.createElement('span');
    tmp.innerHTML = CONST.FILL_CHAR;
    return tmp;
  };
  /**
   * 创建 用于粘贴的 span
   */
  this.createDomForPaste = function (id) {
    var start = void 0,
        content = void 0,
        end = void 0,
        attr = void 0;
    start = domUtils.createSpan();
    attr = {};
    attr[CONST.ATTR.SPAN_PASTE_TYPE] = CONST.TYPE.PASTE.START;
    attr[CONST.ATTR.SPAN_PASTE_ID] = id;
    domUtils.attr(start, attr);
    start.innerHTML = CONST.FILL_CHAR;

    content = domUtils.createSpan();
    attr = {};
    attr[CONST.ATTR.SPAN_PASTE_TYPE] = CONST.TYPE.PASTE.CONTENT;
    attr[CONST.ATTR.SPAN_PASTE_ID] = id;
    domUtils.attr(content, attr);
    content.innerHTML = CONST.FILL_CHAR + CONST.FILL_CHAR;

    end = domUtils.createSpan();
    attr = {};
    attr[CONST.ATTR.SPAN_PASTE_TYPE] = CONST.TYPE.PASTE.END;
    attr[CONST.ATTR.SPAN_PASTE_ID] = id;
    domUtils.attr(end, attr);
    end.innerHTML = CONST.FILL_CHAR;
    return {
      start: start,
      content: content,
      end: end
    };
  };
  /**
   * 标记 删除的 img
   */
  this.deleteImg = function (img, user) {
    //必须首先判断 img 是否为已已标记修订的 img span 内
    var imgSpan = _this.getWizAmendImgParent(img),
        mask = void 0;
    if (imgSpan) {
      //如果是已删除的， 则直接忽略
      //如果不是，则直接给 img span 添加 删除标识
      if (!imgSpan.getAttribute(CONST.ATTR.SPAN_DELETE)) {
        var attr = {};
        attr[CONST.ATTR.SPAN_USERID] = user.hash;
        attr[CONST.ATTR.SPAN_DELETE] = user.hash;
        domUtils.attr(imgSpan, attr);
        mask = imgSpan.querySelector('img[' + CONST.ATTR.IMG_MASK + ']');
        domUtils.css(mask, CONST.CSS.IMG.MASK);
        domUtils.css(mask, CONST.CSS.IMG_DELETED);
      }
      return;
    }

    //因为 删除img 时，是在 img 外面封装span ，破坏了 range 的范围，
    // 所以如果 img 是在 range 的边缘时必须要修正
    var rangeEdge = rangeUtils.isRangeEdge(img);
    var nSpan = _this.packageImg(img, CONST.TYPE.IMG_DELETE, user);

    if (rangeEdge.isStart) {
      rangeEdge.startDom = nSpan;
      rangeEdge.startOffset = 0;
    }
    if (rangeEdge.isEnd) {
      rangeEdge.endDom = nSpan.parentNode;
      rangeEdge.endOffset = domUtils.getIndex(nSpan) + 1;
    }

    if (rangeEdge.isCollapsed && rangeEdge.isStart) {
      rangeUtils.setRange(rangeEdge.startDom, domUtils.getEndOffset(rangeEdge.startDom), null, null);
    } else if (!rangeEdge.isCollapsed && (rangeEdge.isStart || rangeEdge.isEnd)) {
      rangeUtils.setRange(rangeEdge.startDom, rangeEdge.startOffset, rangeEdge.endDom, rangeEdge.endOffset);
    }
  };

  /**
   * 根据 修订Dom 处理 Range 范围 （主要是 img 处于 Range 边缘时）
   * @returns null or {{startImg: *, endImg: *, startDom: Node, startOffset: Number, endDom: Node, endOffset: Number, leftDom: *, rightDom: *}}
   */
  this.fixedAmendRange = function () {
    var range = rangeUtils.getRange();
    if (!range) {
      return null;
    }
    var startDom = range.startContainer,
        endDom = range.endContainer,
        startOffset = range.startOffset,
        endOffset = range.endOffset;

    //判断光标范围， 光标编辑区边界如果是 修订的 img 必须要把 img 全部选中
    var leftDom = void 0,
        rightDom = void 0,
        startInnerDom = void 0,
        endInnerDom = void 0,
        startImg = void 0,
        endImg = void 0;
    if (range && range.collapsed) {
      rightDom = rangeUtils.getRangeAnchor(false);
      //如果光标在某个 textNode 中间， 则前后都是当前这个 textNode
      if (endDom.nodeType === 3 && endOffset > 0 && endOffset < endDom.nodeValue.length) {
        leftDom = rightDom;
      } else {
        leftDom = domUtils.getPreviousNode(rightDom, false, null);
      }
    } else {
      startInnerDom = rangeUtils.getRangeAnchor(true);
      endInnerDom = rangeUtils.getRangeAnchor(false);
      startImg = _this.getWizAmendImgParent(startInnerDom);
      endImg = _this.getWizAmendImgParent(endInnerDom);

      if (startImg) {
        startDom = startImg;
        startOffset = 0;
      }
      if (endImg) {
        endDom = endImg;
        endOffset = endImg.childNodes.length;
      }
      if (startImg || endImg) {
        rangeUtils.setRange(startDom, startOffset, endDom, endOffset);
      }
    }

    return {
      startImg: startImg,
      endImg: endImg,
      startDom: startDom,
      startOffset: startOffset,
      endDom: endDom,
      endOffset: endOffset,
      leftDom: leftDom,
      rightDom: rightDom
    };
  };
  /**
   * 修正 删除图片操作后的 光标位置（用于修订）
   */
  this.fixSelectionByDeleteImg = function () {
    var range = rangeUtils.getRange(),
        startDom = void 0,
        endDom = void 0,
        startOffset = void 0,
        endOffset = void 0,
        isDeleteImgStart = false,
        isDeleteImgEnd = false;

    if (!range) {
      return;
    }

    //判断 startDom 是否处于已删除的 img span 内
    startDom = _this.getWizAmendImgParent(range.startContainer);
    if (startDom && !startDom.getAttribute(CONST.ATTR.SPAN_DELETE)) {
      startDom = null;
    }
    if (!startDom) {
      startDom = range.startContainer;
      startOffset = range.startOffset;
    } else {
      isDeleteImgStart = true;
      startOffset = 0;
    }

    if (!range.collapsed) {
      endDom = _this.getWizAmendImgParent(range.endContainer);
      if (!endDom) {
        endDom = range.endContainer;
        endOffset = range.endOffset;
      } else {
        isDeleteImgEnd = true;
      }
    } else {
      endDom = startDom;
      isDeleteImgEnd = isDeleteImgStart;
    }

    if (isDeleteImgEnd && endDom && endDom.nextSibling) {
      endOffset = 0;
      endDom = endDom.nextSibling;
    } else if (isDeleteImgEnd && endDom) {
      endOffset = domUtils.getIndex(endDom) + 1;
      endDom = endDom.parentNode;
    } else {
      endOffset = range.endOffset;
    }

    if (range.collapsed) {
      rangeUtils.setRange(endDom, endOffset);
    } else {
      rangeUtils.setRange(startDom, startOffset, endDom, endOffset);
    }
  };

  /**
   * 根据条件 获取 修订的 dom 集合
   * @param options  {{[selection]: Boolean, [domList]: Array, [selectAll]: Boolean}}
   * @returns {{insertList: Array, deleteList: Array, deletedInsertList: Array}}
   */
  this.getAmendDoms = function (options) {
    var insertAttr = {},
        deleteAttr = {},
        result = {
      insertList: [],
      deleteList: [],
      deletedInsertList: []
    },
        tmp = [];
    if (options.selection) {
      insertAttr[CONST.ATTR.SPAN_INSERT] = '';
      result.insertList = _this.getWizSpanFromRange(options.selectAll, insertAttr);
      //清理出 删除&新增内容
      result.deletedInsertList = domUtils.removeListFilter(result.insertList, function (dom) {
        return dom.getAttribute(CONST.ATTR.SPAN_DELETE);
      });
      deleteAttr[CONST.ATTR.SPAN_DELETE] = '';
      result.deleteList = _this.getWizSpanFromRange(options.selectAll, deleteAttr);
      //清理出 删除&新增内容
      tmp = domUtils.removeListFilter(result.deleteList, function (dom) {
        return dom.getAttribute(CONST.ATTR.SPAN_INSERT);
      });
      //合并从 insert & delete 集合中 清理出来的 删除&新增内容
      result.deletedInsertList = utils.removeDup(result.deletedInsertList.concat(tmp));
    } else {
      for (var i = 0, j = options.domList.length; i < j; i++) {
        var d = options.domList[i];
        if (d.getAttribute(CONST.ATTR.SPAN_DELETE) && d.getAttribute(CONST.ATTR.SPAN_INSERT)) {
          result.deletedInsertList.push(d);
        } else if (d.getAttribute(CONST.ATTR.SPAN_DELETE)) {
          result.deleteList.push(d);
        } else if (d.getAttribute(CONST.ATTR.SPAN_INSERT)) {
          result.insertList.push(d);
        }
      }
    }
    return result;
  };
  /**
   * 根据 user 获取删除操作时，需要设置的 style & attr
   */
  this.getDeletedStyle = function (user) {
    var attr = {};
    attr[CONST.ATTR.SPAN_DELETE] = user.hash;
    attr[CONST.ATTR.SPAN_USERID] = user.hash;
    attr[CONST.ATTR.SPAN_TIMESTAMP] = utils.getTime();

    var style = { 'color': user.color, 'text-decoration': 'line-through' };

    return {
      attr: attr,
      style: style
    };
  };
  /**
   * 获取 与目标 连续且时间戳相近的 修订 dom 集合(必须同一用户的操作)
   */
  this.getSameTimeStampDom = function (dom) {
    if (!dom || dom.nodeType !== 1) {
      return [];
    }
    var result = [];

    var getSibling = function getSibling(target, isPrev) {
      return isPrev ? domUtils.getPreviousNode(target, false, null) : domUtils.getNextNode(target, false, null);
    };
    var getAmendType = function getAmendType(obj) {
      if (obj.getAttribute(CONST.ATTR.SPAN_DELETE) && obj.getAttribute(CONST.ATTR.SPAN_INSERT)) {
        return 1;
      } else if (obj.getAttribute(CONST.ATTR.SPAN_INSERT)) {
        return 2;
      } else if (obj.getAttribute(CONST.ATTR.SPAN_DELETE)) {
        return 3;
      }
      return 0;
    };
    var findWizSibling = function findWizSibling(target, isPrev, result) {
      var wizAmend = void 0,
          tmp = void 0,
          amendTypeTmp = void 0,
          amendType = getAmendType(target),
          time = target.getAttribute(CONST.ATTR.SPAN_TIMESTAMP),
          userId = target.getAttribute(CONST.ATTR.SPAN_USERID);
      if (!time) {
        return;
      }
      var sibling = getSibling(target, isPrev);
      while (sibling) {
        wizAmend = _this.getWizInsertParent(sibling) || _this.getWizDeleteParent(sibling);
        sibling = wizAmend;
        //首先判断是否同一用户
        if (sibling && sibling.getAttribute(CONST.ATTR.SPAN_USERID) !== userId) {
          sibling = null;
        } else if (sibling) {
          tmp = sibling.getAttribute(CONST.ATTR.SPAN_TIMESTAMP);
          amendTypeTmp = getAmendType(sibling);
          //时间相近的算法必须要考虑 删除其他用户新增的情况， 如果目标是（delete & insert）的情况，则相邻的也必须满足
          if (amendType === amendTypeTmp && utils.isSameAmendTime(sibling.getAttribute(CONST.ATTR.SPAN_TIMESTAMP), time)) {
            if (isPrev) {
              result.splice(0, 0, sibling);
            } else {
              result.push(sibling);
            }
            sibling = getSibling(sibling, isPrev);
          } else {
            sibling = null;
          }
        }
      }
    };

    findWizSibling(dom, true, result);
    result.push(dom);
    findWizSibling(dom, false, result);
    return result;
  };
  /**
   * 获取选择范围内 修订 dom 集合
   */
  this.getSelectedAmendDoms = function () {
    var range = rangeUtils.getRange(),
        startDom = void 0,
        endDom = void 0,
        startOffset = void 0,
        endOffset = void 0;

    var amends = _this.getAmendDoms({
      selection: true,
      selectAll: false
    });
    if (!range || amends.insertList.length === 0 && amends.deleteList.length === 0 && amends.deletedInsertList.length === 0) {
      return null;
    }

    if (range.collapsed) {
      //光标折叠状态时，不需要对 span 进行拆分
      return amends;
    }

    var checkStart = function checkStart(list, startDom, startOffset) {
      if (list.length === 0 || startOffset === 0) {
        return null;
      }
      var s = list[0];
      if (s === startDom || domUtils.contains(s, startDom)) {
        list.splice(0, 1);
        return {
          dom: startDom,
          offset: startOffset
        };
      }
      return null;
    };

    var checkEnd = function checkEnd(list, endDom, endOffset) {
      if (list.length === 0) {
        return null;
      }
      var maxLength = endDom.nodeType === 3 ? endDom.length : endDom.childNodes.length;
      if (endOffset === maxLength) {
        return null;
      }
      var e = list[list.length - 1];
      if (e === endDom || domUtils.contains(e, endDom)) {
        list.splice(list.length - 1, 1);
        return {
          dom: endDom,
          offset: endOffset
        };
      }
      return null;
    };

    startDom = range.startContainer;
    startOffset = range.startOffset;
    endDom = range.endContainer;
    endOffset = range.endOffset;

    var start = checkStart(amends.deleteList, startDom, startOffset);
    if (!start) {
      start = checkStart(amends.insertList, startDom, startOffset);
      if (!start) {
        start = checkStart(amends.deletedInsertList, startDom, startOffset);
      }
    }
    var end = {};
    if (endDom === startDom && !!start) {
      end.dom = start.dom;
      end.offset = endOffset;
    } else {
      end = checkEnd(amends.deleteList, endDom, endOffset);
      if (!end) {
        end = checkEnd(amends.insertList, endDom, endOffset);
        if (!end) {
          end = checkEnd(amends.deletedInsertList, endDom, endOffset);
        }
      }
    }

    amends.start = start;
    amends.end = end;

    return amends;
  };
  /**
   * 获取 wiz 编辑操作中 已标注的 Img 父节点
   */
  this.getWizAmendImgParent = function (dom) {
    return domUtils.getParentByFilter(dom, function (node) {
      return node && node.nodeType === 1 && node.getAttribute(CONST.ATTR.IMG);
    }, true);
  };
  /**
   * 获取 wiz 编辑操作中 已标注为编辑的 父节点
   */
  this.getWizAmendParent = function (dom) {
    return domUtils.getParentByFilter(dom, function (node) {
      return node && node.nodeType === 1 && (node.getAttribute(CONST.ATTR.SPAN_INSERT) || node.getAttribute(CONST.ATTR.SPAN_DELETE));
    }, true);
  };
  /**
   * 获取 wiz 编辑操作中 已标注删除的 父节点
   */
  this.getWizDeleteParent = function (dom) {
    return domUtils.getParentByFilter(dom, function (node) {
      return node && node.nodeType === 1 && node.getAttribute(CONST.ATTR.SPAN_DELETE);
    }, true);
  };
  /**
   * 获取 wiz 编辑操作中 已标注新增的 父节点
   */
  this.getWizInsertParent = function (dom) {
    return domUtils.getParentByFilter(dom, function (node) {
      //node.childNodes.length == 0 时，键盘敲入的字符加在 span 外面
      return node && node.nodeType === 1 && node.getAttribute(CONST.ATTR.SPAN_INSERT) && !node.getAttribute(CONST.ATTR.SPAN_DELETE) && node.childNodes.length > 0;
    }, true);
  };
  /**
   * 获取 鼠标选择范围内（Range）满足条件的 Wiz Span
   */
  this.getWizSpanFromRange = function (isAll, options) {
    var exp = 'span';
    if (!options) {
      return [];
    }
    //根据 options 生成 dom 查询表达式
    for (var i in options) {
      if (options.hasOwnProperty(i)) {
        if (options[i]) {
          exp += '[' + i + '="' + options[i] + '"]';
        } else {
          exp += '[' + i + ']';
        }
      }
    }

    /**
     * 查找 attribute 满足 options 的 Dom 节点过滤器
     */
    var spanFilter = function spanFilter(node) {
      if (!node || node.nodeType !== 1) {
        return false;
      }
      for (var _i in options) {
        //option[i] == '' 表示 只看某属性是否存在，但不比较具体的value
        if (options.hasOwnProperty(_i) && (!node.getAttribute(_i) || options[_i] && node.getAttribute(_i) !== options[_i])) {
          return false;
        }
      }
      return true;
    };

    var range = rangeUtils.getRange(),
        startDom = void 0,
        startOffset = void 0,
        endDom = void 0,
        endOffset = void 0,
        startSpan = void 0,
        endSpan = void 0,
        parent = void 0,
        domList = void 0,
        startIndex = void 0,
        endIndex = void 0,
        dIdx = void 0,
        result = [];

    if (isAll) {
      //在 document.body 内进行查找
      var tmp = env.body.querySelectorAll(exp);
      for (var _i2 = 0, j = tmp.length; _i2 < j; _i2++) {
        result.push(tmp[_i2]);
      }
      return result;
    }

    if (!range) {
      return [];
    }

    if (range.collapsed) {
      endDom = rangeUtils.getRangeAnchor(false);
      startDom = domUtils.getPreviousNode(endDom, false, null);

      if (endDom) {
        endDom = domUtils.getParentByFilter(endDom, spanFilter, true);
        if (endDom) {
          result.push(endDom);
        }
      }

      //TODO 对于换行的处理有问题，需要待定，暂时屏蔽
      //if (!endDom && startDom) {
      //    startDom = domUtils.getParentByFilter(startDom, spanFilter, true);
      //    if (startDom) {
      //        result.push(startDom);
      //    }
      //}

      return result;
    }
    startDom = rangeUtils.getRangeAnchor(true);
    endDom = rangeUtils.getRangeAnchor(false);

    if (!startDom || !endDom) {
      return [];
    }

    //获取 startDom, endDom 所在的 WizSpan 节点
    startSpan = domUtils.getParentByFilter(startDom, spanFilter, true);
    endSpan = domUtils.getParentByFilter(endDom, spanFilter, true);
    if (startSpan && startSpan == endSpan) {
      //startDom 和 endDom 所在同一个 WizSpan
      return [startSpan];
    }

    //在 startDom, endDom 共同的 parent 内根据查询表达式 查找 WizSpan
    parent = domUtils.getParentRoot([startDom, endDom]);
    domList = parent.querySelectorAll(exp);
    startIndex = domUtils.getIndexList(startDom);
    endIndex = domUtils.getIndexList(endDom);
    //startDom 是 TextNode 时，其父节点的 index 肯定要小于 startDom， 所以必须强行加入
    if (startSpan) {
      result.push(startSpan);
    }
    //根据 起始节点的 index 数据筛选 在其范围内的 WizSpan
    for (var _i3 = 0, _j = domList.length; _i3 < _j; _i3++) {
      var d = domList[_i3];
      dIdx = domUtils.getIndexList(d);
      if (domUtils.compareIndexList(startIndex, dIdx) <= 0 && domUtils.compareIndexList(endIndex, dIdx) >= 0) {
        result.push(d);
      }
    }
    return result;
  };
  /**
   * 判断 是否为修订编辑的 笔记
   */
  this.isAmendEdited = function () {
    var amendDoms = _this.getAmendDoms({
      selection: true,
      selectAll: true
    });
    return !!amendDoms && (amendDoms.deleteList.length > 0 || amendDoms.insertList.length > 0 || amendDoms.deletedInsertList.length > 0);
  };
  /**
   * 判断 是否为 修订的 dom
   */
  this.isWizAmend = function (dom) {
    return _this.getWizAmendParent(dom);
  };
  /**
   * 判断 是否为 删除内容
   */
  this.isWizDelete = function (dom) {
    return !!_this.getWizDeleteParent(dom);
  };
  /**
   * 判断 是否为 新增内容
   */
  this.isWizInsert = function (dom) {
    return !!_this.getWizInsertParent(dom);
  };

  /**
   * 粘贴后，修改新粘贴的内容样式（设置为当前用户新建内容）
   */
  this.modifyDomForPaste = function (nSpanStart, nSpanEnd, user) {
    if (!nSpanStart || !nSpanEnd) {
      return;
    }

    if (nSpanStart.childNodes.length === 1 && nSpanStart.innerText === CONST.FILL_CHAR) {
      nSpanStart.innerHTML = '';
    }
    if (nSpanEnd.childNodes.length === 1 && nSpanEnd.innerText === CONST.FILL_CHAR) {
      nSpanEnd.innerHTML = '';
    }

    var parent = domUtils.getParentRoot([nSpanStart, nSpanEnd]);
    if (!parent) {
      return;
    }

    var tmpP = void 0,
        tmpD = void 0,
        tmpWizAmend = void 0,
        domResult = void 0,
        domList = void 0;

    domResult = domUtils.getListA2B({
      startDom: nSpanStart,
      startOffset: 0,
      endDom: nSpanEnd,
      endOffset: domUtils.getEndOffset(nSpanEnd)
    });
    domList = domResult.list;
    for (var i = 0, j = domList.length; i < j; i++) {
      var d = domList[i];
      tmpP = d.parentNode;
      tmpWizAmend = _this.getWizAmendParent(d);
      if (!tmpP) {
        continue;
      }
      if (tmpWizAmend) {
        //如果是复制的 修订span ，则直接修改 span 为当前粘贴的用户
        d = tmpWizAmend;
      } else if (d.nodeType === 3) {
        if (utils.isEmpty(d.nodeValue)) {
          continue;
        }
        //粘贴操作后， 如果 PASTE_TYPE = CONTENT 的 span 内有 nodeType != 3 的节点，则不能直接修改 CONTENT 这个 span
        if (domUtils.isWizSpan(tmpP) && tmpP.children.length === 0) {
          d = tmpP;
        } else {
          tmpD = _this.createDomForInsert(user);
          tmpD.innerHTML = '';
          tmpP.insertBefore(tmpD, d);
          tmpD.appendChild(d);
          d = tmpD;
        }
      }

      if (domUtils.isTag(d, 'img')) {
        d = _this.packageImg(d, CONST.TYPE.IMG_INSERT, user);
      } else if (domUtils.isSelfClosingTag(d)) {
        continue;
      }
      _this.setDefaultAttr(d, user);
      _this.setUserInsertStyle(d, user);
    }

    //清理空的临时 span
    if (parent !== env.body && parent !== env.body.parentNode && parent.parentNode) {
      parent = parent.parentNode;
    }
    domList = parent.querySelectorAll('span[' + CONST.ATTR.SPAN_PASTE_TYPE + ']');
    for (var _i4 = 0, _j2 = domList.length; _i4 < _j2; _i4++) {
      var _d = domList[_i4];
      if (_d.childNodes.length === 0) {
        domUtils.remove(_d);
      } else {
        var attr = {};
        attr[CONST.ATTR.SPAN_PASTE_TYPE] = null;
        attr[CONST.ATTR.SPAN_PASTE_ID] = null;
        domUtils.attr(_d, attr);
      }
    }
  };
  /**
   * 封装修订中的 img（用于删除、粘贴的图片）
   */
  this.packageImg = function (img, type, user) {
    //添加元素的顺序不要随便改动， 会影响 selection 光标的位置
    var pNode = void 0,
        nextNode = void 0,
        tmpNode = void 0,
        nSpan = _this.createDomForImg(type, user);
    pNode = img.parentNode;
    nextNode = img.nextSibling;
    while (nextNode && nextNode.nodeType === 3 && nextNode.nodeValue === CONST.FILL_CHAR) {
      tmpNode = nextNode;
      nextNode = nextNode.nextSibling;
      domUtils.remove(tmpNode);
    }
    nSpan.appendChild(img);
    //添加遮罩
    var mask = env.doc.createElement('img');
    mask.className += CONST.CLASS.IMG_NOT_DRAG;
    var attr = {};
    attr[CONST.ATTR.IMG_MASK] = '1';
    domUtils.attr(mask, attr);
    //手机客户端有的情况下会设置 img max-width = 80%
    if (img.style.maxWidth) {
      mask.style.maxWidth = img.style.maxWidth;
    }
    if (img.style.maxHeight) {
      mask.style.maxHeight = img.style.maxHeight;
    }
    if (img.style.width) {
      mask.style.width = img.style.width;
    }
    if (img.style.height) {
      mask.style.height = img.style.height;
    }
    domUtils.css(mask, CONST.CSS.IMG.MASK);
    if (type === CONST.TYPE.IMG_DELETE) {
      domUtils.css(mask, CONST.CSS.IMG_DELETED);
    } else {
      domUtils.css(mask, CONST.CSS.IMG_INSERT);
    }
    nSpan.appendChild(mask);
    pNode.insertBefore(nSpan, nextNode);
    return nSpan;
  };
  /**
   * 删除 有当前用户删除标记的内容
   */
  this.removeUserDel = function (parentRoot, user) {
    var deleteDomList = [],
        dom = void 0;
    if (!parentRoot) {
      parentRoot = rangeUtils.getRangeParentRoot();
    }
    if (parentRoot) {
      if (!domUtils.isBody(parentRoot)) {
        //避免直接返回最底层的 span，从而导致查询失败，所以需要扩大范围
        parentRoot = parentRoot.parentNode;
      }
      //判断当前的 元素是否是在 已封包的 修订 img 中
      dom = _this.getWizAmendImgParent(parentRoot);

      //只获取当前用户修订的 img span
      if (dom && dom.getAttribute(CONST.ATTR.SPAN_USERID) !== user.hash) {
        dom = null;
      }

      if (dom) {
        // 针对 img 特殊处理
        deleteDomList.push(dom);
      } else {
        domUtils.search(parentRoot, '[' + CONST.ATTR.SPAN_INSERT + '="' + user.hash + '"][' + CONST.ATTR.SPAN_DELETE + '="' + user.hash + '"]', deleteDomList);

        //TODO 此种情况可能已经不会存在了
        domUtils.search(parentRoot, '[' + CONST.ATTR.SPAN_USERID + '="' + user.hash + '"] [' + CONST.ATTR.SPAN_DELETE + '="' + user.hash + '"]', deleteDomList);
      }
    }

    for (var i = 0, j = deleteDomList.length; i < j; i++) {
      var _dom = deleteDomList[i];
      var p = _dom.parentNode;
      p.removeChild(_dom);
      domUtils.removeEmptyParent(p);
    }
  };

  /**
   * 对光标选择范围设置 当前用户的 删除标记
   */
  this.removeSelection = function (user) {
    var range = rangeUtils.getRange(),
        startDom = range.startContainer,
        startOffset = range.startOffset,
        endDom = range.endContainer,
        endOffset = range.endOffset,
        startImg = _this.getWizAmendImgParent(startDom),
        endImg = _this.getWizAmendImgParent(endDom),
        splitInsert = void 0;

    //如果开始 或结尾 是 修订的内容，但不是 img 的时候， 需要进行拆分后处理
    if (!endImg) {
      splitInsert = _this.splitInsertDom(endDom, endOffset, true, user);
      if (splitInsert.isInsert && splitInsert.split) {
        rangeUtils.setRange(startDom, startOffset, endDom, endOffset);
      }
    }
    if (!startImg) {
      splitInsert = _this.splitInsertDom(startDom, startOffset, true, user);
      if (splitInsert.isInsert && splitInsert.split) {
        //如果 选中的是 某一个dom 的中间部分
        if (endDom === startDom) {
          endDom = splitInsert.insertDom.nextSibling;
          endOffset = endDom.childNodes.length;
        }
        startDom = splitInsert.insertDom;
        startOffset = splitInsert.insertDom.childNodes.length;
        rangeUtils.setRange(startDom, startOffset, endDom, endOffset);
      }
    }

    if (range.collapsed) {
      //如果扩展范围后，依然为 折叠状态， 不进行任何删除样式的修改
      return;
    }

    var style = _this.getDeletedStyle(user);
    rangeUtils.modifySelectionDom(style.style, style.attr);
    _this.fixSelectionByDeleteImg();
  };
  /**
   * 初始化 新增span 的属性
   */
  this.setDefaultAttr = function (dom, user) {
    if (dom.nodeType === 1) {
      var attr = {};
      attr[CONST.ATTR.SPAN] = CONST.ATTR.SPAN;
      attr[CONST.ATTR.SPAN_INSERT] = user.hash;
      attr[CONST.ATTR.SPAN_USERID] = user.hash;
      attr[CONST.ATTR.SPAN_TIMESTAMP] = utils.getTime();
      domUtils.attr(dom, attr);
    }
  };
  /**
   * 初始化已删除图片外层 span 的修订样式
   */
  this.setUserImgContainerStyle = function (dom) {
    domUtils.css(dom, CONST.CSS.IMG.SPAN);
  };
  /**
   * 初始化用户修订样式
   */
  this.setUserInsertStyle = function (dom, user) {
    domUtils.css(dom, {
      'color': user.color,
      'text-decoration': 'underline'
    });
  };

  /**
   * 根据 range 拆分 amend span （主要用于 普通编辑 & 在 amend span 内添加其他 html）
   * @param  fixed (this.fixedAmendRange 方法的返回值)
   */
  this.splitAmendDomByRange = function (fixed) {
    if (!fixed) {
      return null;
    }
    var range = rangeUtils.getRange(),
        startDom = fixed.startContainer,
        endDom = fixed.endContainer,
        startOffset = fixed.startOffset,
        endOffset = fixed.endOffset,
        startImg = void 0,
        endImg = void 0;

    if (range && !range.collapsed) {
      commandExtend.execCommand('delete');
      range = rangeUtils.getRange();
      endDom = range.endContainer;
      endOffset = range.endOffset;
    } else {
      startImg = _this.getWizAmendImgParent(fixed.leftDom);
      endImg = _this.getWizAmendImgParent(fixed.rightDom);
      if (endImg) {
        endDom = endImg;
        endOffset = 0;
        rangeUtils.setRange(endDom, endOffset, endDom, endOffset);
      } else if (startImg) {
        startDom = startImg;
        startOffset = startImg.childNodes.length;
        rangeUtils.setRange(startDom, startOffset, startDom, startOffset);
      }

      range = rangeUtils.getRange();
      endDom = range.endContainer;
      endOffset = range.endOffset;
    }

    var newDom = _this.splitAmendDomForReverse(endDom, endOffset);
    if (newDom) {
      rangeUtils.setRange(newDom, 1, newDom, 1);
      return newDom;
    }
    return null;
  };
  /**
   * 如果在 已修订的span 内，进行操作时 需要拆分 Dom，避免修订样式被继承（专门用于 逆修订）
   */
  this.splitAmendDomForReverse = function (endDom, endOffset) {
    var imgDom = _this.getWizAmendImgParent(endDom);

    if (!imgDom && endDom.nodeType === 1 && endOffset > 0) {
      endDom = endDom.childNodes[endOffset - 1];
      endOffset = domUtils.getEndOffset(endDom);
    } else if (!imgDom && endDom.nodeType === 1) {
      endDom = endDom.childNodes[0];
    }
    if (!endDom) {
      return null;
    }
    var insertDom = _this.getWizInsertParent(endDom),
        deleteDom = _this.getWizDeleteParent(endDom),
        amendDom = insertDom || deleteDom,
        newDom = _this.createDomForReverse();

    if (imgDom) {
      domUtils.before(newDom, imgDom, endOffset > 0);
    } else if (amendDom) {
      amendDom = _this.splitWizDomWithTextNode(endDom, endOffset);
      if (amendDom) {
        domUtils.after(newDom, amendDom);
      } else {
        return null;
      }
    } else {
      return null;
    }

    return newDom;
  };
  /**
   * 如果在 已删除的文字内，需要筛分 已删除Dom，在中间添加
   */
  this.splitDeletedDom = function (endDom, endOffset) {
    if (endDom.nodeType === 1) {
      return false;
    }
    var splitDom = null;
    if (_this.isWizDelete(endDom)) {
      splitDom = _this.splitWizDomWithTextNode(endDom, endOffset);
      return !!splitDom;
    }
    return false;
  };
  /**
   * 如果在 wiz span 内，进行操作时 需要拆分 Dom，在中间添加
   */
  this.splitInsertDom = function (endDom, endOffset, forceSplit, user) {
    var result = {
      insertDom: null,
      isInsert: false,
      split: false
    };
    if (!endDom) {
      return result;
    }
    if (endDom.nodeType === 1 && endOffset > 0) {
      endDom = endDom.childNodes[endOffset - 1];
      endOffset = domUtils.getEndOffset(endDom);
    } else if (endDom.nodeType === 1) {
      endDom = endDom.childNodes[0];
    }
    if (!endDom) {
      return result;
    }
    var imgDom = _this.getWizAmendImgParent(endDom),
        insertDom = _this.getWizInsertParent(endDom),
        time1 = void 0,
        time2 = void 0;
    result.insertDom = insertDom;
    if (!insertDom && endDom.nodeType === 1) {
      return result;
    }
    if (imgDom) {
      return result;
    }

    if (insertDom && (forceSplit || insertDom.getAttribute(CONST.ATTR.SPAN_USERID) !== user.hash)) {
      //强迫分割（粘贴操作、Enter）时，直接分隔，不考虑时间
      result.split = true;
    } else if (insertDom) {
      //对于同一个用户，新增内容的在 AMEND_TIME_SPACE 时间间隔内，则仅更新时间戳，否则拆分 span
      time1 = insertDom.getAttribute(CONST.ATTR.SPAN_TIMESTAMP);
      time2 = utils.getTime();
      if (utils.getDateForTimeStr(time2) - utils.getDateForTimeStr(time1) >= CONST.AMEND_TIME_SPACE) {
        result.split = true;
      } else {
        var attr = {};
        attr[CONST.ATTR.SPAN_TIMESTAMP] = time2;
        domUtils.attr(insertDom, attr);
      }
    }

    if (result.split) {
      result.split = !!_this.splitWizDomWithTextNode(endDom, endOffset);
    }

    result.isInsert = !!insertDom;
    return result;
  };
  /**
   * 把 根据 getSelectedAmendDoms 或 getAmendDoms 方法得到的数据中 起始、结束位置的 dom 进行拆分， 实现选择范围内 接受、拒绝修订
   */
  this.splitSelectedAmendDoms = function (amendDoms) {
    if (!amendDoms || !amendDoms.start && !amendDoms.end) {
      return;
    }

    var range = rangeUtils.getRange(),
        startDom = range.startContainer,
        startOffset = range.startOffset,
        endDom = range.endContainer,
        endOffset = range.endOffset;

    var node = void 0;

    if (amendDoms.start && amendDoms.end && mendDoms.start.dom === amendDoms.end.dom) {
      //选择范围在 一个 dom 内部的时候，会把一个 dom 拆分为 3 段
      //为保证主 dom 不丢失，所以一定要先 end 后 start
      _this.splitWizDomWithTextNode(amendDoms.end.dom, amendDoms.end.offset);
      node = _this.splitWizDomWithTextNode(amendDoms.start.dom, amendDoms.start.offset);
      node = node.nextSibling;
      _this.add2SelectedAmendDoms(amendDoms, node);
      startDom = node;
      startOffset = 0;
      endDom = node;
      endOffset = node.childNodes.length;
    } else {
      //单独拆分 选择范围的起始dom 和 结束dom
      if (amendDoms.start) {
        node = _this.splitWizDomWithTextNode(amendDoms.start.dom, amendDoms.start.offset);
        node = node.nextSibling;
        _this.add2SelectedAmendDoms(amendDoms, node);
        startDom = node;
        startOffset = 0;
      }
      if (amendDoms.end) {
        node = _this.splitWizDomWithTextNode(amendDoms.end.dom, amendDoms.end.offset);
        _this.add2SelectedAmendDoms(amendDoms, node);
        endDom = node;
        endOffset = node.childNodes.length;
      }
    }
    delete amendDoms.start;
    delete amendDoms.end;
    //修正选择范围
    rangeUtils.setRange(startDom, startOffset, endDom, endOffset);
  };
  /**
   * 从 TextNode 的 光标位置 拆分该 TextNode 的 修订 Dom
   * 返回最后拆分的 Dom
   */
  this.splitWizDomWithTextNode = function (endDom, endOffset) {
    if (!endDom || endDom.nodeType !== 3) {
      return null;
    }
    var tmpSplitStr = void 0,
        tmpSplit = void 0,
        tmpParent = void 0,
        tmpDom = void 0,
        lastSplit = null;
    if (endOffset < endDom.nodeValue.length) {
      tmpSplitStr = endDom.nodeValue.substr(endOffset);
      tmpSplit = endDom.cloneNode(false);
      tmpSplit.nodeValue = tmpSplitStr;
      endDom.nodeValue = endDom.nodeValue.substr(0, endOffset);
      endDom.parentNode.insertBefore(tmpSplit, endDom.nextSibling);
      lastSplit = endDom;
      tmpParent = endDom.parentNode;
      tmpDom = tmpSplit;
    } else {
      tmpParent = endDom.parentNode;
      tmpDom = endDom.nextSibling;
    }
    while (!!tmpParent && !domUtils.isBody(tmpParent)) {
      lastSplit = tmpParent;
      domUtils.splitDomBeforeSub(tmpParent, tmpDom);
      if (tmpParent && tmpParent.nodeType === 1 && (tmpParent.getAttribute(CONST.ATTR.SPAN_DELETE) || tmpParent.getAttribute(CONST.ATTR.SPAN_INSERT))) {
        break;
      }
      tmpDom = tmpParent.nextSibling;
      tmpParent = tmpParent.parentNode;
    }
    return lastSplit;
  };

  /**
   * 删除 修订内容（接受 已删除的； 拒绝已添加的）
   */
  this.wizAmendDelete = function (domList) {
    for (var i = 0, j = domList.length; i < j; i++) {
      var d = domList[i];
      var p = d.parentNode;
      p.removeChild(d);
      domUtils.removeEmptyParent(p);
    }
  };
  /**
   * 保留 修订内容（接受 已添加的； 拒绝已删除的）
   */
  this.wizAmendSave = function (domList) {
    for (var i = 0, j = domList.length; i < j; i++) {
      var d = domList[i];
      if (d.getAttribute(CONST.ATTR.SPAN_DELETE) && d.getAttribute(CONST.ATTR.SPAN_INSERT) && d.getAttribute(CONST.ATTR.SPAN_INSERT) !== d.getAttribute(CONST.ATTR.SPAN_USERID)) {
        //如果 是用户B 删除了 用户A 新增的内容， 则拒绝已删除操作时，恢复为用户A 新增的状态
        var u = amendUser.getUserByGuid(d.getAttribute(CONST.ATTR.SPAN_INSERT));
        u = u ? u : {};
        var attr = {};
        attr[CONST.ATTR.SPAN_DELETE] = null;
        attr[CONST.ATTR.SPAN_USERID] = u.hash;
        domUtils.attr(d, attr);

        if (d.getAttribute(CONST.ATTR.IMG)) {
          _this.setUserImgContainerStyle(d);
          domUtils.css(mask, CONST.CSS.IMG_INSERT);
        } else {
          _this.setUserInsertStyle(d, u);
        }
        continue;
      }

      if (d.getAttribute(CONST.ATTR.IMG)) {
        domUtils.before(d.children[0], d);
        domUtils.remove(d);
      } else {
        domUtils.css(d, {
          'color': '',
          'text-decoration': ''
        });
        var _attr = {};
        _attr[CONST.ATTR.SPAN_USERID] = null;
        _attr[CONST.ATTR.SPAN_INSERT] = null;
        _attr[CONST.ATTR.SPAN_DELETE] = null;
        _attr[CONST.ATTR.SPAN_PASTE] = null;
        _attr[CONST.ATTR.SPAN_PASTE_TYPE] = null;
        _attr[CONST.ATTR.SPAN_PASTE_ID] = null;
        _attr[CONST.ATTR.SPAN_TIMESTAMP] = null;
        domUtils.attr(d, _attr);
      }
    }
  };
};

module.exports = AmendUtils;

},{"../../config/const":388,"../../libs/utils":400}],360:[function(require,module,exports){
'use strict';

/**
 * 块级元素区域（Table & CodeMirror） 操作核心包 core
 * 1、处理 Table & CodeMirror 横向滚动条
 * 2、处理 块级元素前后自动添加 空行
 * 最新需求 CodeMirror 在移动设备上自动换行，不显示横向滚动条
 */
var CONST = require('../../config/const');
var BlockType = {
  Table: 'table',
  Code: 'code'
};

var BlockCore = function BlockCore() {
  var core = null;
  var env = null;
  var blockUtils = null;
  var codeUtils = null;
  var domUtils = null;
  var tableUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    blockUtils = core.require.blockUtils;
    codeUtils = core.require.codeUtils;
    domUtils = core.require.domUtils;
    tableUtils = core.require.tableUtils;
  };

  var scrollContainer = void 0,
      scroll = void 0;
  var blockList = [];
  var findTimer = void 0;

  var checkScroll = function checkScroll() {
    if (blockList.length === 0) {
      return;
    }

    var viewHeight = env.options.document.documentElement.clientHeight;
    var pageScroll = domUtils.getPageScroll();
    var viewTop = pageScroll.top + viewHeight;

    for (var i = blockList.length - 1; i >= 0; i--) {
      var blockObj = blockList[i];
      if (blockObj.top < viewTop && blockObj.top + blockObj.height > viewTop && blockObj.target.offsetWidth < blockObj.target.scrollWidth) {
        if (scroll && scroll.curBlock && scroll.curBlock.target === blockObj.target) {
          setScrollSize(blockObj);
          return;
        } else if (scroll) {
          hideDiyScroll();
        }
        showDiyScroll(blockObj);
        return;
      }
    }
    // 没有任何一个需要显示时，则隐藏 scroll
    hideDiyScroll();
  };
  var findBlocks = function findBlocks() {
    blockList = [];

    var scrollTarget = void 0;
    // 查找 table
    var _tableList = env.body.querySelectorAll('table');
    for (var i = _tableList.length - 1; i >= 0; i--) {
      var table = _tableList[i];
      var tableContainer = tableUtils.getContainer(table);
      if (!tableContainer) {
        tableUtils.initTableContainer(table);
        tableContainer = tableUtils.getContainer(table);
      }
      if (tableContainer) {
        scrollTarget = tableContainer.querySelector('.' + CONST.CLASS.TABLE_BODY);
        blockList.push({
          type: BlockType.Table,
          target: scrollTarget,
          top: tableContainer.offsetTop,
          height: tableContainer.offsetHeight
        });
      }
      // console.log(tTop + tHeight > scrollTop + viewHeight);
    }

    // 查找 code
    // 非 手机端、Pad 端才处理 Code 的 横向滚动条
    if (!(env.client.type.isPhone || env.client.type.isPad)) {
      var _codeList = env.body.querySelectorAll('.' + CONST.CLASS.CODE_MIRROR);
      for (var _i = _codeList.length - 1; _i >= 0; _i--) {
        var code = _codeList[_i];
        var codeContainer = codeUtils && codeUtils.getContainerFromChild(code);
        if (!codeContainer && codeUtils) {
          codeUtils.fixCode(code);
          codeContainer = codeUtils.getContainerFromChild(code);
        }
        if (!codeContainer) {
          continue;
        }
        // 不使用 codeMirror 自定义的滚动条
        scrollTarget = code.querySelector('.' + CONST.CLASS.CODE_MIRROR_HSCROLL);
        blockList.push({
          type: BlockType.Code,
          target: scrollTarget,
          codeMirror: codeContainer.codeMirror,
          top: codeContainer.offsetTop,
          height: codeContainer.offsetHeight
        });
        // console.log(tTop + tHeight > scrollTop + viewHeight);
      }
    }

    checkScroll();
  };
  var findBlocksController = function findBlocksController() {
    if (scroll && scroll.parentNode !== scrollContainer) {
      // 滚动时 如果 自定义滚动条正在显示，则立即控制滚动条是否隐藏
      checkScroll();
    }

    if (findTimer) {
      clearTimeout(findTimer);
    }
    findTimer = setTimeout(findBlocks, 100);
  };
  var hideDiyScroll = function hideDiyScroll() {
    if (scroll) {
      _event.unbindScroll();
      scroll.curBlock = null;
      scrollContainer.appendChild(scroll);
    }
  };
  var setScrollSize = function setScrollSize(blockObj) {
    var scrollInner = void 0;
    if (scroll) {
      scrollInner = scroll.children[0];
    } else {
      scroll = env.doc.createElement(CONST.TAG.TMP_TAG);
      scrollInner = env.doc.createElement('div');
      scroll.appendChild(scrollInner);
      domUtils.addClass(scroll, CONST.CLASS.BLOCK_SCROLL);
    }

    var targetWidth = blockObj.target.scrollWidth;
    domUtils.css(scrollInner, {
      "width": targetWidth + "px",
      "height": "1px",
      "background-color": "rgba(255, 255, 255, 0.2)"
    });

    domUtils.css(scroll, {
      "background-color": "rgba(255, 255, 255, 0.2)",
      "height": "17px",
      "width": blockObj.target.offsetWidth + "px",
      "overflow-x": "scroll",
      "overflow-y": "hidden",
      "position": "fixed",
      "bottom": "0px",
      "z-index": 999
    });

    scroll.scrollLeft = blockObj.target.scrollLeft;
  };
  var showDiyScroll = function showDiyScroll(blockObj) {
    setScrollSize(blockObj);
    scroll.curBlock = blockObj;
    domUtils.after(scroll, blockObj.target);
    _event.bindScroll();
    // 显示自定义滚动条时，需要与 目标横向滚动条位置相同
    _event.handler.onTxScroll();
  };
  var _event = {
    bind: function bind() {
      _event.unbind();
      if (!env.client.type.isIOS && !env.client.type.isAndroid) {
        env.event.add(CONST.EVENT.ON_SCROLL, _event.handler.onScroll);
        env.event.add(CONST.EVENT.ON_DOM_SUBTREE_MODIFIED, _event.handler.updateRender);
        env.win.addEventListener('resize', _event.handler.updateRender);
      }
      if (!env.readonly) {
        if (env.client.type.isPhone || env.client.type.isPad) {
          env.event.add(CONST.EVENT.ON_TOUCH_START, _event.handler.onMouseDown);
        } else {
          env.event.add(CONST.EVENT.ON_MOUSE_DOWN, _event.handler.onMouseDown);
        }
      }
    },
    unbind: function unbind() {
      hideDiyScroll();
      env.event.remove(CONST.EVENT.ON_SCROLL, _event.handler.onScroll);
      env.event.remove(CONST.EVENT.ON_DOM_SUBTREE_MODIFIED, _event.handler.updateRender);
      env.win.removeEventListener('resize', _event.handler.updateRender);

      env.event.remove(CONST.EVENT.ON_TOUCH_START, _event.handler.onMouseDown);
      env.event.remove(CONST.EVENT.ON_MOUSE_DOWN, _event.handler.onMouseDown);
    },
    bindScroll: function bindScroll() {
      _event.unbindScroll();
      // 避免 滚动条循环事件导致 滚动不流畅， 不监听 target 的 scroll 事件
      // scroll.curBlock.target.addEventListener('scroll', _event.handler.onTxScroll);
      scroll.addEventListener('scroll', _event.handler.onSxScroll);
    },
    unbindScroll: function unbindScroll() {
      // if (scroll.curBlock) {
      //     scroll.curBlock.target.removeEventListener('scroll', _event.handler.onTxScroll);
      // }
      scroll.removeEventListener('scroll', _event.handler.onSxScroll);
    },
    handler: {
      onMouseDown: function onMouseDown(e) {
        var isLeft = e.type !== 'mousedown' || e.button === 0 || e.button === 1;
        if (!isLeft) {
          return;
        }
        blockUtils.checkAndInsertEmptyLine(e);
      },
      onScroll: function onScroll() {
        findBlocksController();
      },
      onSxScroll: function onSxScroll() {
        if (scroll.curBlock) {
          scroll.curBlock.target.scrollLeft = scroll.scrollLeft;
        }
      },
      onTxScroll: function onTxScroll() {
        if (scroll.curBlock) {
          scroll.scrollLeft = scroll.curBlock.target.scrollLeft;
        }
      },
      updateRender: function updateRender() {
        findBlocksController();
      }
    }
  };

  this.on = function () {
    _event.bind();

    if (env.client.type.isIOS || env.client.type.isAndroid) {
      return;
    }
    if (!scrollContainer) {
      scrollContainer = env.doc.createElement('div');
    }
    findBlocksController();
  };
  this.off = function () {
    _event.unbind();
  };
};

module.exports = BlockCore;

},{"../../config/const":388}],361:[function(require,module,exports){
'use strict';

/**
 * wiz 模块区域（表格、代码）操作的基本方法集合
 */
var CONST = require('../../config/const'),
    utils = require('../../libs/utils');

var BlockUtils = function BlockUtils() {
  var _this = this;

  var core = null;
  var env = null;
  var commandExtend = null;
  var domUtils = null;
  var historyUtils = null;
  var rangeUtils = null;
  var tableZone = null;
  var todoUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    commandExtend = core.require.commandExtend;
    domUtils = core.require.domUtils;
    historyUtils = core.require.historyUtils;
    rangeUtils = core.require.rangeUtils;
    tableZone = core.require.tableZone;
    todoUtils = core.require.todoUtils;
  };

  var checkPageFirst = function checkPageFirst(editBody, checkFirst, clientY, getBlockFun) {
    var isFirst = false,
        isLast = false,
        offset = void 0,
        container = void 0;
    var obj = checkFirst ? domUtils.getFirstDeepChild(editBody) : domUtils.getLastDeepChild(editBody);
    container = domUtils.getParentByClass(obj, CONST.CLASS.CODE_CONTAINER);

    if (container) {
      obj = container;
    } else {
      while (obj && !domUtils.canEdit(obj)) {
        obj = checkFirst ? domUtils.getNextNodeCanEdit(obj, false) : domUtils.getPreviousNodeCanEdit(obj, false);
      }
    }

    if (obj) {
      if (obj.nodeType === 3) {
        obj = obj.parentNode;
      }
      offset = domUtils.getOffset(obj);
      container = domUtils.getParentByFilter(obj, getBlockFun, true);
      if (checkFirst && clientY < offset.top && container) {
        isFirst = true;
      } else if (!checkFirst && clientY > offset.top + obj.offsetHeight && container) {
        isLast = true;
      } else {
        obj = null;
      }
    }
    return {
      container: container,
      isFirst: isFirst,
      isLast: isLast
    };
  };

  /**
   * 清理 出现的多余 dom 结构（例如：<div><span></span></div>）
   * @param block
   */
  var clearEmptyBlock = function clearEmptyBlock(block) {
    if (domUtils.isEmptyDom(block) && !block.querySelector('br')) {
      domUtils.remove(block);
      return true;
    }
    return false;
  };

  var fixBlockList = function fixBlockList(start, end, parentIndex) {
    var range = rangeUtils.getRange();
    if (!range) {
      return;
    }

    var target = start;
    var isBlock = void 0,
        isTodo = void 0,
        isCode = void 0,
        isTable = void 0,
        isWizDom = void 0;
    var targetIndex = void 0;

    while (target) {
      // console.log('----------------------------  target --------------------');
      // console.log(target.nodeType === 3 ? target.nodeValue : target.outerHTML);
      var endIndex = domUtils.getIndexList(domUtils.getLastDeepChild(end)).join('.');
      targetIndex = domUtils.getIndexList(target).join('.');
      if (utils.compareVersion(targetIndex, endIndex) > 0) {
        // 到达结尾处需要跳出循环
        break;
      }

      isTodo = false;
      isCode = false;
      isTable = false;
      isWizDom = false;
      isBlock = domUtils.isBlock(target, { includeBr: false });

      if (isBlock) {
        var codeContainer = domUtils.getParentByClass(target, CONST.CLASS.CODE_CONTAINER, true);
        if (codeContainer) {
          isCode = true;
          target = codeContainer;
        } else {
          isWizDom = domUtils.isWizDom(target);
        }
        if (!isCode && !isWizDom) {
          var tableContainer = domUtils.getParentByClass(target, CONST.CLASS.TABLE_CONTAINER, true);
          if (tableContainer) {
            isTable = true;
            target = tableContainer;
          }
        }
        if (!isWizDom && !isCode && !isTable) {
          isTodo = todoUtils && !!todoUtils.isLayer(target);
        }

        var tmpTarget = void 0;
        var parentList = domUtils.getParentList(target);
        if (parentIndex < parentList.length) {
          var parent = parentList[parentIndex];
          tmpTarget = domUtils.splitDomSingle(parent, target);
        } else {
          tmpTarget = target;
        }

        tmpTarget.isBlock = true;

        if (isWizDom || isCode || isTable) {
          tmpTarget.notFormat = true;
        }
      }
      var canSearchChildren = !domUtils.isTag(target, ['ol', 'ul']) && target.childNodes.length > 0;

      var next = void 0;
      if (!isWizDom && !isCode && !isTable && !isTodo && canSearchChildren) {
        next = target.childNodes[0];
      } else {
        next = target.nextSibling;
        while (!next && target !== env.body && target.parentNode) {
          target = target.parentNode;
          next = target.nextSibling;
        }
      }
      target = next;
    }
  };

  var getBlockFun = function getBlockFun(obj) {
    return domUtils.hasClass(obj, CONST.CLASS.CODE_CONTAINER) || domUtils.hasClass(obj, CONST.CLASS.TABLE_CONTAINER);
  };

  var getBlockContainer = function getBlockContainer(obj) {
    return domUtils.getParentByFilter(obj, getBlockFun, true);
  };

  var isBlock = function isBlock(obj) {
    return domUtils.hasClass(obj, CONST.CLASS.CODE_CONTAINER) || domUtils.hasClass(obj, CONST.CLASS.TABLE_CONTAINER) || domUtils.hasClass(obj, CONST.CLASS.TABLE_BODY);
  };

  /**
   * 为防止笔记内只有一个模块区域（表格、代码等）时 无法在模块前后 或 多个模块之间输入内容
   */
  this.checkAndInsertEmptyLine = function (e) {
    var touch = e.changedTouches ? e.changedTouches[0] : null,
        target = touch ? touch.target : e.target,
        eventClient = utils.getEventClientPos(e),
        clientY = domUtils.getPageScroll().top + eventClient.y;

    if (env.doc.elementFromPoint) {
      // 需要针对以下情况进行修正：
      // body 内 两个连续的 Table，点击 table 之间时，得到的 target 是 body，从而导致判定失败，所以使用 elementFromPoint 修正得到的 target
      var clientX = domUtils.getPageScroll().left + eventClient.x;
      // clientY - 10 是为了得到 光标上方 10像素的 BLOCK
      var pointTarget = env.doc.elementFromPoint(clientX, clientY - 10);
      if (pointTarget) {
        pointTarget = getBlockContainer(pointTarget);
      }
      if (pointTarget && domUtils.isParent(pointTarget, target)) {
        // 只有当 pointTarget 是 target 的子元素时，才认为有效
        target = pointTarget;
      }
      // clientY + 10 的情况暂不考虑，因为已经不需要了
      // pointTarget = env.doc.elementFromPoint(clientX, clientY + 10);
    }

    var dom = void 0,
        container = void 0,
        checkResult = void 0,
        isAfter = false,
        isBefore = false,
        offsetY = void 0;

    // 需要兼容 WizTemplate 的模板（区域性设置 contenteditable）
    var editBody = domUtils.getParentByFilter(target, function (dom) {
      return dom.getAttribute('contenteditable') === 'true';
    }, true) || env.body;
    var isEditBody = editBody && target === editBody;
    var isEditBodyParent = editBody && target === editBody.parentNode;
    if (isEditBody || isEditBodyParent) {
      // 只有一个 CodeMirror 时，点击 CodeMirror 下面， range = null
      if (isEditBody) {
        checkResult = checkPageFirst(editBody, true, clientY, getBlockFun);
        isBefore = checkResult.isFirst;
        container = checkResult.container;
      }
      if (!isBefore) {
        checkResult = checkPageFirst(editBody, false, clientY, getBlockFun);
        isAfter = checkResult.isLast;
        container = checkResult.container;
      }
    } else if (isBlock(target)) {
      container = getBlockContainer(target);
      offsetY = 0;
      if (container) {
        offsetY = clientY - domUtils.getOffset(container).top;
      }
      if (container && offsetY < 15) {
        dom = domUtils.getPreviousNodeCanEdit(target, false);
        var prevBlock = getBlockContainer(dom);
        if (!dom || prevBlock && prevBlock !== container) {
          isBefore = true;
        } else if (dom) {
          // Block 在 li 内 需要特殊处理
          prevBlock = domUtils.getBlockParent(dom, true);
          if (prevBlock && domUtils.isTag(prevBlock, 'li') && !domUtils.isParent(container, prevBlock)) {
            isBefore = true;
          }
        }
      } else if (container && target.offsetHeight - offsetY < 15) {
        dom = domUtils.getNextNodeCanEdit(target, false);
        var nextBlock = getBlockContainer(dom);
        if (!dom || nextBlock && nextBlock !== container) {
          isAfter = true;
        } else if (dom) {
          // Block 在 li 内 需要特殊处理
          nextBlock = domUtils.getBlockParent(dom, true);
          if (nextBlock && domUtils.isTag(nextBlock, 'li') && !domUtils.isParent(container, nextBlock)) {
            isAfter = true;
          }
        }
      }
    }
    if (container && (isAfter || isBefore)) {
      historyUtils.saveSnap(false);
      _this.insertEmptyLine(container, isAfter);
    } else {
      dom = null;
    }
  };

  this.insertBlock = function (target) {
    var range = rangeUtils.getRange();
    var start = void 0,
        curDom = void 0,
        curBlock = void 0,
        br = void 0;

    if (range) {
      start = rangeUtils.getRangeDetail(range.startContainer, range.startOffset);
      curDom = start.container;
      curBlock = domUtils.getBlockParent(curDom, true);
      var oriBlock = curBlock;
      if (domUtils.hasClass(curBlock, CONST.CLASS.TODO_LAYER)) {
        // 如果光标在 TodoList 内，则直接在 TodoList 下面创建
        curDom = env.doc.createElement(curBlock.tagName);
        domUtils.after(curDom, curBlock);
        curDom.appendChild(target);
        curBlock = curDom;
      } else if (!curBlock || !domUtils.isEmptyDom(curBlock)) {
        var prevDom = null;
        if (curBlock && domUtils.isTag(curDom, 'br')) {
          prevDom = curDom.previousSibling;
        }
        // 如果 prevDom & curDom 都是 br，则直接在 br 之间插入 Block
        if (!domUtils.isTag(prevDom, 'br')) {
          // 如果光标位置非空，先插入 段落
          commandExtend.execCommand('insertparagraph');
          range = rangeUtils.getRange();
          if (range.startContainer.nodeType === 1 && range.startContainer.childNodes.length > 0) {
            curDom = range.startContainer.childNodes[range.startOffset];
          } else {
            curDom = range.startContainer;
          }

          curBlock = domUtils.getBlockParent(curDom, true);
          if (curDom.nextSibling && domUtils.isTag(curDom, 'br')) {
            // 删除第一个 br ，因为他是多余的
            domUtils.remove(curDom);
          }
        }
      }

      if (curBlock !== oriBlock && domUtils.isEmptyDom(curBlock) && domUtils.isTag(curBlock, 'div')) {
        // 如果 光标位置 block 模块为空，直接注入 target
        curBlock.innerHTML = '';
        curBlock.appendChild(target);
      } else {
        // 如果 光标位置 block 模块非空，则在 block 之前插入 block，然后再注入 target

        if (curBlock === oriBlock) {
          // 有序列表 li 内 <br> 前回车，只会产生新的 <br> 并不会出现新的 li 所以 curBlock == oriBlock
          // 如果直接插入到 curBlock 会导致将 block 插入到 当前 li 的前面
          curBlock = curDom;
        }
        curDom = env.doc.createElement('div');
        if (domUtils.isTag(curBlock, 'li') && domUtils.isTag(curBlock.previousElementSibling, 'li')) {
          // 避免将 Block 插入到 li 之间
          curBlock.previousElementSibling.appendChild(curDom);
        } else {
          domUtils.before(curDom, curBlock);
        }
        curDom.appendChild(target);
        if (domUtils.isEmptyDom(curBlock) || domUtils.isTag(curBlock, 'br')) {
          domUtils.remove(curBlock);
        }
        curBlock = curDom;
      }
    } else {
      curBlock = env.doc.createElement('div');
      curBlock.appendChild(target);
      env.body.appendChild(curBlock);
      br = env.doc.createElement('div');
      br.appendChild(env.doc.createElement('br'));
      env.body.appendChild(br);
    }
    return curBlock;
  };

  this.insertEmptyLine = function (blockContainer, after) {
    if (!blockContainer) {
      return;
    }
    var newLine = env.doc.createElement('div');
    var dom = env.doc.createElement('br');
    newLine.appendChild(dom);
    domUtils.before(newLine, blockContainer, after);
    tableZone.clear();
    rangeUtils.setRange(dom, 0);
  };

  this.fixAndGetBlockListFromRange = function () {
    var blockList = [];
    var range = rangeUtils.getRange();
    if (!range) {
      return blockList;
    }

    var start = rangeUtils.getRangeDetail(range.startContainer, range.startOffset).container;
    var end = rangeUtils.getRangeDetail(range.endContainer, range.endOffset).container;

    if (!domUtils.isBlock(start, { includeBr: true })) {
      var prevBlock = domUtils.getPrevBlock(start);
      if (prevBlock && prevBlock !== env.body && domUtils.isParent(start, prevBlock)) {
        // 与 end 不同， end 为了保证始终在结尾 ，所以需要保存最深的末级节点
        // start 需要保留第一个 块级节点
        start = prevBlock;
      } else {
        if (prevBlock && prevBlock !== env.body) {
          start = domUtils.getNextNode(prevBlock, false, start);
        } else {
          start = domUtils.getFirstDeepChild(env.body);
        }
      }
      if (prevBlock && domUtils.isTag(prevBlock, ['br'])) {
        domUtils.remove(prevBlock);
      }
    }

    if (!domUtils.isBlock(end, { includeBr: true })) {
      var nextBlock = domUtils.getNextBlock(end);
      if (nextBlock && nextBlock !== env.body && domUtils.isParent(end, nextBlock)) {
        end = domUtils.getLastDeepChild(nextBlock);
      } else {
        if (nextBlock && nextBlock !== env.body) {
          end = domUtils.getPreviousNode(nextBlock, false, end);
        } else {
          end = domUtils.getLastDeepChild(env.body);
        }
      }
      if (nextBlock && domUtils.isTag(nextBlock, ['br'])) {
        domUtils.remove(nextBlock);
      }
    }
    // console.log('start: ');
    // console.log(start);
    // console.log('end: ');
    // console.log(end);

    var isSameElement = start === end;
    var parentRoot = domUtils.getParentRoot([start, end]);
    // table 只有 单元格内才能被选中，要避免 td、th 被替换 tagname 或 被外面 包上新的 tagname
    if (domUtils.isTag(parentRoot, ['td', 'th'])) {
      var tmp = domUtils.packageChildNodesByDiv(parentRoot);
      if (start === parentRoot) {
        start = tmp;
      }
      if (end === parentRoot) {
        end = tmp;
      }
      parentRoot = tmp;
    }
    var parentIndex = 0;
    if (parentRoot !== env.body) {
      parentIndex = domUtils.getParentList(parentRoot).length + 1;
    }
    // console.log('parentIndex: ' + parentIndex);
    // console.log(parentRoot);

    //开始 分隔 start & end
    var parentList = domUtils.getParentList(start);
    var startParent = void 0,
        endParent = void 0;
    if (parentIndex < parentList.length) {
      startParent = parentList[parentIndex];
      start = domUtils.splitDomBeforeSub(startParent, start);
    } else {
      startParent = start;
    }
    if (!isSameElement) {
      parentList = domUtils.getParentList(end);
      if (parentIndex < parentList.length) {
        endParent = parentList[parentIndex];
        domUtils.splitDomAfterSub(endParent, end);
      } else {
        // endParent = end;
      }
    } else {
      // endParent = startParent;
      end = start;
    }

    fixBlockList(start, end, parentIndex);

    // 修正 block 后， startParent 需要重新获取
    parentList = domUtils.getParentList(start);
    if (parentIndex < parentList.length) {
      startParent = parentList[parentIndex];
    } else {
      startParent = start;
    }

    // console.log('start: ');
    // console.log(start);
    // console.log(startParent);
    // console.log('end: ');
    // console.log(end);
    // console.log(endParent);

    // 合并 行级元素到同一个块级元素中
    var target = startParent;
    var tmpBlock = void 0;

    // 特殊处理 <div><br/></div>
    if (startParent === end && domUtils.isTag(startParent, 'br')) {
      var p = startParent.parentNode;
      var tmpTarget = null;
      while (p && p !== env.body && p.childNodes.length === 1) {
        tmpTarget = p;
        p = p.parentNode;
      }
      if (tmpTarget) {
        target = tmpTarget;
        if (domUtils.isBlock(target)) {
          target.isBlock = true;
        }
      }
    }
    while (target) {
      var next = target.nextSibling;
      if (!target.isBlock) {
        if (!tmpBlock) {
          tmpBlock = env.doc.createElement('div');
          domUtils.before(tmpBlock, target);
          blockList.push(tmpBlock);
        }
        tmpBlock.appendChild(target);
      } else {
        tmpBlock = null;
        if (domUtils.isTag(target, 'br')) {
          tmpBlock = env.doc.createElement('div');
          domUtils.before(tmpBlock, target);
          blockList.push(tmpBlock);
          tmpBlock.appendChild(target);
        } else {
          if (!clearEmptyBlock(target)) {
            blockList.push(target);
          }
        }
      }

      target = next;
      if (target) {
        //因为有合并 dom 的操作，所以 endIndex 必须每次重新获取
        var endIndex = domUtils.getIndexList(end).join('.');
        var targetIndex = domUtils.getIndexList(target).join('.');
        if (utils.compareVersion(targetIndex, endIndex) > 0) {
          // 到达结尾处需要跳出循环
          break;
        }
      }
    }
    // console.log(blockList);
    return blockList;
  };
};

module.exports = BlockUtils;

},{"../../config/const":388,"../../libs/utils":400}],362:[function(require,module,exports){
'use strict';

/**
 * 代码区域操作核心包 core
 */
var CONST = require('../../config/const');
var utils = require('../../libs/utils');
var LoadController = require('../../libs/LoadController');
var dependLoader = require('../../libs/dependLoader');

var loadController = new LoadController();
var CodeCore = function CodeCore() {
  var _this = this;

  var core = null;
  var env = null;
  var blockUtils = null;
  var codeStyle = null;
  var codeUtils = null;
  var domUtils = null;
  var historyUtils = null;
  var rangeUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    blockUtils = core.require.blockUtils;
    codeStyle = core.require.codeStyle;
    codeUtils = core.require.codeUtils;
    domUtils = core.require.domUtils;
    historyUtils = core.require.historyUtils;
    rangeUtils = core.require.rangeUtils;
  };

  this.hasLoaded = false;

  var loadDependency = function loadDependency(callback) {
    loadController.addCallback(env.doc, callback);
    if (loadController.getLoading(env.doc)) {
      return;
    }
    if (typeof env.win.CodeMirror === 'undefined') {
      loadController.setLoading(env.doc, true);
      dependLoader.loadJs(env.doc, dependLoader.getDependencyFiles(env.dependency, 'js', 'codeMirror'), function () {
        loadController.setLoading(env.doc, false);
        loadController.callback(env.doc);
      });
    } else {
      loadController.callback(env.doc);
    }
  };

  var _event = {
    bind: function bind() {
      _event.unbind();
      env.event.add(CONST.EVENT.ON_SELECT_PLUGIN_CHANGE, _event.handler.onChangeSelector);
      env.event.add(CONST.EVENT.ON_SELECT_PLUGIN_HIDE, _event.handler.onHideSelector);
      env.event.add(CONST.EVENT.ON_SELECT_PLUGIN_SHOW, _event.handler.onShowSelector);
      env.event.add(CONST.EVENT.BEFORE_GET_DOCHTML, _event.handler.beforeGetDocHtml);
      env.event.add(CONST.EVENT.BEFORE_SAVESNAP, _event.handler.onBeforeSaveSnap);
      env.event.add(CONST.EVENT.AFTER_RESTORE_HISTORY, _event.handler.onAfterRestoreHistory);
      env.event.add(CONST.EVENT.ON_MOUSE_DOWN, _event.handler.onMouseDown);
    },
    unbind: function unbind() {
      env.event.remove(CONST.EVENT.ON_SELECT_PLUGIN_CHANGE, _event.handler.onChangeSelector);
      env.event.remove(CONST.EVENT.BEFORE_GET_DOCHTML, _event.handler.beforeGetDocHtml);
      env.event.remove(CONST.EVENT.BEFORE_SAVESNAP, _event.handler.onBeforeSaveSnap);
      env.event.remove(CONST.EVENT.AFTER_RESTORE_HISTORY, _event.handler.onAfterRestoreHistory);
      env.event.remove(CONST.EVENT.ON_MOUSE_DOWN, _event.handler.onMouseDown);
    },
    handler: {
      beforeGetDocHtml: function beforeGetDocHtml() {
        codeUtils.saveToText();
        codeStyle.clearStyle();
      },
      onAfterRestoreHistory: function onAfterRestoreHistory() {
        var containerList = codeUtils.getContainerList();
        for (var i = containerList.length - 1; i >= 0; i--) {
          var container = containerList[i];
          var cm = container.codeMirror;
          if (!cm) {
            // 恢复 版本（重新刷 body 后），实例化 CodeMirror
            codeUtils.fixCodeContainer({ container: container });
            // 根据 history 恢复的 CodeMirror Doc 恢复当前 版本
            var cmDoc = historyUtils.getCodeMirrorDoc(container.id);
            if (cmDoc) {
              cm = container.codeMirror;
              cm.swapDoc(cmDoc);
            }
          }
        }
      },
      onBeforeSaveSnap: function onBeforeSaveSnap() {
        var containerList = codeUtils.getContainerList();
        for (var i = containerList.length - 1; i >= 0; i--) {
          var container = containerList[i];
          var cm = container.codeMirror;
          if (cm) {
            // CodeMirror 将最新代码保存到 textarea
            cm.save();
            // 将 textarea 的 value 写入 html
            domUtils.setTextarea(cm.getTextArea());
          }
        }
      },
      onHideSelector: function onHideSelector(target) {
        var container = codeUtils.getContainerFromChild(target);
        if (!container) {
          return;
        }
        domUtils.removeClass(container, "CodeMirror-show-tools");
      },
      onShowSelector: function onShowSelector(target) {
        var container = codeUtils.getContainerFromChild(target);
        if (!container) {
          return;
        }
        domUtils.addClass(container, "CodeMirror-show-tools");
      },
      onChangeSelector: function onChangeSelector(target) {
        var container = codeUtils.getContainerFromChild(target);
        if (!container) {
          return;
        }
        if (domUtils.hasClass(target, CONST.CLASS.CODE_TOOLS_MODE)) {
          codeUtils.changeMode(container, target.value, false);
        } else if (domUtils.hasClass(target, CONST.CLASS.CODE_TOOLS_THEME)) {
          codeStyle.insertTheme(target.value);
          codeUtils.changeTheme(container, target.value, false);
        } else if (domUtils.hasClass(target, CONST.CLASS.CODE_TOOLS_MORE)) {
          if (target.value === CONST.CODE.StorageKey.Wrap) {
            codeUtils.changeLineWrapping(!env.options.code.lineWrapping);
          }
        }
        container.codeMirror.focus();
      },
      onMouseDown: function onMouseDown(e) {
        // 点击 Tools 的时候 阻止默认事件，避免与 CodeMirror 抢焦点
        var tools = codeUtils.getToolsFromChild(e.target);
        // 手机端切换 代码语言 & 主题时不能 stopEvent，否则会导致 select 无法修改
        if (tools && !domUtils.isTag(e.target, 'select')) {
          utils.stopEvent(e);
        }
      },
      onKeyDown: function onKeyDown(e) {
        if (_this.hasLoaded && !codeUtils.onKeyDown(e)) {
          utils.stopEvent(e);
          return false;
        }
        return true;
      }
    }
  };

  this.on = function (options, callback) {
    // 必须要先放置 Code 的样式，否则会导致初始化的 CodeMirror 宽度异常
    codeStyle.initCommon();

    var onCodeLoad = function onCodeLoad() {
      _this.hasLoaded = true;
      _event.bind();
      options = options || {};

      // 修正旧的 prettyprint
      codeUtils.oldPatch.fixOldCode(options.body);
      // 不仅处理 旧的 code，还要初始化新的 codeMirror，所以不能使用 fixOldCode 的返回值
      codeUtils.fixCodeContainer({
        body: options.body,
        container: null,
        readOnly: options.readOnly
      });

      if (callback) {
        callback();
      }
    };

    var oldCodeList = codeUtils.oldPatch.getOldCodeList(options.body);
    var codeList = codeUtils.getContainerList(options.body);
    var pasteCodeList = codeUtils.pastePatch.getPasteCodeList();
    if (!options.forceLoad && oldCodeList.length === 0 && codeList.length === 0 && pasteCodeList.length === 0) {
      if (callback) {
        callback();
      }
    } else {
      loadDependency(onCodeLoad);
    }
  };
  this.off = function () {
    _event.unbind();
    codeUtils.clearCodeMirror();
    _this.hasLoaded = false;
  };
  this.insertCode = function () {
    if (!_this.hasLoaded) {
      _this.on({ forceLoad: true }, _this.insertCode);
      return;
    }
    historyUtils.saveSnap(false);
    var range = rangeUtils.getRange();

    if (range && !codeUtils.canCreateCode()) {
      // CodeMirror / Table 内
      return;
    }
    var curObj = void 0,
        container = void 0,
        textarea = void 0;
    var tempObj = void 0,
        tempRange = void 0,
        src = '';
    if (range) {
      if (!range.collapsed) {
        tempObj = env.doc.createElement('div');
        tempRange = range.cloneContents();
        while (tempRange.firstChild) {
          tempObj.appendChild(tempRange.firstChild);
        }
        tempObj.style.position = "absolute";
        tempObj.style.top = "0px";
        tempObj.style.left = "-10000px";
        tempObj.style.height = "1px";
        env.body.appendChild(tempObj);
        src = tempObj.innerText;
        env.body.removeChild(tempObj);

        range.deleteContents();
      }

      curObj = rangeUtils.getRangeDetail(range.startContainer, range.startOffset);
      curObj = domUtils.getBlockParent(curObj.container, true);
      if (curObj && curObj !== env.body && domUtils.isEmptyDom(curObj) && domUtils.isTag(curObj, 'div')) {
        container = curObj;
        curObj.innerHTML = '';
      }
    }

    textarea = env.doc.createElement('textarea');
    domUtils.setTextarea(textarea, src);
    container = container ? container : env.doc.createElement('div');
    container.appendChild(textarea);
    domUtils.addClass(container, CONST.CLASS.CODE_CONTAINER);
    // 只有新的 CodeMirror 才使用 last 设置
    container.isNew = true;
    if (!container.parentNode) {
      blockUtils.insertBlock(container);
    }
    codeUtils.fixCodeContainer({ container: container });
    container.isNew = false;

    //修正 光标
    setTimeout(function () {
      container.codeMirror.focus();
    }, 100);

    env.event.call(CONST.EVENT.UPDATE_RENDER);
  };
  this.onKeyDown = _event.handler.onKeyDown;
};

module.exports = CodeCore;

},{"../../config/const":388,"../../libs/LoadController":393,"../../libs/dependLoader":397,"../../libs/utils":400}],363:[function(require,module,exports){
'use strict';

/**
 * codeMirror 相关样式处理
 */
var CONST = require('../../config/const');

var CSS = {
  tmp: {
    common: '.wiz-code-tools {display:none; align-items: center;position: absolute; top: -32px; right: 0; opacity: .95; z-index: 110;}' + '.' + CONST.CLASS.WIZ_BODY + ' .' + CONST.CLASS.CODE_CONTAINER + ' .wiz-code-tools {opacity:0;display:flex;transition: opacity 500ms;}' + '.' + CONST.CLASS.WIZ_BODY + ' .' + CONST.CLASS.CODE_CONTAINER + ':hover .wiz-code-tools {opacity:1; }' + '.' + CONST.CLASS.EDITING + ' .CodeMirror-show-tools .wiz-code-tools {z-index: 220;}' + '.' + CONST.CLASS.READONLY + ' .wiz-code-tools.mobile,' + '.' + CONST.CLASS.EDITING + ' .CodeMirror-show-tools .wiz-code-tools,' + '.' + CONST.CLASS.EDITING + ' .CodeMirror-focused .wiz-code-tools {opacity:1; display: flex;}' + '.CodeMirror-sizer {border-right: 0 !important;}' + '.' + CONST.CLASS.WIZ_BODY + ' pre.prettyprint {padding:0;}' + '.' + CONST.CLASS.WIZ_BODY + ' pre.prettyprint code {white-space: pre-wrap;}' + '.' + CONST.CLASS.WIZ_BODY + ' pre.prettyprint.linenums {box-shadow:none; overflow: auto;-webkit-overflow-scrolling: touch;}' + '.' + CONST.CLASS.WIZ_BODY + ' pre.prettyprint.linenums ol.linenums {box-shadow: 40px 0 0 #FBFBFC inset, 41px 0 0 #ECECF0 inset; padding: 10px 10px 10px 40px !important;}' + '.' + CONST.CLASS.EDITING + ' .CodeMirror-activeline-background {display: none;}' + '.' + CONST.CLASS.EDITING + ' .CodeMirror-focused .CodeMirror-activeline-background {display: block;}',
    reader: '.' + CONST.CLASS.READONLY + ' .CodeMirror-cursors {visibility: hidden !important;}',
    readerForIphone: '.' + CONST.CLASS.READONLY + ' .' + CONST.CLASS.CODE_CONTAINER + ' .CodeMirror-scroll {-webkit-overflow-scrolling: touch;}' + '.' + CONST.CLASS.READONLY + ' .' + CONST.CLASS.CODE_CONTAINER + ' .CodeMirror-sizer {min-width: auto !important;}',
    phone: '.' + CONST.CLASS.CODE_CONTAINER + '{margin-left:0; margin-right:0;}',
    scrollForPhone: '.' + CONST.CLASS.CODE_CONTAINER + ' .CodeMirror-scroll {overflow-x: auto !important;overflow-y: hidden !important;}'
  },
  common: '.' + CONST.CLASS.WIZ_BODY + ' .' + CONST.CLASS.CODE_CONTAINER + '{position: relative; padding:8px 0; margin: 5px 0;text-indent:0; text-align:left;}' + // 专门用于 CodeMirror 之间间隔，并且可以自动添加空行
  '.CodeMirror {font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace; color: black; font-size: 10.5pt; font-size: 0.875rem}' + '.' + CONST.CLASS.WIZ_BODY + ' .' + CONST.CLASS.CODE_CONTAINER + ' .CodeMirror div {margin-top: 0; margin-bottom: 0;}' + '.CodeMirror-lines {padding: 4px 0;}' + '.CodeMirror pre {padding: 0 4px;}' + '.CodeMirror pre.CodeMirror-line {min-height: 24px;}' + '.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {background-color: white;}' + '.CodeMirror-gutters {border-right: 1px solid #ddd; background-color: #f7f7f7; white-space: nowrap;}' + '.CodeMirror-linenumbers {}' + '.CodeMirror-linenumber {padding: 0 3px 0 5px; min-width: 20px; text-align: right; color: #999; white-space: nowrap;}' + '.CodeMirror-guttermarker {color: black;}' + '.CodeMirror-guttermarker-subtle {color: #999;}' + '.CodeMirror-cursor {border-left: 1px solid black; border-right: none; width: 0;}' + '.CodeMirror div.CodeMirror-secondarycursor {border-left: 1px solid silver;}' + '.cm-fat-cursor .CodeMirror-cursor {width: auto; border: 0 !important; background: #7e7;}' + '.cm-fat-cursor div.CodeMirror-cursors {z-index: 1;}' + '.cm-fat-cursor-mark {background-color: rgba(20, 255, 20, 0.5);-webkit-animation: blink 1.06s steps(1) infinite;-moz-animation: blink 1.06s steps(1) infinite;animation: blink 1.06s steps(1) infinite;}' + '.cm-animate-fat-cursor {width: auto; border: 0; -webkit-animation: blink 1.06s steps(1) infinite; -moz-animation: blink 1.06s steps(1) infinite; animation: blink 1.06s steps(1) infinite; background-color: #7e7;}' + '@-moz-keyframes blink {' + '  0% {}' + '  50% { background-color: transparent; }' + '  100% {}' + '}' + '@-webkit-keyframes blink {' + '  0% {}' + '  50% { background-color: transparent; }' + '  100% {}' + '}' + '@keyframes blink {' + '  0% {}' + '  50% { background-color: transparent; }' + '  100% {}' + '}' + '.CodeMirror-overwrite .CodeMirror-cursor {}' + '.cm-tab { display: inline-block; text-decoration: inherit; }' + '.CodeMirror-rulers {position: absolute; left: 0; right: 0; top: -50px; bottom: -20px; overflow: hidden;}' + '.CodeMirror-ruler {border-left: 1px solid #ccc; top: 0; bottom: 0; position: absolute;}' + '.cm-s-default .cm-header {color: blue;}' + '.cm-s-default .cm-quote {color: #090;}' + '.cm-negative {color: #d44;}' + '.cm-positive {color: #292;}' + '.cm-header, .cm-strong {font-weight: bold;}' + '.cm-em {font-style: italic;}' + '.cm-link {text-decoration: underline;}' + '.cm-strikethrough {text-decoration: line-through;}' + '.cm-s-default .cm-keyword {color: #708;}' + '.cm-s-default .cm-atom {color: #219;}' + '.cm-s-default .cm-number {color: #164;}' + '.cm-s-default .cm-def {color: #00f;}' + '.cm-s-default .cm-variable,' + '.cm-s-default .cm-punctuation,' + '.cm-s-default .cm-property,' + '.cm-s-default .cm-operator {}' + '.cm-s-default .cm-variable-2 {color: #05a;}' + '.cm-s-default .cm-variable-3 {color: #085;}' + '.cm-s-default .cm-comment {color: #a50;}' + '.cm-s-default .cm-string {color: #a11;}' + '.cm-s-default .cm-string-2 {color: #f50;}' + '.cm-s-default .cm-meta {color: #555;}' + '.cm-s-default .cm-qualifier {color: #555;}' + '.cm-s-default .cm-builtin {color: #30a;}' + '.cm-s-default .cm-bracket {color: #997;}' + '.cm-s-default .cm-tag {color: #170;}' + '.cm-s-default .cm-attribute {color: #00c;}' + '.cm-s-default .cm-hr {color: #999;}' + '.cm-s-default .cm-link {color: #00c;}' + '.cm-s-default .cm-error {color: #f00;}' + '.cm-invalidchar {color: #f00;}' + '.CodeMirror-composing { border-bottom: 2px solid; }' + 'div.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}' + 'div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}' + '.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }' + '.CodeMirror-activeline-background {background: #e8f2ff;}' +
  // '.CodeMirror {position: relative; overflow: hidden; background: white;}' +
  '.CodeMirror {position: relative; background: #f5f5f5;}' +
  // '.CodeMirror-scroll {overflow: scroll !important; margin-bottom: -30px; margin-right: -30px; padding-bottom: 30px; height: 100%; outline: none; position: relative;}' +
  '.CodeMirror-scroll {overflow: hidden !important; margin-bottom: 0; margin-right: -30px; padding: 16px 30px 16px 0; outline: none; position: relative;}' + '.CodeMirror-sizer {position: relative; border-right: 30px solid transparent;}' + '.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {position: absolute; z-index: 6; display: none;}' + '.CodeMirror-vscrollbar {right: 0; top: 0; overflow-x: hidden; overflow-y: scroll;}' +
  // '.CodeMirror-hscrollbar {bottom: 0; left: 0; overflow-y: hidden; overflow-x: scroll;}' +
  '.CodeMirror-hscrollbar {bottom: 0; left: 0 !important; overflow-y: hidden; overflow-x: scroll;pointer-events: auto !important;outline: none;}' + '.CodeMirror-scrollbar-filler {right: 0; bottom: 0;}' + '.CodeMirror-gutter-filler {left: 0; bottom: 0;}' +
  // '.CodeMirror-gutters {position: absolute; left: 0; top: 0; min-height: 100%; z-index: 3;}' +
  '.CodeMirror-gutters {position: absolute; left: 0; top: -5px; min-height: 100%; z-index: 3;}' + '.CodeMirror-gutter {white-space: normal; height: 100%; display: inline-block; vertical-align: top; margin-bottom: -30px;}' + '.CodeMirror-gutter-wrapper {position: absolute; z-index: 4; background: none !important; border: none !important;}' + '.CodeMirror-gutter-background {position: absolute; top: 0; bottom: 0; z-index: 4;}' + '.CodeMirror-gutter-elt {position: absolute; cursor: default; z-index: 4;}' + '.CodeMirror-gutter-wrapper ::selection { background-color: transparent }' + '.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }' + '.CodeMirror-lines {cursor: text; min-height: 1px;}' + '.CodeMirror pre {-moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0; border-width: 0; background: transparent; font-family: inherit; font-size: inherit; margin: 0; white-space: pre; word-wrap: normal; line-height: inherit; color: inherit; z-index: 2; position: relative; overflow: visible; -webkit-tap-highlight-color: transparent; -webkit-font-variant-ligatures: contextual; font-variant-ligatures: contextual;}' + '.CodeMirror-wrap pre {word-wrap: break-word; white-space: pre-wrap; word-break: normal;}' + '.CodeMirror-linebackground {position: absolute; left: 0; right: 0; top: 0; bottom: 0; z-index: 0;}' + '.CodeMirror-linewidget {position: relative; z-index: 2; padding: 0.1px;}' + '.CodeMirror-widget {}' + '.CodeMirror-rtl pre { direction: rtl; }' + '.CodeMirror-code {outline: none;}' + '.CodeMirror-scroll,.CodeMirror-sizer,.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber {-moz-box-sizing: content-box; box-sizing: content-box;}' + '.CodeMirror-measure {position: absolute; width: 100%; height: 0; overflow: hidden; visibility: hidden;}' + '.CodeMirror-cursor {position: absolute; pointer-events: none;}' + '.CodeMirror-measure pre { position: static; }' + 'div.CodeMirror-cursors {visibility: hidden; position: relative; z-index: 3;}' + 'div.CodeMirror-dragcursors {visibility: visible;}' + '.CodeMirror-focused div.CodeMirror-cursors {visibility: visible;}' + '.CodeMirror-selected { background: #d9d9d9; }' + '.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }' + '.CodeMirror-crosshair { cursor: crosshair; }' + '.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }' + '.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }' + '.cm-searching {background: #ffa; background: rgba(255, 255, 0, .4);}' + '.cm-force-border { padding-right: .1px; }' + '@media print {' + '  .CodeMirror div.CodeMirror-cursors {visibility: hidden;}' + '}' + '.cm-tab-wrap-hack:after { content: ""; }' + 'span.CodeMirror-selectedtext { background: none; }' + '.CodeMirror-activeline-background, .CodeMirror-selected {transition: visibility 0ms 100ms;}' + '.CodeMirror-blur .CodeMirror-activeline-background, .CodeMirror-blur .CodeMirror-selected {visibility:hidden;}' + '.CodeMirror-blur .CodeMirror-matchingbracket {color:inherit !important;outline:none !important;text-decoration:none !important;}' + '.CodeMirror-sizer {min-height:auto !important;}' + '',
  theme: {
    'base16-dark': '.cm-s-base16-dark.CodeMirror { background: #151515; color: #e0e0e0; }' + '.cm-s-base16-dark div.CodeMirror-selected { background: #303030; }' + '.cm-s-base16-dark .CodeMirror-line::selection, .cm-s-base16-dark .CodeMirror-line > span::selection, .cm-s-base16-dark .CodeMirror-line > span > span::selection { background: rgba(48, 48, 48, .99); }' + '.cm-s-base16-dark .CodeMirror-line::-moz-selection, .cm-s-base16-dark .CodeMirror-line > span::-moz-selection, .cm-s-base16-dark .CodeMirror-line > span > span::-moz-selection { background: rgba(48, 48, 48, .99); }' + '.cm-s-base16-dark .CodeMirror-gutters { background: #151515; border-right: 0px; }' + '.cm-s-base16-dark .CodeMirror-guttermarker { color: #ac4142; }' + '.cm-s-base16-dark .CodeMirror-guttermarker-subtle { color: #505050; }' + '.cm-s-base16-dark .CodeMirror-linenumber { color: #505050; }' + '.cm-s-base16-dark .CodeMirror-cursor { border-left: 1px solid #b0b0b0; }' + '.cm-s-base16-dark span.cm-comment { color: #8f5536; }' + '.cm-s-base16-dark span.cm-atom { color: #aa759f; }' + '.cm-s-base16-dark span.cm-number { color: #aa759f; }' + '.cm-s-base16-dark span.cm-property, .cm-s-base16-dark span.cm-attribute { color: #90a959; }' + '.cm-s-base16-dark span.cm-keyword { color: #ac4142; }' + '.cm-s-base16-dark span.cm-string { color: #f4bf75; }' + '.cm-s-base16-dark span.cm-variable { color: #90a959; }' + '.cm-s-base16-dark span.cm-variable-2 { color: #6a9fb5; }' + '.cm-s-base16-dark span.cm-def { color: #d28445; }' + '.cm-s-base16-dark span.cm-bracket { color: #e0e0e0; }' + '.cm-s-base16-dark span.cm-tag { color: #ac4142; }' + '.cm-s-base16-dark span.cm-link { color: #aa759f; }' + '.cm-s-base16-dark span.cm-error { background: #ac4142; color: #b0b0b0; }' + '.cm-s-base16-dark .CodeMirror-activeline-background { background: #202020; }' + '.cm-s-base16-dark .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }',

    'base16-light': '.cm-s-base16-light.CodeMirror { background: #f5f5f5; color: #202020; }' + '.cm-s-base16-light div.CodeMirror-selected { background: #e0e0e0; }' + '.cm-s-base16-light .CodeMirror-line::selection, .cm-s-base16-light .CodeMirror-line > span::selection, .cm-s-base16-light .CodeMirror-line > span > span::selection { background: #e0e0e0; }' + '.cm-s-base16-light .CodeMirror-line::-moz-selection, .cm-s-base16-light .CodeMirror-line > span::-moz-selection, .cm-s-base16-light .CodeMirror-line > span > span::-moz-selection { background: #e0e0e0; }' + '.cm-s-base16-light .CodeMirror-gutters { background: #f5f5f5; border-right: 0px; }' + '.cm-s-base16-light .CodeMirror-guttermarker { color: #ac4142; }' + '.cm-s-base16-light .CodeMirror-guttermarker-subtle { color: #b0b0b0; }' + '.cm-s-base16-light .CodeMirror-linenumber { color: #b0b0b0; }' + '.cm-s-base16-light .CodeMirror-cursor { border-left: 1px solid #505050; }' + '.cm-s-base16-light span.cm-comment { color: #8f5536; }' + '.cm-s-base16-light span.cm-atom { color: #aa759f; }' + '.cm-s-base16-light span.cm-number { color: #aa759f; }' + '.cm-s-base16-light span.cm-property, .cm-s-base16-light span.cm-attribute { color: #90a959; }' + '.cm-s-base16-light span.cm-keyword { color: #ac4142; }' + '.cm-s-base16-light span.cm-string { color: #f4bf75; }' + '.cm-s-base16-light span.cm-variable { color: #90a959; }' + '.cm-s-base16-light span.cm-variable-2 { color: #6a9fb5; }' + '.cm-s-base16-light span.cm-def { color: #d28445; }' + '.cm-s-base16-light span.cm-bracket { color: #202020; }' + '.cm-s-base16-light span.cm-tag { color: #ac4142; }' + '.cm-s-base16-light span.cm-link { color: #aa759f; }' + '.cm-s-base16-light span.cm-error { background: #ac4142; color: #505050; }' + '.cm-s-base16-light .CodeMirror-activeline-background { background: #DDDCDC; }' + '.cm-s-base16-light .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }',

    'blackboard': '.cm-s-blackboard.CodeMirror { background: #0C1021; color: #F8F8F8; }' + '.cm-s-blackboard div.CodeMirror-selected { background: #253B76; }' + '.cm-s-blackboard .CodeMirror-line::selection, .cm-s-blackboard .CodeMirror-line > span::selection, .cm-s-blackboard .CodeMirror-line > span > span::selection { background: rgba(37, 59, 118, .99); }' + '.cm-s-blackboard .CodeMirror-line::-moz-selection, .cm-s-blackboard .CodeMirror-line > span::-moz-selection, .cm-s-blackboard .CodeMirror-line > span > span::-moz-selection { background: rgba(37, 59, 118, .99); }' + '.cm-s-blackboard .CodeMirror-gutters { background: #0C1021; border-right: 0; }' + '.cm-s-blackboard .CodeMirror-guttermarker { color: #FBDE2D; }' + '.cm-s-blackboard .CodeMirror-guttermarker-subtle { color: #888; }' + '.cm-s-blackboard .CodeMirror-linenumber { color: #888; }' + '.cm-s-blackboard .CodeMirror-cursor { border-left: 1px solid #A7A7A7; }' + '.cm-s-blackboard .cm-keyword { color: #FBDE2D; }' + '.cm-s-blackboard .cm-atom { color: #D8FA3C; }' + '.cm-s-blackboard .cm-number { color: #D8FA3C; }' + '.cm-s-blackboard .cm-def { color: #8DA6CE; }' + '.cm-s-blackboard .cm-variable { color: #FF6400; }' + '.cm-s-blackboard .cm-operator { color: #FBDE2D; }' + '.cm-s-blackboard .cm-comment { color: #AEAEAE; }' + '.cm-s-blackboard .cm-string { color: #61CE3C; }' + '.cm-s-blackboard .cm-string-2 { color: #61CE3C; }' + '.cm-s-blackboard .cm-meta { color: #D8FA3C; }' + '.cm-s-blackboard .cm-builtin { color: #8DA6CE; }' + '.cm-s-blackboard .cm-tag { color: #8DA6CE; }' + '.cm-s-blackboard .cm-attribute { color: #8DA6CE; }' + '.cm-s-blackboard .cm-header { color: #FF6400; }' + '.cm-s-blackboard .cm-hr { color: #AEAEAE; }' + '.cm-s-blackboard .cm-link { color: #8DA6CE; }' + '.cm-s-blackboard .cm-error { background: #9D1E15; color: #F8F8F8; }' + '.cm-s-blackboard .CodeMirror-activeline-background { background: #3C3636; }' + '.cm-s-blackboard .CodeMirror-matchingbracket { outline:1px solid grey;color:white !important; }',

    'eclipse': '.cm-s-eclipse span.cm-meta { color: #FF1717; }' + '.cm-s-eclipse span.cm-keyword { line-height: 1em; font-weight: bold; color: #7F0055; }' + '.cm-s-eclipse span.cm-atom { color: #219; }' + '.cm-s-eclipse span.cm-number { color: #164; }' + '.cm-s-eclipse span.cm-def { color: #00f; }' + '.cm-s-eclipse span.cm-variable { color: black; }' + '.cm-s-eclipse span.cm-variable-2 { color: #0000C0; }' + '.cm-s-eclipse span.cm-variable-3 { color: #0000C0; }' + '.cm-s-eclipse span.cm-property { color: black; }' + '.cm-s-eclipse span.cm-operator { color: black; }' + '.cm-s-eclipse span.cm-comment { color: #3F7F5F; }' + '.cm-s-eclipse span.cm-string { color: #2A00FF; }' + '.cm-s-eclipse span.cm-string-2 { color: #f50; }' + '.cm-s-eclipse span.cm-qualifier { color: #555; }' + '.cm-s-eclipse span.cm-builtin { color: #30a; }' + '.cm-s-eclipse span.cm-bracket { color: #cc7; }' + '.cm-s-eclipse span.cm-tag { color: #170; }' + '.cm-s-eclipse span.cm-attribute { color: #00c; }' + '.cm-s-eclipse span.cm-link { color: #219; }' + '.cm-s-eclipse span.cm-error { color: #f00; }' + '.cm-s-eclipse .CodeMirror-activeline-background { background: #e8f2ff; }' + '.cm-s-eclipse .CodeMirror-matchingbracket { outline:1px solid grey; color:black !important; }',

    'material': '.cm-s-material.CodeMirror {background-color: #263238; color: rgba(233, 237, 237, 1);}' + '.cm-s-material .CodeMirror-gutters {background: #263238; color: rgb(83,127,126); border: none;}' + '.cm-s-material .CodeMirror-guttermarker, .cm-s-material .CodeMirror-guttermarker-subtle, .cm-s-material .CodeMirror-linenumber { color: rgb(83,127,126); }' + '.cm-s-material .CodeMirror-cursor { border-left: 1px solid #f8f8f0; }' + '.cm-s-material div.CodeMirror-selected { background: rgba(255, 255, 255, 0.15); }' + '.cm-s-material.CodeMirror-focused div.CodeMirror-selected { background: rgba(255, 255, 255, 0.10); }' + '.cm-s-material .CodeMirror-line::selection, .cm-s-material .CodeMirror-line > span::selection, .cm-s-material .CodeMirror-line > span > span::selection { background: rgba(255, 255, 255, 0.10); }' + '.cm-s-material .CodeMirror-line::-moz-selection, .cm-s-material .CodeMirror-line > span::-moz-selection, .cm-s-material .CodeMirror-line > span > span::-moz-selection { background: rgba(255, 255, 255, 0.10); }' + '.cm-s-material .CodeMirror-activeline-background { background: rgba(0, 0, 0, 0); }' + '.cm-s-material .cm-keyword { color: rgba(199, 146, 234, 1); }' + '.cm-s-material .cm-operator { color: rgba(233, 237, 237, 1); }' + '.cm-s-material .cm-variable-2 { color: #80CBC4; }' + '.cm-s-material .cm-variable-3 { color: #82B1FF; }' + '.cm-s-material .cm-builtin { color: #DECB6B; }' + '.cm-s-material .cm-atom { color: #F77669; }' + '.cm-s-material .cm-number { color: #F77669; }' + '.cm-s-material .cm-def { color: rgba(233, 237, 237, 1); }' + '.cm-s-material .cm-string { color: #C3E88D; }' + '.cm-s-material .cm-string-2 { color: #80CBC4; }' + '.cm-s-material .cm-comment { color: #546E7A; }' + '.cm-s-material .cm-variable { color: #82B1FF; }' + '.cm-s-material .cm-tag { color: #80CBC4; }' + '.cm-s-material .cm-meta { color: #80CBC4; }' + '.cm-s-material .cm-attribute { color: #FFCB6B; }' + '.cm-s-material .cm-property { color: #80CBAE; }' + '.cm-s-material .cm-qualifier { color: #DECB6B; }' + '.cm-s-material .cm-variable-3 { color: #DECB6B; }' + '.cm-s-material .cm-tag { color: rgba(255, 83, 112, 1); }' + '.cm-s-material .cm-error {color: rgba(255, 255, 255, 1.0); background-color: #EC5F67;}' + '.cm-s-material .CodeMirror-matchingbracket {text-decoration: underline; color: white !important;}',

    'monokai': '.cm-s-monokai.CodeMirror { background: #272822; color: #f8f8f2; }' + '.cm-s-monokai div.CodeMirror-selected { background: #49483E; }' + '.cm-s-monokai .CodeMirror-line::selection, .cm-s-monokai .CodeMirror-line > span::selection, .cm-s-monokai .CodeMirror-line > span > span::selection { background: rgba(73, 72, 62, .99); }' + '.cm-s-monokai .CodeMirror-line::-moz-selection, .cm-s-monokai .CodeMirror-line > span::-moz-selection, .cm-s-monokai .CodeMirror-line > span > span::-moz-selection { background: rgba(73, 72, 62, .99); }' + '.cm-s-monokai .CodeMirror-gutters { background: #272822; border-right: 0px; }' + '.cm-s-monokai .CodeMirror-guttermarker { color: white; }' + '.cm-s-monokai .CodeMirror-guttermarker-subtle { color: #d0d0d0; }' + '.cm-s-monokai .CodeMirror-linenumber { color: #d0d0d0; }' + '.cm-s-monokai .CodeMirror-cursor { border-left: 1px solid #f8f8f0; }' + '.cm-s-monokai span.cm-comment { color: #75715e; }' + '.cm-s-monokai span.cm-atom { color: #ae81ff; }' + '.cm-s-monokai span.cm-number { color: #ae81ff; }' + '.cm-s-monokai span.cm-property, .cm-s-monokai span.cm-attribute { color: #a6e22e; }' + '.cm-s-monokai span.cm-keyword { color: #f92672; }' + '.cm-s-monokai span.cm-builtin { color: #66d9ef; }' + '.cm-s-monokai span.cm-string { color: #e6db74; }' + '.cm-s-monokai span.cm-variable { color: #f8f8f2; }' + '.cm-s-monokai span.cm-variable-2 { color: #9effff; }' + '.cm-s-monokai span.cm-variable-3 { color: #66d9ef; }' + '.cm-s-monokai span.cm-def { color: #fd971f; }' + '.cm-s-monokai span.cm-bracket { color: #f8f8f2; }' + '.cm-s-monokai span.cm-tag { color: #f92672; }' + '.cm-s-monokai span.cm-header { color: #ae81ff; }' + '.cm-s-monokai span.cm-link { color: #ae81ff; }' + '.cm-s-monokai span.cm-error { background: #f92672; color: #f8f8f0; }' + '.cm-s-monokai .CodeMirror-activeline-background { background: #373831; }' + '.cm-s-monokai .CodeMirror-matchingbracket {text-decoration: underline; color: white !important;}',

    'tomorrow-night-eighties': '.cm-s-tomorrow-night-eighties.CodeMirror { background: #000000; color: #CCCCCC; }' + '.cm-s-tomorrow-night-eighties div.CodeMirror-selected { background: #2D2D2D; }' + '.cm-s-tomorrow-night-eighties .CodeMirror-line::selection, .cm-s-tomorrow-night-eighties .CodeMirror-line > span::selection, .cm-s-tomorrow-night-eighties .CodeMirror-line > span > span::selection { background: rgba(45, 45, 45, 0.99); }' + '.cm-s-tomorrow-night-eighties .CodeMirror-line::-moz-selection, .cm-s-tomorrow-night-eighties .CodeMirror-line > span::-moz-selection, .cm-s-tomorrow-night-eighties .CodeMirror-line > span > span::-moz-selection { background: rgba(45, 45, 45, 0.99); }' + '.cm-s-tomorrow-night-eighties .CodeMirror-gutters { background: #000000; border-right: 0px; }' + '.cm-s-tomorrow-night-eighties .CodeMirror-guttermarker { color: #f2777a; }' + '.cm-s-tomorrow-night-eighties .CodeMirror-guttermarker-subtle { color: #777; }' + '.cm-s-tomorrow-night-eighties .CodeMirror-linenumber { color: #515151; }' + '.cm-s-tomorrow-night-eighties .CodeMirror-cursor { border-left: 1px solid #6A6A6A; }' + '.cm-s-tomorrow-night-eighties span.cm-comment { color: #d27b53; }' + '.cm-s-tomorrow-night-eighties span.cm-atom { color: #a16a94; }' + '.cm-s-tomorrow-night-eighties span.cm-number { color: #a16a94; }' + '.cm-s-tomorrow-night-eighties span.cm-property, .cm-s-tomorrow-night-eighties span.cm-attribute { color: #99cc99; }' + '.cm-s-tomorrow-night-eighties span.cm-keyword { color: #f2777a; }' + '.cm-s-tomorrow-night-eighties span.cm-string { color: #ffcc66; }' + '.cm-s-tomorrow-night-eighties span.cm-variable { color: #99cc99; }' + '.cm-s-tomorrow-night-eighties span.cm-variable-2 { color: #6699cc; }' + '.cm-s-tomorrow-night-eighties span.cm-def { color: #f99157; }' + '.cm-s-tomorrow-night-eighties span.cm-bracket { color: #CCCCCC; }' + '.cm-s-tomorrow-night-eighties span.cm-tag { color: #f2777a; }' + '.cm-s-tomorrow-night-eighties span.cm-link { color: #a16a94; }' + '.cm-s-tomorrow-night-eighties span.cm-error { background: #f2777a; color: #6A6A6A; }' + '.cm-s-tomorrow-night-eighties .CodeMirror-activeline-background { background: #343600; }' + '.cm-s-tomorrow-night-eighties .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }'
  }
};

var CodeStyle = function CodeStyle() {
  var _this = this;

  var core = null,
      env = null,
      wizStyle = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    wizStyle = core.require.wizStyle;
  };

  this.clearStyle = function () {
    var styleList = env.doc.getElementsByName(CONST.NAME.CODE_STYLE);
    for (var i = styleList.length - 1; i >= 0; i--) {
      var style = styleList[i];
      var theme = style.id.replace(CONST.ID.CODE_STYLE + '-', '');
      if (!env.doc.querySelector('.' + CONST.CLASS.CODE_CONTAINER + '[data-theme=' + theme + ']')) {
        wizStyle.removeStyleById(style.id);
      }
    }
    var codeList = env.doc.querySelectorAll('.' + CONST.CLASS.CODE_CONTAINER);
    if (codeList.length === 0) {
      wizStyle.removeStyleById(CONST.ID.CODE_STYLE);
    }
  };
  this.initCommon = function () {
    wizStyle.replaceStyleById(CONST.ID.CODE_STYLE, CSS.common, false);
    _this.insertTemp();
  };
  this.insertCommon = function () {
    var style = env.doc.getElementById(CONST.ID.CODE_STYLE);
    if (!style) {
      wizStyle.replaceStyleById(CONST.ID.CODE_STYLE, CSS.common, false);
    }
  };
  this.insertTemp = function () {
    wizStyle.insertStyle({
      id: CONST.ID.TMP_STYLE_PRE + 'code_common',
      name: CONST.NAME.TMP_STYLE
    }, CSS.tmp.common);

    if (env.client.type.isPhone || env.client.type.isPad) {
      wizStyle.insertStyle({
        id: CONST.ID.TMP_STYLE_PRE + 'code_phone',
        name: CONST.NAME.TMP_STYLE
      }, CSS.tmp.phone);
    }

    if (env.client.type.isIOS && env.browser.isIPhone) {
      // iphone 当出现 div width 设置宽度超出屏幕时，该 div 内字体会变大
      wizStyle.insertStyle({
        id: CONST.ID.TMP_STYLE_PRE + 'code_reader_for_iphone',
        name: CONST.NAME.TMP_STYLE
      }, CSS.tmp.readerForIphone);
    }

    wizStyle.insertStyle({
      id: CONST.ID.TMP_STYLE_PRE + 'code_reader',
      name: CONST.NAME.TMP_STYLE
    }, CSS.tmp.reader);
  };
  this.fixScrollStyle = function (lineWrapping) {
    var id = CONST.ID.TMP_STYLE_PRE + 'code_scroll_for_phone';
    if (!lineWrapping && (env.client.type.isPhone || env.client.type.isPad)) {

      wizStyle.insertStyle({
        id: id,
        name: CONST.NAME.TMP_STYLE
      }, CSS.tmp.scrollForPhone);
    } else {
      wizStyle.removeStyleById(id);
    }
  };
  this.insertTheme = function (theme) {
    if (CSS.theme[theme] && !env.doc.querySelector('#' + CONST.ID.CODE_STYLE + '-' + theme)) {
      wizStyle.insertStyle({
        id: CONST.ID.CODE_STYLE + '-' + theme,
        name: CONST.NAME.CODE_STYLE
      }, CSS.theme[theme]);
    }
  };
};

module.exports = CodeStyle;

},{"../../config/const":388}],364:[function(require,module,exports){
'use strict';

/**
 * 代码区域操作的基本方法集合
 */
var CONST = require('../../config/const');
var utils = require('../../libs/utils');

var CODE_MIRROR = {
  MODE: {
    'APL': {
      cm: 'text/apl',
      file: 'apl',
      same: ['apollo']
    },
    'C': {
      cm: 'text/x-csrc',
      file: 'clike',
      same: []
    },
    'C++': {
      cm: 'text/x-c++src',
      file: 'clike',
      same: ['cpp']
    },
    'C#': {
      cm: 'text/x-csharp',
      file: 'clike',
      same: ['cs']
    },
    'CSS': {
      cm: 'text/css',
      file: 'css',
      same: []
    },
    'Dart': {
      cm: 'application/dart',
      file: ['clike', 'dart'],
      same: []
    },
    'Erlang': {
      cm: 'text/x-erlang',
      file: 'erlang',
      same: []
    },
    'Go': {
      cm: 'text/x-go',
      file: 'go',
      same: []
    },
    'HTML': {
      cm: 'text/html',
      file: [['xml', 'css', 'javascript', 'vbscript'], ['htmlmixed']],
      same: []
    },
    'Java': {
      cm: 'text/x-java',
      file: 'clike',
      same: []
    },
    'JavaScript': {
      cm: 'text/javascript',
      file: 'javascript',
      same: ['js']
    },
    'JSX': {
      cm: 'text/jsx',
      file: [['xml', 'javascript'], ['jsx']],
      same: []
    },
    'Julia': {
      cm: 'text/x-julia',
      file: 'julia',
      same: []
    },
    'Lisp': {
      cm: 'text/x-common-lisp',
      file: 'commonlisp',
      same: []
    },
    'Lua': {
      cm: 'text/x-lua',
      file: 'lua',
      same: []
    },
    'Octave (MATLAB)': {
      cm: 'text/x-octave',
      file: 'octave',
      same: ['matlab', 'octave']
    },
    'Objective-C': {
      cm: 'text/x-objectivec',
      file: 'clike',
      same: []
    },
    'Pascal': {
      cm: 'text/x-pascal',
      file: 'pascal',
      same: []
    },
    'Perl': {
      cm: 'text/x-perl',
      file: 'perl',
      same: []
    },
    'PHP': {
      cm: 'application/x-httpd-php',
      file: 'php',
      same: []
    },
    'Python': {
      cm: 'text/x-python',
      file: 'python',
      same: ['py']
    },
    'Ruby': {
      cm: 'text/x-ruby',
      file: 'ruby',
      same: ['rb']
    },
    'Rust': {
      cm: 'text/x-rustsrc',
      file: 'rust',
      same: []
    },
    'Shell': {
      cm: 'text/x-sh',
      file: 'shell',
      same: ['sh']
    },
    'SQL': {
      cm: 'text/x-sql',
      file: 'sql',
      same: []
    },
    'Swift': {
      cm: 'text/x-swift',
      file: 'swift',
      same: []
    },
    'VBScript': {
      cm: 'text/vbscript',
      file: 'vbscript',
      same: ['basic', 'vb']
    },
    'Verilog': {
      cm: 'text/x-verilog',
      file: 'verilog',
      same: []
    },
    'VHDL': {
      cm: 'text/x-vhdl',
      file: 'vhdl',
      same: []
    },
    'XML': {
      cm: 'application/xml',
      file: 'xml',
      same: []
    },
    'XSL': {
      cm: 'application/xml',
      file: 'xml',
      same: []
    },
    'YAML': {
      cm: 'text/x-yaml',
      file: 'yaml',
      same: []
    }
  },
  THEME: {
    'default': {
      name: 'L1 (default)',
      same: ['L1']
    },
    'base16-light': {
      name: 'L2 (base16-light)',
      same: ['L2']
    },
    'eclipse': {
      name: 'L3 (eclipse)',
      same: ['L3']
    },
    'base16-dark': {
      name: 'D1 (base16-dark)',
      same: ['D1']
    },
    'blackboard': {
      name: 'D2 (blackboard)',
      same: ['D2']
    },
    'material': {
      name: 'D3 (material)',
      same: ['D3']
    },
    'monokai': {
      name: 'D4 (monokai)',
      same: ['D4']
    },
    'tomorrow-night-eighties': {
      name: 'D5 (tomorrow)',
      same: ['D5']
    }
  }
};

var ModeOptions = [];
var ThemeOptions = [];
var modeDic = {};
var themeDic = {};

(function () {
  for (var key in CODE_MIRROR.MODE) {
    if (CODE_MIRROR.MODE.hasOwnProperty(key)) {
      ModeOptions.push({
        text: key,
        value: key
      });
      var same = CODE_MIRROR.MODE[key].same;
      modeDic[key.toLowerCase()] = key;
      for (var i = 0; i < same.length; i++) {
        modeDic[same[i].toLowerCase()] = key;
      }
    }
  }
  for (var _key in CODE_MIRROR.THEME) {
    if (CODE_MIRROR.THEME.hasOwnProperty(_key)) {
      ThemeOptions.push({
        text: CODE_MIRROR.THEME[_key].name,
        value: _key
      });
      var _same = CODE_MIRROR.THEME[_key].same;
      themeDic[_key.toLowerCase()] = _key;
      for (var _i = 0; _i < _same.length; _i++) {
        themeDic[_same[_i].toLowerCase()] = _key;
      }
    }
  }
})();

var CodeUtils = function CodeUtils() {
  var _this = this;

  var core = null;
  var env = null;
  var lang = null;
  var codeCore = null;
  var codeStyle = null;
  var domUtils = null;
  var historyUtils = null;
  var rangeUtils = null;
  var selectPlugin = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    lang = core.lang;
    codeCore = core.require.codeCore;
    codeStyle = core.require.codeStyle;
    domUtils = core.require.domUtils;
    historyUtils = core.require.historyUtils;
    rangeUtils = core.require.rangeUtils;
    selectPlugin = core.require.selectPlugin;
  };

  var createLineWrapOption = function createLineWrapOption() {
    var div = env.doc.createElement('div');
    var checkMark = env.doc.createElement('i');
    domUtils.addClass(checkMark, 'icon-checkmark editor-icon');
    if (env.options.code.lineWrapping) {
      domUtils.addClass(checkMark, 'active');
    }
    var span = env.doc.createElement('span');
    span.innerText = lang.Code.Wrap;
    domUtils.css(span, { 'margin-right': '8px' });
    div.appendChild(span);
    div.appendChild(checkMark);
    return div;
  };
  var createModeOption = function createModeOption(mode) {
    var div = env.doc.createElement('div');
    var selector = createNativeSelector(ModeOptions, mode);
    var optionText = env.doc.createElement('span');
    optionText.innerText = mode;
    domUtils.css(div, {
      position: 'relative'
    });
    domUtils.css(selector, {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      opacity: 0
    });
    div.appendChild(optionText);
    div.appendChild(selector);
    div.selector = selector;
    div.optionText = optionText;
    domUtils.addClass(div, CONST.CLASS.CODE_TOOLS_MODE);
    return div;
  };
  var createThemeOption = function createThemeOption(theme) {
    var div = env.doc.createElement('div');
    var selector = createNativeSelector(ThemeOptions, theme);
    var optionText = env.doc.createElement('span');
    optionText.innerText = CODE_MIRROR.THEME[theme].name;
    domUtils.css(div, {
      position: 'relative'
    });
    domUtils.css(selector, {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      opacity: 0
    });
    div.appendChild(optionText);
    div.appendChild(selector);
    div.selector = selector;
    div.optionText = optionText;
    domUtils.addClass(div, CONST.CLASS.CODE_TOOLS_THEME);
    return div;
  };
  var createNativeSelector = function createNativeSelector(optionsData, curValue) {
    var select = env.doc.createElement('select');
    for (var i = 0, j = optionsData.length; i < j; i++) {
      var data = optionsData[i];
      var text = data.text;
      var value = data.value;
      var option = env.doc.createElement('option');
      option.textContent = text;
      domUtils.attr(option, { 'value': value });
      if (value === curValue) {
        select.value = value;
      }
      select.appendChild(option);
    }
    return select;
  };

  this.canCreateCode = function () {
    var range = rangeUtils.getRange();
    if (!range || _this.getContainerFromChild(range.startContainer) || domUtils.getParentByClass(range.startContainer, CONST.CLASS.TABLE_CONTAINER, true)) {
      // CodeMirror / Table 内
      return false;
    }
    return true;
  };
  this.changeLineWrapping = function (lineWrapping) {
    var containerList = _this.getContainerList();
    env.options.code.lineWrapping = lineWrapping;
    codeStyle.fixScrollStyle(lineWrapping);
    for (var i = 0; i < containerList.length; i++) {
      var container = containerList[i];
      var cm = container.codeMirror;
      cm.setOption('lineWrapping', lineWrapping);
      cm.setOption('scrollbarStyle', lineWrapping ? 'null' : 'native');
    }
    var checkMarkList = env.body.querySelectorAll('.' + CONST.CLASS.CODE_TOOLS_MORE + ' .icon-checkmark');
    if (lineWrapping) {
      domUtils.addClass(checkMarkList, 'active');
    } else {
      domUtils.removeClass(checkMarkList, 'active');
    }

    if (env.win.localStorage) {
      env.win.localStorage.setItem(CONST.CODE.StorageKey.Wrap, lineWrapping ? '1' : '');
    }
  };
  this.changeMode = function (container, mode, readOnly) {
    if (!container) {
      return;
    }
    var cm = container.codeMirror;
    if (!cm) {
      return;
    }
    cm.setOption('mode', CODE_MIRROR.MODE[mode].cm);
    domUtils.attr(container, {
      'data-mode': mode
    });
    if (env.win.localStorage && !readOnly) {
      env.win.localStorage.setItem(CONST.CODE.StorageKey.Mode, mode);
    }
  };
  this.changeTheme = function (container, theme, readOnly) {
    if (!container) {
      return;
    }
    theme = theme || 'default';

    var cm = container.codeMirror;
    if (!cm) {
      return;
    }
    codeStyle.insertTheme(theme);

    cm.setOption('theme', theme);
    domUtils.attr(container, {
      'data-theme': theme
    });
    if (env.win.localStorage && !readOnly) {
      env.win.localStorage.setItem(CONST.CODE.StorageKey.Theme, theme);
    }
  };
  this.clearCodeMirror = function (containerList) {
    // if (!codeCore.hasLoaded) {
    //   return;
    // }
    containerList = containerList ? containerList : _this.getContainerList();
    for (var i = containerList.length - 1; i >= 0; i--) {
      var container = containerList[i];
      if (container.codeMirror) {
        var cm = container.codeMirror;
        if (cm) {
          cm.setOption('readOnly', true);
          cm.setOption('styleActiveLine', false);
          cm.getDoc().clearHistory();
        }
      }
    }
  };
  this.clearCodeForMarkdown = function (tmpBody) {
    // if (!codeCore.hasLoaded) {
    //   return;
    // }
    var containerList = tmpBody.querySelectorAll('.' + CONST.CLASS.CODE_CONTAINER);
    var readOnly = env.readonly;
    for (var i = containerList.length - 1; i >= 0; i--) {
      var container = containerList[i];
      var textarea = container.querySelector('textarea');
      var mode = _this.getCmMode(container, readOnly);
      var theme = _this.getCmTheme(container, readOnly);
      var src = '```' + mode + ',' + theme + '\n' + textarea.value + '\n```';

      var pre = env.doc.createElement('pre');
      pre.appendChild(env.doc.createTextNode(src));
      domUtils.before(pre, container);
      domUtils.remove(container);
    }
  };
  this.fixCode = function (code) {
    if (!code) {
      return null;
    }
    var container = code.parentNode;
    if (domUtils.hasClass(container, CONST.CLASS.CODE_CONTAINER)) {
      return null;
    }
    if (container === env.body || container.childNodes.length !== 1) {
      container = env.doc.createElement('div');
      domUtils.before(container, code);
      container.appendChild(code);
    }
    return container;
  };
  this.fixCodeContainer = function (options) {
    if (!codeCore.hasLoaded) {
      codeCore.on({}, function () {
        if (codeCore.hasLoaded) {
          _this.fixCodeContainer(options);
        }
      });
      return;
    }
    options = options || {};
    var containerList = options.container ? [options.container] : _this.getContainerList(options.body);
    for (var i = containerList.length - 1; i >= 0; i--) {
      var container = containerList[i];
      // 必须记住 id，需要将 id 恢复到对应的 CodeMirror 内，
      // 否则会导致 Undo、Redo 时无法找到 对应的 History
      var id = container.id;
      // console.log(container);
      // codemirror 容器 的 style/id/class 必须清除，避免非 codeMirror 时仍保留此信息
      domUtils.attr(container, {
        style: null,
        id: null,
        class: null
      });
      _this.fixCodeContainerParent(container);
      if (env.options.reader.codeNoIDE) {
        _this.initCodeNoIDE(container);
      } else {
        if (id) {
          container.id = id;
        }
        _this.initCodeMirror({
          container: container,
          readOnly: !!options.readOnly || env.readonly
        });
      }
    }
  };
  this.fixCodeContainerParent = function (container) {
    var parentList = void 0,
        parent = void 0;

    // 避免将 有序、无序列表打断
    var orderObj = domUtils.getParentByTagName(container, ['ol', 'ul'], true);
    if (orderObj) {
      return;
    }
    parentList = domUtils.getParentList(container);
    if (parentList.length > 0) {
      if (domUtils.hasClass(parentList[0], CONST.CLASS.WIZ_EIDTOR_PREVIEW_CONTAINER) || domUtils.hasClass(parentList[0], CONST.CLASS.WIZ_BODY)) {
        return;
      }
      parent = domUtils.splitDomSingle(parentList[0], container);
      domUtils.before(container, parent);
      domUtils.remove(parent);
    }
  };
  this.focusToFirst = function (cm) {
    if (!cm) {
      return;
    }
    cm.focus();
    cm.setCursor({ line: 0, ch: 0 });
  };
  this.focusToLast = function (cm) {
    if (!cm) {
      return;
    }
    cm.focus();
    cm.setCursor({
      line: cm.lastLine(),
      ch: cm.getLineHandle(cm.lastLine()).text.length
    });
  };
  this.getCmMode = function (container, readOnly) {
    var mode = (container.getAttribute('data-mode') || '').toLowerCase();
    var lastMode = '';
    if (container.isNew && env.win.localStorage && !readOnly) {
      lastMode = (env.win.localStorage.getItem(CONST.CODE.StorageKey.Mode) || '').toLowerCase();
    }
    return modeDic[mode] || modeDic[lastMode] || 'JavaScript';
  };
  this.getCmTheme = function (container, readOnly) {
    var theme = (container.getAttribute('data-theme') || '').toLowerCase();
    var lastTheme = '';
    if (container.isNew && env.win.localStorage && !readOnly) {
      lastTheme = (env.win.localStorage.getItem(CONST.CODE.StorageKey.Theme) || '').toLowerCase();
    }
    return themeDic[theme] || themeDic[lastTheme] || 'default';
  };
  this.getCmWrapper = function (container) {
    return container.querySelector('.' + CONST.CLASS.CODE_MIRROR);
  };
  this.getContainerFromChild = function (target) {
    return domUtils.getParentByClass(target, CONST.CLASS.CODE_CONTAINER, true);
  };
  this.getContainerList = function (body) {
    body = body || env.body;
    return body.querySelectorAll('.' + CONST.CLASS.CODE_CONTAINER);
  };
  this.getToolsFromChild = function (target) {
    return domUtils.getParentByClass(target, CONST.CLASS.CODE_TOOLS, true);
  };
  this.initCodeNoIDE = function (container) {
    if (!container) {
      return;
    }
    _this.removeCmWrapper(container);

    var textarea = container.querySelector('textarea');
    var codeSrc = '',
        pre = void 0,
        code = void 0;
    if (textarea) {
      codeSrc = textarea.textContent;
      pre = env.doc.createElement('pre');
      code = env.doc.createElement('code');
      pre.appendChild(code);
      code.textContent = codeSrc;
      domUtils.before(pre, textarea);
      domUtils.remove(textarea);
    }
  };
  this.initCodeMirror = function (_options) {
    var container = _options.container;
    var readOnly = _options.readOnly;
    if (!container) {
      return;
    }
    codeStyle.insertCommon();

    var options = void 0,
        textarea = void 0,
        cm = void 0,
        cmDiv = void 0,
        cmTag = void 0,
        mode = void 0,
        theme = void 0;
    if (!container.id) {
      container.id = 'wiz_cm_' + new Date().valueOf() + '_' + Math.floor(10000 * Math.random());
    }
    domUtils.addClass(container, CONST.CLASS.CODE_CONTAINER);
    domUtils.setContenteditable(container, false);

    mode = _this.getCmMode(container, readOnly);
    theme = _this.getCmTheme(container, readOnly);

    // console.log(mode + ', ' + theme);
    if (container.codeMirror) {
      cm = container.codeMirror;
      if (readOnly) {
        // 设置 readOnly 为 nocursor 会导致内容无法被复制
        // cm.setOption('readOnly', 'nocursor');
        // cm.setOption('readOnly', true);
        cm.setOption('matchBrackets', false);
        cm.setOption('readOnly', env.client.type.isPhone || env.client.type.isPad ? 'nocursor' : true);
        cm.setOption('styleActiveLine', false);
        cm.getDoc().clearHistory();
      } else {
        cm.setOption('matchBrackets', true);
        cm.setOption('readOnly', false);
        cm.setOption('styleActiveLine', true);
      }
      _this.initTools(container, env.readonly);
      return;
    }

    _this.removeCmWrapper(container);

    // 防止 万一 data-id 不存在的情况
    while (container.lastChild && !domUtils.isTag(container.lastChild, 'textarea')) {
      container.removeChild(container.lastChild);
    }

    textarea = container.querySelector('textarea');
    // 清理特殊字符
    domUtils.setTextarea(textarea, utils.replaceSpecialChar(textarea.value));
    options = {
      viewportMargin: Infinity,
      fixedGutter: false,
      indentUnit: 4,
      // lineWrapping: (env.client.type.isPhone || env.client.type.isPad),
      lineWrapping: env.options.code.lineWrapping,
      scrollbarStyle: env.options.code.lineWrapping ? 'null' : 'native',
      lineNumbers: true,
      matchBrackets: !readOnly,
      mode: CODE_MIRROR.MODE[mode].cm,
      extraKeys: {
        // Tab: (cm) => {
        //   let spaces = Array(cm.getOption("indentUnit") + 1).join(" ");
        //   cm.replaceSelection(spaces);
        // },
        'Ctrl-Z': function CtrlZ() {
          historyUtils.undo();
        },
        'Cmd-Z': function CmdZ() {
          historyUtils.undo();
        },
        'Ctrl-Y': function CtrlY() {
          historyUtils.redo();
        },
        'Shift-Cmd-Z': function ShiftCmdZ() {
          historyUtils.redo();
        },
        'Cmd-Y': function CmdY() {
          historyUtils.redo();
        }
      }
    };

    if (readOnly) {
      // options.readOnly = 'nocursor';
      // options.readOnly = true;

      // 移动端 阅读界面必须设置 readonly 为 nocursor，否则会导致点击代码区域出现 键盘 和 光标
      options.readOnly = env.client.type.isPhone || env.client.type.isPad ? 'nocursor' : true;
      options.styleActiveLine = false;
    } else {
      options.readOnly = false;
      options.styleActiveLine = true;
    }
    codeStyle.fixScrollStyle(env.options.code.lineWrapping);

    cm = env.win.CodeMirror.fromTextArea(textarea, options);
    container.codeMirror = cm;
    container.mode = mode;
    domUtils.attr(cm.display.wrapper, { 'data-id': container.id });
    cmDiv = container.querySelector('.' + CONST.CLASS.CODE_MIRROR);
    cmTag = env.doc.createElement(CONST.TAG.CODE_MIRROR);
    domUtils.before(cmTag, cmDiv);
    cmTag.appendChild(cmDiv);

    _this.changeMode(container, mode, readOnly);
    _this.changeTheme(container, theme, readOnly);
    _this.initTools(container, env.readonly);

    // keydown & beforeSelectionChange 组合用于 衔接 CodeMirror 与 Editor 的光标移动
    var cursorDirect = void 0,
        lastCursorPos = '';
    cm.on('keydown', function (cm, e) {
      var keyCode = e.keyCode || e.which;
      if (keyCode === 37 || keyCode === 38) {
        // left or up
        cursorDirect = -1;
      } else if (keyCode === 39 || keyCode === 40) {
        // right or down
        cursorDirect = 1;
      } else {
        // other
        cursorDirect = 0;
      }
    });
    cm.on('beforeSelectionChange', function (cm, obj) {
      var range = obj.ranges[0],
          anchor = range.anchor,
          head = range.head,
          newCur = void 0;
      var curCursorPos = [anchor.line, anchor.ch, head.line, head.ch].join('.');
      var codeContainer = void 0;
      // 选中区间时，不处理光标
      if (obj.origin === "+move" && anchor.line === head.line && anchor.ch === head.ch && curCursorPos === lastCursorPos) {
        if (cursorDirect === -1) {
          newCur = domUtils.getPreviousNode(container);
          while (newCur && !domUtils.isTag(newCur, 'br') && domUtils.isEmptyDom(newCur)) {
            newCur = domUtils.getPreviousNode(newCur);
          }
          if (newCur) {
            codeContainer = _this.getContainerFromChild(newCur);
            if (codeContainer) {
              cm = codeContainer.codeMirror;
              _this.focusToLast(cm);
            } else {
              domUtils.setContenteditable(env.body, true);
              rangeUtils.setRange(newCur, domUtils.getEndOffset(newCur));
            }
          }
        } else if (cursorDirect === 1) {
          newCur = domUtils.getNextNode(container);
          while (newCur && !domUtils.isTag(newCur, 'br') && domUtils.isEmptyDom(newCur)) {
            newCur = domUtils.getNextNode(newCur);
          }
          if (newCur) {
            codeContainer = _this.getContainerFromChild(newCur);
            if (codeContainer) {
              cm = codeContainer.codeMirror;
              _this.focusToFirst(cm);
            } else {
              domUtils.setContenteditable(env.body, true);
              rangeUtils.setRange(newCur, 0);
            }
          }
        }
      }

      lastCursorPos = curCursorPos;
    });
    cm.on('beforeChange', function (cm, obj) {
      // undo/redo 不能在 beforeChange 内执行 cancel 会导致 history 清空

      // 捕获 CodeMirror 修改前的事件，相当于 editor 的 KeyDown
      if (obj.origin !== 'redo' && obj.origin !== 'undo') {
        historyUtils.saveSnap(false, {
          type: CONST.HISTORY.TYPE.CODE_MIRROR,
          cmContainerId: container.id
        });
      }
    });
    cm.on('change', function (cm, obj) {
      if (/^(redo|undo|paste)$/i.test(obj.origin)) {
        // 修改样式不使用滚动条后，redo/undo/paste 大段代码，CodeMirror 只显示一部分代码，所以必须要重新设置大小
        cm.setSize();
      }
    });
    cm.on('copy', function (cm, e) {
      // 移动端 阅读界面 因为设置了 nocursor 会导致无法正确进行复制，所以 必须忽略 codemirror 内部的复制功能
      if ((env.client.type.isPhone || env.client.type.isPad) && env.readonly) {
        e.codemirrorIgnore = true;
      }
    });
    cm.on('focus', function (cm, obj) {
      if (cm.blurTimer) {
        clearTimeout(cm.blurTimer);
      }
      // let container = this.getContainerFromChild(cm.display.wrapper);


      // 目前已经不显示横向滚动条，全部进行自动换行，所以此功能取消
      // 以后重新开启时，需要注意，此功能会导致 IOS 手机端焦点进入 CodeMirror 后，再无法失去焦点进入其他区域

      // if (!env.readonly) {
      //     // Chrome 49 内核 body contenteditable = true 时，
      //     // codeMirror 内的 focus 方法会导致页面跳跃，
      //     // 导致 横向滚动条移动时 页面纵向滚动条会快速移动到光标位置
      //     // 因此 必须 利用 focus 、blur 事件调整 body 的 contenteditable
      //     env.body.setAttribute('contenteditable', false);
      // }
      // domUtils.removeClass(cm.display.wrapper, 'CodeMirror-blur');
    });
    cm.on('blur', function (cm, obj) {
      // 避免 CodeMirror 失去焦点后，还显示选中区域
      // 选中多行后，左键点击选中区域，会导致先触发 blur，然后重新出发 focus，
      // 为了避免这种 blur 导致的光标位置异常，需要使用 setTimeout
      cm.blurTimer = setTimeout(function () {
        var range = rangeUtils.getRange();
        var isBlur = true;
        if (range) {
          var target = range.startContainer;
          var _container = _this.getContainerFromChild(target);
          // 如果 range 焦点仍在 cm 内，说明是整个 webview 失去焦点，这种时候不修改选中区域
          isBlur = !(_container && _container.codeMirror === cm);
        }
        if (isBlur) {
          cm.doc.setSelection({ line: 0, ch: 0 }, null, { scroll: false });
        }
      }, 200);

      // if (!env.readonly) {
      //     env.body.setAttribute('contenteditable', true);
      // }
      // domUtils.addClass(cm.display.wrapper, 'CodeMirror-blur');
    });

    // patch
    var sizer = container.querySelector('.CodeMirror-sizer');
    var emptyLine = void 0;
    if (sizer) {
      emptyLine = sizer.nextElementSibling;
      if (emptyLine) {
        emptyLine.style.height = '13px';
      }
    }
  };
  this.initTools = function (container, readOnly) {
    // if (!container || readOnly || env.client.type.isPhone || env.client.type.isPad) {
    if (!container) {
      return;
    }
    var cmWrapper = _this.getCmWrapper(container);
    var codeTools = container.querySelector('.' + CONST.CLASS.CODE_TOOLS);
    var modeSelector = void 0,
        themeSelector = void 0,
        moreSelector = void 0;
    var mode = _this.getCmMode(container, readOnly);
    var theme = container.getAttribute('data-theme');
    if (codeTools) {
      return;
    }
    var MoreOptions = [{
      obj: createLineWrapOption(),
      value: CONST.CODE.StorageKey.Wrap
    }];
    codeTools = env.doc.createElement(CONST.TAG.TMP_TAG);
    if (!readOnly) {
      if (env.supportTouchEvent) {
        // 移动端设备使用不一样的交互菜单
        modeSelector = createModeOption(mode);
        modeSelector.selector.onchange = function () {
          moreSelector.hideOptions();
          var mode = modeSelector.selector.value;
          modeSelector.optionText.innerText = mode;
          _this.changeMode(container, mode, false);
          container.codeMirror.focus();
        };

        themeSelector = createThemeOption(theme);
        themeSelector.selector.onchange = function () {
          moreSelector.hideOptions();
          var theme = themeSelector.selector.value;
          themeSelector.optionText.innerText = CODE_MIRROR.THEME[theme].name;
          _this.changeTheme(container, theme, false);
          container.codeMirror.focus();
        };

        MoreOptions.splice(0, 0, {
          text: lang.Code.Language,
          disabled: true,
          style: {
            'margin-bottom': '2px'
          }
        }, {
          obj: modeSelector,
          value: CONST.CODE.StorageKey.Mode,
          style: {
            'margin-top': '2px'
          },
          onClick: function onClick() {
            return false;
          }
        }, {
          text: lang.Code.Theme,
          disabled: true,
          style: {
            'margin-bottom': '2px'
          }
        }, {
          obj: themeSelector,
          value: CONST.CODE.StorageKey.Theme,
          style: {
            'margin-top': '2px',
            'margin-bottom': '10px'
          },
          onClick: function onClick() {
            return false;
          }
        });
      } else {
        modeSelector = selectPlugin.create({
          type: CONST.SELECT_PLUGIN.TYPE.Common,
          optionsData: ModeOptions,
          className: CONST.CLASS.CODE_TOOLS_MODE,
          defaultValue: mode
        });
        themeSelector = selectPlugin.create({
          type: CONST.SELECT_PLUGIN.TYPE.Common,
          optionsData: ThemeOptions,
          className: CONST.CLASS.CODE_TOOLS_THEME,
          defaultValue: theme
        });

        codeTools.appendChild(modeSelector);
        codeTools.appendChild(themeSelector);
        domUtils.addClass(modeSelector, CONST.CLASS.CODE_TOOLS_MODE);
        domUtils.addClass(themeSelector, CONST.CLASS.CODE_TOOLS_THEME);
      }
    }
    moreSelector = selectPlugin.create({
      type: CONST.SELECT_PLUGIN.TYPE.More,
      optionsData: MoreOptions,
      className: CONST.CLASS.CODE_TOOLS_MORE,
      defaultValue: theme
    });
    codeTools.appendChild(moreSelector);
    domUtils.addClass(moreSelector, CONST.CLASS.CODE_TOOLS_MORE);
    domUtils.addClass(codeTools, CONST.CLASS.CODE_TOOLS + (env.supportTouchEvent ? ' mobile' : ''));
    cmWrapper.appendChild(codeTools);
  };
  this.insertCodeSrc = function (container, src) {
    var cm = container.codeMirror;
    if (!cm) {
      return;
    }
    cm.replaceSelection(src, 'end');
  };
  this.onKeyDown = function (e) {
    var range = rangeUtils.getRange();
    var sel = rangeUtils.getSelection();
    if (!range || !range.collapsed || !sel.modify) {
      return true;
    }

    var code = e.keyCode || e.which;
    var startLast = rangeUtils.getRangeDetail(range.startContainer, range.startOffset),
        start = void 0,
        block = void 0,
        target = void 0;
    var direct = void 0,
        charMove = void 0,
        searchBackward = false,
        searchForward = false,
        searchStart = null,
        searchEnd = null,
        container = null,
        cm = void 0;

    /**
     * Backspace
     */
    if (code === 8 && startLast.offset === 0) {
      target = domUtils.getPreviousNode(startLast.container, false);
      container = _this.getContainerFromChild(target);
    }
    /**
     * Delete
     */
    if (code === 46 && (domUtils.isTag(startLast.container, 'br') || startLast.offset === domUtils.getEndOffset(startLast.container))) {
      target = domUtils.getNextNode(startLast.container, false);
      container = _this.getContainerFromChild(target);

      if (container && domUtils.isTag(startLast.container, 'br')) {
        // 删除当前空行
        domUtils.remove(startLast.container);
        _this.focusToFirst(container.codeMirror);
        return false;
      }
    }

    if (container) {
      historyUtils.saveSnap(false);
      domUtils.remove(container);
      return false;
    }

    // 判断键盘，控制光标移动
    switch (code) {
      case 37:
        //left
        if (!e.ctrlKey && !e.metaKey) {
          charMove = true;
          sel.modify('move', 'backward', 'character');
        }
        direct = { x: -1, y: 0 };
        break;
      case 38:
        //up
        if (!e.ctrlKey && !e.metaKey) {
          charMove = true;
          sel.modify('move', 'backward', 'line');
        }
        direct = { x: 0, y: -1 };
        break;
      case 39:
        //right
        if (!e.ctrlKey && !e.metaKey) {
          charMove = true;
          sel.modify('move', 'forward', 'character');
        }
        direct = { x: 1, y: 0 };
        break;
      case 40:
        //down
        if (!e.ctrlKey && !e.metaKey) {
          charMove = true;
          sel.modify('move', 'forward', 'line');
        }
        direct = { x: 0, y: 1 };
        break;
    }

    // 模拟光标移动后，检查移动范围内是否出现 CodeMirror 的 container
    if (charMove) {
      range = rangeUtils.getRange();
      start = rangeUtils.getRangeDetail(range.startContainer, range.startOffset);
      searchStart = startLast.container;
      searchEnd = start.container;

      if (start.container === startLast.container && start.offset !== startLast.offset) {
        // 光标移动且 start 未变化，说明是在但行内移动，无需查找 CodeMirror Container

      } else if (start.container !== startLast.container) {
        // 光标移动
        if (direct.x > 0 || direct.y > 0) {
          // forward
          searchForward = true;
        } else {
          // backward
          searchBackward = true;
        }
      } else {
        // 光标未移动
        if (direct.x > 0 || direct.y > 0) {
          // forward
          searchForward = true;
        } else {
          // backward
          searchBackward = true;
        }
        searchEnd = env.body;
      }

      if (searchForward) {
        block = domUtils.getNextNode(searchStart, false, searchEnd);
        while (block && block !== searchEnd && !domUtils.isTag(block, 'br') && domUtils.isEmptyDom(block)) {
          block = domUtils.getNextNode(block, false, searchEnd);
        }
        if (block) {
          block = domUtils.getNextBlock(block);
        }
      } else if (searchBackward) {
        block = domUtils.getPreviousNode(searchStart, false, searchEnd);
        while (block && block !== searchEnd && !domUtils.isTag(block, 'br') && domUtils.isEmptyDom(block)) {
          block = domUtils.getPreviousNode(block, false, searchEnd);
        }
        if (block) {
          block = domUtils.getPrevBlock(block);
        }
      }

      if (block) {
        container = _this.getContainerFromChild(block);
        cm = container && container.codeMirror;
        if (!cm) {
          container = null;
        } else {
          // 找到 container 后，设置对应光标位置
          cm.focus();
          if (direct.x > 0 || direct.y > 0) {
            _this.focusToFirst(cm);
          } else {
            _this.focusToLast(cm);
          }
        }
      }

      // 没有找到 Container 的情况下 恢复光标位置
      if (!container) {
        if (direct.x < 0) {
          sel.modify('move', 'forward', 'character');
        } else if (direct.y < 0) {
          sel.modify('move', 'forward', 'line');
        } else if (direct.x > 0) {
          sel.modify('move', 'backward', 'character');
        } else if (direct.y > 0) {
          sel.modify('move', 'backward', 'line');
        }
      }
    }
    return !container;
  };
  this.removeCmWrapper = function (container) {
    // 创建 cm 实例，必须删除原 cm Dom 结构
    // 如果 codeMirror 在 p 内， 恢复时 CodeMirror 的 div 会成为 p 的 nextSibling，所以只能根据 id 进行删除
    if (!container.id) {
      return;
    }
    var tmpWrapper = container.querySelector('.' + CONST.CLASS.CODE_MIRROR + '[data-id=' + container.id + ']');
    domUtils.remove(tmpWrapper);
  };
  this.saveToText = function () {
    if (!codeCore.hasLoaded) {
      return;
    }
    var containerList = _this.getContainerList();
    for (var i = containerList.length - 1; i >= 0; i--) {
      var container = containerList[i];
      var cm = container.codeMirror;
      if (cm) {
        cm.save();
        var textarea = container.querySelector('textarea');
        domUtils.setTextarea(textarea);
      }
    }
  };

  this.highlight = {
    clear: function clear(container) {
      var cm = container.codeMirror;
      if (!cm) {
        return;
      }
      var state = container.state;
      if (!state) {
        state = {};
        container.state = state;
      }

      cm.operation(function () {
        state.lastQuery = state.query || null;
        if (!state.query) {
          return;
        }
        state.query = state.queryText = null;
        cm.removeOverlay(state.overlay);
      });
    },
    clearAll: function clearAll() {
      // if (!codeCore.hasLoaded) {
      //   return;
      // }
      var containerList = _this.getContainerList();
      for (var i = 0; i < containerList.length; i++) {
        var container = containerList[i];
        _this.highlight.clear(container);
      }
    },
    overlay: function overlay(_query) {
      var query = new RegExp(_query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), "gi");
      return {
        token: function token(stream) {
          query.lastIndex = stream.pos;
          var match = query.exec(stream.string);
          if (match && match.index === stream.pos) {
            stream.pos += match[0].length || 1;
            return "searching";
          } else if (match) {
            stream.pos = match.index;
          } else {
            stream.skipToEnd();
          }
        }
      };
    },
    search: function search(container, query) {
      if (!codeCore.hasLoaded) {
        return;
      }
      // 如果 CodeMirror 区域内已经处理过同样的关键字，则不要再处理，
      // 否则会导致 highlightUtils 代码 while (env.win.find(key, false, true)) {...} 部分出现死循环
      if (container.state && container.state.query && container.state.query.toLowerCase() === query.toLowerCase()) {
        return;
      }

      var cm = container.codeMirror;
      if (!cm) {
        return;
      }
      _this.highlight.clear(container);
      var state = container.state;
      query = query.toLowerCase();
      state.query = query;
      cm.removeOverlay(state.overlay);
      state.overlay = _this.highlight.overlay(state.query);
      cm.addOverlay(state.overlay);
    }
  };
  this.oldPatch = {
    getOldCodeList: function getOldCodeList(body) {
      body = body || env.body;
      return body.querySelectorAll('.' + CONST.CLASS.CODE_CONTAINER_OLD);
      if (codeList.length > 50) {
        // 如果代码段大于 50 不进行修正，会导致页面性能大幅下降
        return result;
      }
    },
    oldCodeReady: function oldCodeReady() {
      // 分割代码内的其他内容 (A / Img)
      var codeList = void 0;
      var code = void 0,
          codeI = void 0;
      var split = function split(_code, selector) {
        var domList = void 0;
        domList = _code.querySelectorAll(selector);
        for (var domI = domList.length - 1; domI >= 0; domI--) {
          var dom = domList[domI];
          // a 标签内如果 text 为空，才进行处理（只有 a 里面是图片 才分割）
          if (!utils.isEmpty(dom.innerText)) {
            continue;
          }
          var main = domUtils.getParentByClass(dom, CONST.CLASS.CODE_CONTAINER_OLD, false);
          if (main) {
            var domP = domUtils.splitDomSingle(main, dom);
            var div = env.doc.createElement('div');
            div.appendChild(dom);
            domUtils.before(div, domP);
            domUtils.remove(domP);
          }
        }
      };

      code = env.body.querySelector('.' + CONST.CLASS.CODE_CONTAINER_OLD + ' .' + CONST.CLASS.CODE_CONTAINER_OLD);
      // 清理所有被嵌套的 代码段
      while (code) {
        var parentCode = domUtils.getParentByClass(code, CONST.CLASS.CODE_CONTAINER_OLD, false);
        domUtils.after(code, parentCode);
        code = env.body.querySelector('.' + CONST.CLASS.CODE_CONTAINER_OLD + ' .' + CONST.CLASS.CODE_CONTAINER_OLD);
      }

      codeList = env.body.querySelectorAll('.' + CONST.CLASS.CODE_CONTAINER_OLD);
      // 将 超链接拆分出来
      for (codeI = codeList.length - 1; codeI >= 0; codeI--) {
        code = codeList[codeI];
        split(code, 'a');
      }

      // 每一次拆分后必须重新遍历 codeList，因为 code 区块会增加
      codeList = env.body.querySelectorAll('.' + CONST.CLASS.CODE_CONTAINER_OLD);
      // 将 img 拆分出来
      for (codeI = codeList.length - 1; codeI >= 0; codeI--) {
        code = codeList[codeI];
        split(code, 'img');
      }
    },
    fixOldCode: function fixOldCode(body) {
      var codeList = void 0;
      var result = [];

      _this.oldPatch.oldCodeReady();
      codeList = _this.oldPatch.getOldCodeList(body);

      for (var i = codeList.length - 1; i >= 0; i--) {
        var code = codeList[i];
        // 仅仅针对 之前 客户端自己生成的 代码内容进行处理，其余的一概保持原样
        if (!domUtils.isTag(code, 'pre') || !code.querySelector('code')) {
          continue;
        }
        var container = _this.fixCode(code);
        var src = _this.oldPatch.getSrc(code);
        var mode = _this.oldPatch.getMode(code);
        container.removeChild(code);
        if (!src) {
          continue;
        }
        var textarea = env.doc.createElement('textarea');
        textarea.value = src;
        textarea.style.display = 'none';
        container.appendChild(textarea);
        domUtils.addClass(container, CONST.CLASS.CODE_CONTAINER);
        if (mode) {
          domUtils.attr(container, {
            'data-mode': mode
          });
        }
        result.push(container);
      }
      return result;
    },
    getMode: function getMode(code) {
      var regCode = /language-([\w]+)/i;
      var regPre = /lang-([\w]+)/i;
      var modeObj = code.querySelector('code'),
          result = void 0,
          mode = void 0;
      if (modeObj && modeObj.className && (result = modeObj.className.match(regCode))) {
        mode = result[1];
      } else if (code.className && (result = code.className.match(regPre))) {
        mode = result[1];
      }
      if (mode) {
        mode = modeDic[mode.toLowerCase()];
      }
      return mode;
    },
    getSrc: function getSrc(code) {
      if (!code) {
        return '';
      }
      // 注意：
      // 1、旧的笔记代码段没有严格控制，所以会导致各种元素穿插在内（例如：超链接、图片等）
      // 2、prettyprint 渲染后 有的代码段 空行是 <code></code> 直接使用 innerText 获取源码 会导致空行丢失，必须修正

      var domList = code.querySelectorAll('code');
      // 修正空行
      for (var i = 0, j = domList.length; i < j; i++) {
        var dom = domList[i];
        if (!dom.innerText) {
          dom.innerText = '\n';
        }
      }

      // 列表后面只要有内容， innerText 在结尾就会多出一个 \n，如果不处理 在 CodeMirror 中就会多出一行
      return (code.innerText || code.textContent || '').replace(/\n$/, '');
    }
  };
  // 1. 处理 删除操作
  // 2. 判断从 CodeMirror 之外移动光标是否进入 CodeMirror
  this.pastePatch = {
    getPasteCodeList: function getPasteCodeList() {
      return env.body.querySelectorAll('.' + CONST.CLASS.CODE_CONTAINER_PASTE);
    },
    fix: function fix() {
      var codeList = _this.pastePatch.getPasteCodeList();
      for (var i = codeList.length; i >= 0; i--) {
        var container = codeList[i];
        domUtils.removeClass(container, CONST.CLASS.CODE_CONTAINER_PASTE);
        _this.fixCodeContainer({ container: container });
      }
    },
    ready: function ready(dom, isInTable) {
      var codeList = dom.querySelectorAll('.' + CONST.CLASS.CODE_MIRROR);
      var codeContainer = void 0,
          textarea = void 0;
      var container = void 0,
          codeMirror = void 0,
          rowList = void 0,
          mode = void 0,
          theme = void 0,
          codeLine = void 0,
          src = void 0;
      for (var codeIndex = codeList.length - 1; codeIndex >= 0; codeIndex--) {
        codeMirror = codeList[codeIndex];
        container = _this.getContainerFromChild(codeMirror);
        if (!container) {
          container = codeMirror;
        }
        codeLine = [];

        rowList = codeMirror.querySelectorAll('.' + CONST.CLASS.CODE_MIRROR_LINE);
        for (var rowIndex = 0; rowIndex < rowList.length; rowIndex++) {
          var row = rowList[rowIndex];
          src = row.innerText || row.textContent;
          codeLine.push(src.replace(CONST.FILL_CHAR_REG, ''));
        }

        codeContainer = env.doc.createElement('div');
        if (isInTable) {
          codeContainer.innerHTML = '<br/>' + codeLine.join('<br/>') + '<br/><br/>';
        } else {
          mode = container.getAttribute('data-mode');
          theme = container.getAttribute('data-theme');

          textarea = env.doc.createElement('textarea');
          textarea.textContent = codeLine.join('\n');
          domUtils.addClass(codeContainer, CONST.CLASS.CODE_CONTAINER_PASTE);
          codeContainer.appendChild(textarea);
          if (mode) {
            domUtils.attr(codeContainer, { 'data-mode': mode });
          }
          if (theme) {
            domUtils.attr(codeContainer, { 'data-theme': theme });
          }
        }

        domUtils.before(codeContainer, container);
        domUtils.remove(container);
      }
    }
  };
};

module.exports = CodeUtils;

},{"../../config/const":388,"../../libs/utils":400}],365:[function(require,module,exports){
'use strict';

/**
 * 内容提取操作核心包 core
 */

var CONST = require('../../config/const');
var domPatch = require('../../libs/domPatch');
var LoadController = require('../../libs/LoadController');
var dependLoader = require('../../libs/dependLoader');

var loadController = new LoadController();

var BORDER_COLOR = '#F0F2F4';
var HTML_BG_COLOR = '#E8E8E8';
var BODY_BG_COLOR = '#FFFFFF';

var BORDER_COLOR_NIGHT = '#1F2228';
var HTML_BG_COLOR_NIGHT = '#282B33';
var BODY_BG_COLOR_NIGHT = '#1F2228';

var ContentCore = function ContentCore() {
  var _this = this;

  var core = null;
  var env = null;
  var domUtils = null;
  var nightModeUtils = null;
  var wizStyle = null;

  var curTouchTarget = null;
  var contentResult = {};

  var checkEmailToWiz = function checkEmailToWiz() {
    var inputList = env.body.querySelectorAll('input[type=hidden]');
    for (var i = 0; i < inputList.length; i++) {
      var value = inputList[i].value;
      if (value.indexOf('wiz_mail_from') === 0) {
        return true;
      }
    }
    return false;
  };

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
    nightModeUtils = core.require.nightModeUtils;
    wizStyle = core.require.wizStyle;
  };

  var event = {
    bind: function bind(doc) {
      if (!doc) {
        return;
      }
      event.unbind(doc);
      if (env.supportTouchEvent) {
        doc.body.addEventListener('touchend', handler.onTouchEnd);
        doc.body.addEventListener('touchstart', handler.onTouchStart);
      } else {
        doc.body.addEventListener('click', handler.onClick);
      }
    },
    unbind: function unbind(doc) {
      if (!doc) {
        return;
      }

      doc.body.removeEventListener('touchend', handler.onTouchEnd);
      doc.body.removeEventListener('touchstart', handler.onTouchStart);
      doc.body.removeEventListener('click', handler.onClick);
    }
  };

  var handler = {
    onChanged: function onChanged(checkbox, checkboxInContent) {
      // 使用 setTimeout 轮询，检测是否发生改变
      if (checkbox.getAttribute(CONST.ATTR.TODO_CHECK) === checkboxInContent.getAttribute(CONST.ATTR.TODO_CHECK)) {
        setTimeout(function () {
          handler.onChanged(checkbox, checkboxInContent);
        }, 200);
        return;
      }
      var id = checkbox.id;
      var state = checkbox.getAttribute(CONST.ATTR.TODO_CHECK);
      var isChecked = state === 'checked';

      var dom = contentResult.iframeDoc.querySelector('#' + id);
      if (!dom) {
        return;
      }
      // dom.removeEventListener('DOMAttrModified', handler.onChanged);

      var domLayer = domUtils.getParentByClass(dom, CONST.CLASS.TODO_LAYER);
      if (isChecked) {
        domUtils.removeClass(domLayer, CONST.CLASS.TODO_UNCHECKED);
        domUtils.addClass(domLayer, CONST.CLASS.TODO_CHECKED);
      } else {
        domUtils.removeClass(domLayer, CONST.CLASS.TODO_CHECKED);
        domUtils.addClass(domLayer, CONST.CLASS.TODO_UNCHECKED);
      }
      var attr = {};
      attr[CONST.ATTR.TODO_CHECK] = state;
      domUtils.attr(dom, attr);
    },
    onClick: function onClick(e) {
      var checkboxInContent = e.target;
      if (!domUtils.hasClass(checkboxInContent, CONST.CLASS.TODO_CHECKBOX)) {
        return;
      }

      var id = checkboxInContent.id;
      var checkbox = env.body.querySelector('#' + id);
      if (!checkbox) {
        return;
      }

      // chrome 不支持 DOMAttrModified 属性
      //dom.addEventListener('DOMAttrModified', handler.onChanged);
      handler.onChanged(checkbox, checkboxInContent);

      var event = env.doc.createEvent("HTMLEvents");
      event.initEvent("click", true, true);
      event.eventName = 'click';
      checkbox.dispatchEvent(event);
    },
    onTouchEnd: function onTouchEnd(e) {
      if (e.target !== curTouchTarget) {
        return;
      }
      curTouchTarget = null;
      handler.onClick(e);
    },
    onTouchStart: function onTouchStart(e) {
      curTouchTarget = e.target;
    }
  };

  var loadDependency = function loadDependency(callback) {
    loadController.addCallback(env.doc, callback);
    if (loadController.getLoading(env.doc)) {
      return;
    }
    if (typeof env.win.WizContent === 'undefined') {
      loadController.setLoading(env.doc, true);
      dependLoader.loadJs(env.doc, dependLoader.getDependencyFiles(env.dependency, 'js', 'wizContent'), function () {
        loadController.setLoading(env.doc, false);
        loadController.callback(env.doc);
      });
    } else {
      loadController.callback(env.doc);
    }
  };

  this.on = function (options, callback) {
    var borderColor = env.options.pureReadMode.borderColor || (env.options.nightMode.enable ? BODY_BG_COLOR_NIGHT : BORDER_COLOR);
    var htmlBgColor = env.options.pureReadMode.htmlBgColor || (env.options.nightMode.enable ? HTML_BG_COLOR_NIGHT : HTML_BG_COLOR);
    var bodyBgColor = env.options.pureReadMode.bodyBgColor || (env.options.nightMode.enable ? BORDER_COLOR_NIGHT : BODY_BG_COLOR);

    var PureReadCss = '* {box-sizing: border-box;}' + 'html {' + 'height:100%; background-color:' + htmlBgColor + ' !important;' +
    // 'margin-left: calc(100vw - 100%) !important;' +  // 目前不用考虑原始内容左右抖动
    '}' + 'body *, .' + CONST.CLASS.WIZ_BODY + ' * {max-width:100%;} ' + 'body, .' + CONST.CLASS.WIZ_BODY + ', .markdown-body {' + 'background-color:' + bodyBgColor + ' !important;' + 'border:1px solid ' + borderColor + ' !important;' + 'max-width:820px !important;' + 'min-height:initial !important;' + 'min-height:calc(100% - 80px) !important;' + 'margin:40px auto !important;' + 'padding:48px 75px !important;' + '}' + 'pre {white-space: pre-wrap;}';

    var stylePatch = '';
    if (env.options.nightMode.enable) {
      stylePatch = 'body, .wiz-editor-body, .markdown-body {border: 0px !important;}' + (nightModeUtils ? nightModeUtils.getBaseStyle('', bodyBgColor) : '');
    }

    // 采用 env.options.container && useFrame = false 模式下，禁用 内容提取
    if (env.options.container && !env.options.useFrame) {
      return;
    }

    if (env.readonly === true && (options.needContentExtraction || env.options.pureReadMode.needContentExtraction)) {
      // Email 导入为 笔记的内容不能进行正文提取，直接处理全文

      var isEmailToWiz = checkEmailToWiz();
      var onContentLoad = function onContentLoad() {
        var isDebug = false;
        env.win.WizContent.init('', isDebug).on({
          needContentExtraction: !isEmailToWiz,
          needShow: !(env.client.type.isIOS || env.client.type.isAndroid),
          borderColor: bodyBgColor,
          htmlBgColor: htmlBgColor,
          bodyBgColor: bodyBgColor,
          stylePatch: stylePatch
        }, function (result) {
          contentResult = result;

          // 需要注入 默认样式
          var _document = env.doc;
          env.doc = contentResult.iframeDoc;
          wizStyle.insertDefaultStyle();
          env.doc = _document;

          event.bind(contentResult.iframeDoc);
          if (callback) {

            callback(contentResult);

            // iphone & ipad 正文提取不显示 iframe，直接让客户端自行显示 html
            if (env.client.type.isIOS || env.client.type.isAndroid) {
              try {
                var html = _this.getContentExtractionHtml();
                if (window.webkit) {
                  window.webkit.messageHandlers.postPureReadContext.postMessage(html);
                } else if (window.WizNote) {
                  window.WizNote.onContentExtractionEnd(html);
                }
              } catch (e) {
                console.log(e);
              }
            }
          }
        });
      };

      loadDependency(onContentLoad);
    } else if (env.options.pureReadMode.enable && !options.needContentExtraction && !env.options.pureReadMode.needContentExtraction) {

      var css = PureReadCss + stylePatch;

      // 进行内容提取的笔记，如果采用普通编辑时，不能注入 样式
      wizStyle.insertStyle({
        id: CONST.ID.PURE_READ_STYLE,
        name: CONST.NAME.TMP_STYLE
      }, css);
      if (env.win.WizContent) {
        env.win.WizContent.off();
      }
    }
  };
  this.off = function () {
    event.unbind(contentResult.iframeDoc);

    // 避免由于 WizContent 正在加载而导致的 off 失效
    var onContentLoad = function onContentLoad() {
      env.win.WizContent.off();
    };
    loadDependency(onContentLoad);

    wizStyle.removeStyleById(CONST.ID.PURE_READ_STYLE);
  };
  this.getContentExtractionHtml = function () {
    if (!contentResult || !contentResult.iframe || !domUtils.hasClass(contentResult.iframe, CONST.CLASS.WIZ_CONTENT_IFRAME_ACTIVE)) {
      return null;
    }

    var _document = env.doc,
        _win = env.win,
        _body = env.body;

    env.doc = contentResult.iframeDoc;
    env.win = contentResult.iframeWin;
    env.body = env.doc.body;
    domPatch.run(env.win);

    //获取处理后的 html
    var html = domUtils.getContentHtml();
    env.body = _body;
    env.doc = _document;
    env.win = _win;

    return html;
  };
};

module.exports = ContentCore;

},{"../../config/const":388,"../../libs/LoadController":393,"../../libs/dependLoader":397,"../../libs/domPatch":398}],366:[function(require,module,exports){
'use strict';

/**
 * 编辑器 基础工具包
 */
var CONST = require('../../config/const');
var dependLoader = require('../../libs/dependLoader');

var Editor = function Editor() {
  var _this = this;

  var core = null;
  var env = null;
  var amend = null;
  var blockCore = null;
  var codeCore = null;
  var commandExtend = null;
  var domUtils = null;
  var editorEvent = null;
  var formatPainter = null;
  var frameViewCore = null;
  var historyUtils = null;
  var imgCore = null;
  var linkUtils = null;
  var selectPlugin = null;
  var tabKey = null;
  var tableCore = null;
  var todoCore = null;
  var wizStyle = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    amend = core.require.amend;
    blockCore = core.require.blockCore;
    codeCore = core.require.codeCore;
    commandExtend = core.require.commandExtend;
    domUtils = core.require.domUtils;
    editorEvent = core.require.editorEvent;
    formatPainter = core.require.formatPainter;
    frameViewCore = core.require.frameViewCore;
    historyUtils = core.require.historyUtils;
    imgCore = core.require.imgCore;
    linkUtils = core.require.linkUtils;
    selectPlugin = core.require.selectPlugin;
    tabKey = core.require.tabKey;
    tableCore = core.require.tableCore;
    todoCore = core.require.todoCore;
    wizStyle = core.require.wizStyle;
  };

  var originalHtml = '';

  this.off = function () {
    _this.offEvent();

    env.readonly = true;
    if (env.isSetBodyFontSize) {
      env.body.style.fontSize = null;
      env.isSetBodyFontSize = false;
    }
    domUtils.setContenteditable(null, false);
    // domUtils.removeByName(CONST.NAME.TMP_STYLE);
    domUtils.removeByTag(CONST.TAG.TMP_TAG);
  };

  this.offEvent = function () {
    historyUtils.stop();
    amend.stopReverse();
    amend.stop();
    formatPainter.off();
    if (codeCore) {
      codeCore.off();
    }
    blockCore.off();
    if (todoCore) {
      todoCore.off();
    }
    tabKey.off();
    tableCore.off();
    imgCore.off();
    selectPlugin.off();
    commandExtend.off();
    editorEvent.unbind();
    frameViewCore.off();
    if (env.options.editor.autoCheckLink) {
      linkUtils.off();
    }
  };

  this.on = function (callback) {
    var onCodeRender = function onCodeRender() {
      amend.startReverse();
      historyUtils.start(env.options.editor.maxRedo, env.options.editor.callback.redo);
      imgCore.setImgFullPath();

      if (env.client.type.isPhone || env.client.type.isPad) {
        //手机端 渲染可能会慢，所以必须要延时处理
        setTimeout(function () {
          _this.setOriginalHtml();
        }, 500);
      } else {
        _this.setOriginalHtml();
      }
      if (typeof callback === 'function') {
        callback();
      }
    };

    domUtils.removeClass(env.body, CONST.CLASS.READONLY);
    domUtils.addClass(env.body, CONST.CLASS.EDITING);
    if (env.options.container) {
      domUtils.removeClass(env.options.container, CONST.CLASS.READONLY);
      domUtils.addClass(env.options.container, CONST.CLASS.EDITING);
    }

    if (env.frame.toolbarContainer && env.options.document !== env.doc) {
      dependLoader.loadCss(env.options.document, [env.dependency.files.css.fonts]);
    }
    dependLoader.loadCss(env.doc, [env.dependency.files.css.fonts]);
    historyUtils.init();
    domUtils.setContenteditable(null, true);
    frameViewCore.on();
    wizStyle.insertTmpEditorStyle();

    domUtils.fixOrderList();
    editorEvent.bind();
    commandExtend.on();
    selectPlugin.on();
    imgCore.on();
    tableCore.on();
    tabKey.on();
    if (todoCore) {
      todoCore.on();
    }
    blockCore.on();
    formatPainter.init();

    if (env.options.editor.autoCheckLink) {
      linkUtils.on();
    }
    if (codeCore) {
      codeCore.on({}, onCodeRender);
    } else {
      onCodeRender();
    }

    // 必须要设置 style，否则 编辑时，Chrome 会在第一行自动设置 font-size
    if (!env.body.style.fontSize) {
      env.body.style.fontSize = env.win.getComputedStyle(env.body).fontSize;
      env.isSetBodyFontSize = true;
    } else {
      env.isSetBodyFontSize = false;
    }
  };
  this.getOriginalHtml = function () {
    return originalHtml;
  };
  this.setOriginalHtml = function () {
    originalHtml = domUtils.getContentHtml();
  };
};

module.exports = Editor;

},{"../../config/const":388,"../../libs/dependLoader":397}],367:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * editor 使用的基本事件处理
 */
var CONST = require('../../config/const');
var utils = require('../../libs/utils');

var EditorEventType = {
  SelectionChange: 'selectionchange',
  HistoryUndo: 'historyUndo'
};

var EditorEvent = function EditorEvent() {
  var _this = this;

  var core = null;
  var env = null;
  var lang = null;
  var amend = null;
  var amendUser = null;
  var amendUtils = null;
  var clipboardUtils = null;
  var codeUtils = null;
  var commandExtend = null;
  var domUtils = null;
  var formatPainter = null;
  var frameViewUtils = null;
  var historyUtils = null;
  var linkUtils = null;
  var pasteUtils = null;
  var rangeUtils = null;
  var tableCore = null;
  var tableUtils = null;
  var tableZone = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    lang = core.lang;
    amend = core.require.amend;
    amendUser = core.require.amendUser;
    amendUtils = core.require.amendUtils;
    clipboardUtils = core.require.clipboardUtils;
    codeUtils = core.require.codeUtils;
    commandExtend = core.require.commandExtend;
    domUtils = core.require.domUtils;
    formatPainter = core.require.formatPainter;
    frameViewUtils = core.require.frameViewUtils;
    historyUtils = core.require.historyUtils;
    linkUtils = core.require.linkUtils;
    pasteUtils = core.require.pasteUtils;
    rangeUtils = core.require.rangeUtils;
    tableCore = core.require.tableCore;
    tableUtils = core.require.tableUtils;
    tableZone = core.require.tableZone;
  };

  var editorListener = {
    selectionchange: [],
    historyUndo: []
  };

  var eventTrackHandler = {};
  var selectTimer = null;
  var clipboardDoing = false;

  var eventStringify = function eventStringify(event) {
    var s = [];
    for (var k in event) {
      var v = event[k];
      var t = (typeof v === 'undefined' ? 'undefined' : _typeof(v)).toLowerCase();
      if (t === 'string' || t === 'number') {
        if (t === 'string') {
          v = '"' + v.replace(/"/g, '\\"') + '"';
        }
        s.push('"' + k + '":' + v);
      }
    }
    return '{' + s.join(',') + '}';
  };
  /**
   * 复制/剪切 选中区域
   */
  var copySelection = function copySelection(e, isCut, callback) {
    var zone = tableZone.getZone(),
        range = rangeUtils.getRange(),
        fragment = void 0,
        oldHtml = void 0,
        newHtml = void 0,
        hasCodeMirror = false,
        tmpParent = void 0,
        tmp = void 0,
        canSetData = true,
        user = void 0,
        style = void 0,
        domList = [];
    isCut = !!isCut;

    // 检查复制的区域内是否存在 codeMirror
    if (!zone.range && range && !range.collapsed) {
      tmp = range.cloneContents();
      hasCodeMirror = !!tmp.querySelector('.' + CONST.CLASS.CODE_CONTAINER);
    }

    //只有在修订状态时才禁止复制 已删除 的内容
    if (range) {
      tmpParent = domUtils.getParentRoot([range.startContainer, range.endContainer]);
      if (amend.isAmendEditing() && tmpParent && tmpParent.getAttribute(CONST.ATTR.SPAN_DELETE) === amendUser.getCurUser().hash) {
        alert(isCut ? lang.Err.Cut_Null : lang.Err.Copy_Null);
        utils.stopEvent(e);
        callback();
        return;
      }
    }

    // 只有选中 表格、修订、CodeMirror 区域 才干涉选中内容
    if (!zone.range && (!range || range.collapsed || !hasCodeMirror && !amend.isAmendEditing()) || zone.range && range && !range.collapsed) {
      callback();
      return;
    }

    if (zone.range && (!range || range.collapsed)) {
      fragment = tableZone.getFragmentForCopy();
    } else if (range && !range.collapsed) {
      fragment = rangeUtils.getFragmentForCopy();
    }
    if (fragment) {
      if (amend.isAmendEditing()) {
        oldHtml = fragment.innerHTML.length;
        amend.fragmentFilter(fragment);
        newHtml = fragment.innerHTML.length;
        if (newHtml === 0 && oldHtml > 0) {
          alert(lang.Err.Copy_Null);
          canSetData = false;
        }
      }

      var html = fragment.innerHTML;
      var text = fragment.innerText;
      fragment.innerHTML = '';
      domUtils.remove(fragment);
      fragment = null;

      if (canSetData) {
        var _callback = function _callback() {
          if (isCut) {
            historyUtils.saveSnap(false);
          }

          if (isCut && amend.isAmendEditing()) {
            user = amendUser.getCurUser();
            style = amendUtils.getDeletedStyle(user);
            if (zone.range && (!range || range.collapsed)) {
              //处理表格内部时，必须要把每一个叶子节点找出来，然后去处理
              domList = tableUtils.getDomsByCellList(tableZone.getSelectedCells());

              domUtils.modifyNodesStyleAndClear(domList, style.style, style.attr, []);
              amendUtils.removeUserDel(zone.table, user);
            } else {

              amendUtils.removeSelection(user);
              amendUtils.removeUserDel(null, user);
              rangeUtils.getSelection().collapseToEnd();
              rangeUtils.caretFocus();
            }
          } else if (isCut && zone.range && (!range || range.collapsed)) {
            tableCore.clearCellValue();
          } else if (isCut) {
            range.deleteContents();
          }

          callback();
        };

        clipboardUtils.setData(e, html, text, _callback);
      }
    }
    if (!env.browser.isIe) {
      utils.stopEvent(e);
    }
  };
  /**
   * 获取光标位置 文字样式
   */
  var getCaretStyle = function getCaretStyle() {
    if (selectTimer) {
      clearTimeout(selectTimer);
    }
    selectTimer = setTimeout(_getCaretStyle, 200);
  };
  var _getCaretStyle = function _getCaretStyle() {
    var queryCommand = function queryCommand(command) {
      return commandExtend.queryCommandState(command) ? "1" : "0";
    };

    var result = {
      'backColor': '',
      'blockFormat': '',
      'bold': '0',
      'canCreateCode': '1',
      'canCreateTable': '1',
      'canCreateTodo': '1',
      'canFormatPainter': '1',
      'isInCode': '0',
      'isInTable': '0',
      'clientTools': '1',
      'fontName': '',
      'fontSize': '',
      'foreColor': '',
      'formatPainterStatus': formatPainter.status().toString(),
      'InsertOrderedList': '0',
      'InsertUnorderedList': '0',
      'italic': '0',
      'justifyleft': '0',
      'justifycenter': '0',
      'justifyright': '0',
      'justifyfull': '0',
      'strikeThrough': '0',
      'subscript': '0',
      'superscript': '0',
      'underline': '0',
      'unlink': '0'
    },
        style = void 0;
    var range = rangeUtils.getRange(),
        zone = tableZone.getZone(),
        cells = void 0,
        cellsAlign = void 0,
        rangeList = [];

    if (!range && (!zone.range || zone.active)) {
      return;
    }

    if (zone.grid && zone.range) {
      // 在表格内
      result.canCreateTable = '0';
      result.canCreateCode = '0';
      result.isInTable = '1';
    } else if (range && codeUtils && codeUtils.getContainerFromChild(range.startContainer)) {
      // 在 CodeMirror 内
      result.isInCode = '1';
      result.clientTools = '0';
      result.canCreateCode = '0';
      result.canCreateTable = '0';
      result.canCreateTodo = '0';
      result.canFormatPainter = '0';
    }

    if (range && (!zone.range || tableZone.isSingleCell())) {
      result.blockFormat = env.doc.queryCommandValue("formatBlock");
      if (!/^h[1-6]$/i.test(result.blockFormat)) {
        result.blockFormat = 'div';
      }
      result.fontName = env.doc.queryCommandValue("fontName");
      result.foreColor = utils.rgb2Hex(env.doc.queryCommandValue('foreColor'));
      result.backColor = utils.rgb2Hex(env.doc.queryCommandValue('backColor'));
      result.bold = queryCommand('bold');
      result.italic = queryCommand('italic');
      result.underline = queryCommand('underline');
      result.strikeThrough = queryCommand('strikeThrough');
      result.subscript = queryCommand('subscript');
      result.superscript = queryCommand('superscript');
      result.justifyleft = queryCommand('justifyleft');
      result.justifycenter = queryCommand('justifycenter');
      result.justifyright = queryCommand('justifyright');
      result.justifyfull = queryCommand('justifyfull');
      result.InsertOrderedList = queryCommand('InsertOrderedList');
      result.InsertUnorderedList = queryCommand('InsertUnorderedList');
      result.unlink = linkUtils.hasLinkFromRange() ? '1' : '0';

      style = {
        'font-size': ''
      };

      rangeList = rangeUtils.getRangeDomList({
        noSplit: true
      });
      if (rangeList) {
        rangeList = rangeList.list.length > 0 ? rangeList.list : [rangeList.startDom];
      }
    } else {
      // 表格 多选单元格的时候
      cellsAlign = tableUtils.getAlign(zone.grid, zone.range);
      cells = tableZone.getSelectedCells();
      rangeList = tableUtils.getDomsByCellList(cells);

      result.justifyleft = cellsAlign.align === 'left' ? '1' : '0';
      result.justifycenter = cellsAlign.align === 'center' ? '1' : '0';
      result.justifyright = cellsAlign.align === 'right' ? '1' : '0';

      style = {
        'font-size': '',
        'font-family': '',
        'font-weight': '',
        'font-style': '',
        'text-decoration': '',
        'color': '',
        'background-color': ''
      };
    }

    for (var i = 0, j = rangeList.length; i < j; i++) {
      var o = rangeList[i];
      if (o.nodeType !== 3 && o.nodeType !== 1) {
        continue;
      }
      o = o.nodeType === 3 ? o.parentNode : rangeList[i];
      for (var k in style) {
        if (style.hasOwnProperty(k)) {
          var v = domUtils.getComputedStyle(o, k, true);
          if (!v) {
            continue;
          }

          if (i === 0) {
            style[k] = v;
          } else if (style[k] !== v) {
            style[k] = '';
          }
        }
      }
    }

    var s = style['font-size'];
    if (s) {
      result['fontSize'] = Math.round(parseFloat(s) / domUtils.pt2px() / domUtils.getRootSizeRate()) + 'pt';
    }
    s = style['font-family'];
    if (s) {
      result['fontName'] = s;
    }
    s = style['font-weight'];
    if (s && /bold|bolder/.test(s)) {
      result['bold'] = '1';
    }
    s = style['font-style'];
    if (s && /italic|oblique/.test(s)) {
      result['italic'] = '1';
    }
    s = style['text-decoration'];
    if (s && /underline/.test(s)) {
      result['underline'] = '1';
    } else if (s && /line\-through/.test(s)) {
      result['strikeThrough'] = '1';
    }

    //默认的选中节点背景色 需要过滤掉
    if (result.backColor === '#f3f7ff') {
      result.backColor = '';
    }
    // console.log(result);
    _this.triggerListener(EditorEventType.SelectionChange, [result]);
  };

  var handler = {
    onClick: function onClick(e) {
      linkUtils.onClickLink(e);
      if (env.options.editor.callback.onClick && !env.options.editor.callback.onClick(e)) {
        return;
      }
      env.event.call(CONST.EVENT.ON_CLICK, e);
    },
    onCompositionend: function onCompositionend(e) {
      env.event.call(CONST.EVENT.ON_COMPOSITION_END, e);
    },
    onCompositionstart: function onCompositionstart(e) {
      env.event.call(CONST.EVENT.ON_COMPOSITION_START, e);
    },
    onCopy: function onCopy(e) {
      // CodeMirror 内 复制操作全部忽略
      if (codeUtils && codeUtils.getContainerFromChild(e.target)) {
        return;
      }
      clipboardDoing = true;
      copySelection(e, false, function () {
        clipboardDoing = false;
      });
      // env.event.call(CONST.EVENT.ON_COPY, e);
    },
    onCut: function onCut(e) {
      // CodeMirror 内 剪贴操作全部忽略
      if (codeUtils && codeUtils.getContainerFromChild(e.target)) {
        return;
      }
      historyUtils.saveSnap(false);
      clipboardDoing = true;
      copySelection(e, true, function () {
        env.event.call(CONST.EVENT.ON_CUT, e);
        frameViewUtils.onAdjustContainerSize();
        clipboardDoing = false;
      });
    },
    onDOMSubtreeModified: function onDOMSubtreeModified(e) {
      if (domUtils.isTag(env.body.firstElementChild, 'br')) {
        // 避免 由于删除操作导致的 body 内容为单纯的 br
        var br = env.body.firstElementChild;
        var tmp = env.doc.createElement('div');
        domUtils.before(tmp, br);
        tmp.appendChild(br);
      }
      env.event.call(CONST.EVENT.ON_DOM_SUBTREE_MODIFIED, e);
    },
    onDragStart: function onDragStart(e) {
      env.event.call(CONST.EVENT.ON_DRAG_START, e);
    },
    onDragEnter: function onDragEnter(e) {
      env.event.call(CONST.EVENT.ON_DRAG_ENTER, e);
    },
    onDrop: function onDrop(e) {
      var files = e.dataTransfer && e.dataTransfer.files ? e.dataTransfer.files : null;
      if (files && env.options.editor.callback.onDropFile) {
        env.options.editor.callback.onDropFile(files, e);
        utils.stopEvent(e);
        return;
      }
      env.event.call(CONST.EVENT.ON_DROP, e);
    },
    onKeydown: function onKeydown(e) {
      var isCmd = !env.browser.isMac && e.ctrlKey || env.browser.isMac && e.metaKey;
      if (env.browser.isIe && e.key === 'c' && isCmd) {
        handler.onCopy(e);
        return;
      }
      if (env.browser.isIe && e.key === 'x' && isCmd) {
        handler.onCut(e);
        return;
      }

      if (env.options.editor.callback.onKeyDown && !env.options.editor.callback.onKeyDown(e)) {
        return;
      }

      // 修正 body 避免 body 为空
      var range = rangeUtils.getRange();
      var line = void 0;
      if (range && range.collapsed && env.body && env.body.childNodes.length === 0) {
        line = env.doc.createElement('div');
        line.appendChild(env.doc.createElement('br'));
        env.body.appendChild(line);
        rangeUtils.setRange(line, 1);
      }

      // Mac 端 Ctrl + S 触发保存操作
      var keyCode = e.keyCode || e.which;
      if (env.win.WizQtEditor && env.client.type.isMac && keyCode === 83 && isCmd) {
        env.win.WizQtEditor.saveCurrentNote();
      }

      if (codeUtils && codeUtils.getContainerFromChild(e.target)) {
        // CodeMirror 内键盘操作全部忽略
        return;
      }

      var sel = void 0,
          method = void 0,
          direct = void 0,
          type = void 0;
      var zone = tableZone.getZone();
      // Mac 端快捷键
      if (env.browser.isMac && !zone.range) {
        sel = rangeUtils.getSelection();
        method = e.shiftKey ? 'extend' : 'move';
        if (e.metaKey && keyCode === 37 || e.ctrlKey && keyCode === 65) {
          // Cmd + left or  Ctrl + A
          direct = 'backward';
          type = 'lineboundary';
        } else if (e.metaKey && keyCode === 39 || e.ctrlKey && keyCode === 69) {
          // Cmd + right or  Ctrl + E
          direct = 'forward';
          type = 'lineboundary';
        } else if (e.metaKey && keyCode === 38) {
          // Cmd + up
          direct = 'backward';
          type = 'documentboundary';
        } else if (e.metaKey && keyCode === 40) {
          // Cmd + down
          direct = 'forward';
          type = 'documentboundary';
        } else if (e.ctrlKey && keyCode === 80) {
          // Ctrl + P
          direct = 'backward';
          type = 'line';
        } else if (e.ctrlKey && keyCode === 78) {
          // Ctrl + N
          direct = 'forward';
          type = 'line';
        } else if (e.ctrlKey && keyCode === 70) {
          // Ctrl + F
          direct = 'forward';
          type = 'character';
        } else if (e.ctrlKey && keyCode === 66) {
          // Ctrl + B
          direct = 'backward';
          type = 'character';
        }
      }

      if (direct) {
        // 满足快捷键需求，则修改 range
        sel.modify(method, direct, type);
        // 如果 开头 或结尾 是 table 或 code ，则由于容器 contenteditable = false，会导致功能失效
        if (type === 'documentboundary') {
          if (direct === 'forward') {
            var last = domUtils.getLast();
            var tableContainer = tableUtils.getContainer(last);
            if (tableContainer) {
              rangeUtils.setRange(tableContainer, tableContainer.childNodes.length);
            } else {
              var codeContainer = codeUtils.getContainerFromChild(last);
              if (codeContainer) {
                codeUtils.focusToLast(codeContainer.codeMirror);
              }
            }
          } else {
            var first = domUtils.getFirst();
            var _tableContainer = tableUtils.getContainer(first);
            if (_tableContainer) {
              rangeUtils.setRange(_tableContainer, 0);
            } else {
              var _codeContainer = codeUtils.getContainerFromChild(first);
              if (_codeContainer) {
                codeUtils.focusToFirst(_codeContainer.codeMirror);
              }
            }
          }
        }
        rangeUtils.fixScroll();
        return;
      }

      env.event.call(CONST.EVENT.ON_KEY_DOWN, e);

      frameViewUtils.onAdjustContainerSize();
    },
    onKeyup: function onKeyup(e) {
      rangeUtils.caretFocus();
      env.event.call(CONST.EVENT.ON_KEY_UP, e);
      // IOS 在键盘输入时，需要修正光标位置，保证光标进入可视区
      if (env.client.type.isIOS) {
        rangeUtils.fixScroll();
      }
    },
    onMousedown: function onMousedown(e) {
      if (env.isShowPreview) {
        return;
      } else if (!domUtils.isInWizBody(e.target)) {
        // 编辑器 container 非 body 时，利用 MouseDown 事件判断是否点击到 编辑器外，且需要清空 tableZone
        // 否则在 onCopy 、onCut 时无法判断是否是复制、剪切 编辑器内的表格内容
        tableZone.clear();
        return;
      }

      env.event.call(CONST.EVENT.ON_MOUSE_DOWN, e);
      frameViewUtils.onAdjustContainerSize();
    },
    onMousemove: function onMousemove(e) {
      if (env.isShowPreview) {
        return;
      }
      env.event.call(CONST.EVENT.ON_MOUSE_MOVE, e);
    },
    onMouseover: function onMouseover(e) {
      if (env.isShowPreview) {
        return;
      }
      env.event.call(CONST.EVENT.ON_MOUSE_OVER, e);
    },
    onMouseup: function onMouseup(e) {
      if (env.isShowPreview) {
        return;
      }
      env.event.call(CONST.EVENT.ON_MOUSE_UP, e);
    },
    onOrientationchange: function onOrientationchange(e) {
      env.event.call(CONST.EVENT.ON_ORIENTATION_CHANGE, e);
      // IOS 横竖屏转换后 自动修正光标进入可视区
      if (env.client.type.isIOS) {
        rangeUtils.fixScroll();
      }
    },
    onPaste: function onPaste(e) {
      if (env.isShowPreview) {
        return;
      }
      var callback = function callback(hasPasted) {
        if (hasPasted) {
          env.event.call(CONST.EVENT.ON_PASTE, e);
        }
        frameViewUtils.onAdjustContainerSize();
        clipboardDoing = false;
      };
      clipboardDoing = true;
      pasteUtils.pasteFromClipBoard(e, callback);
    },
    onScroll: function onScroll(e) {
      env.event.call(CONST.EVENT.ON_SCROLL, e);
    },
    onSelectionStart: function onSelectionStart(e) {
      env.event.call(CONST.EVENT.ON_SELECT_START, e);
    },
    onSelectionChange: function onSelectionChange(e) {
      // clipboardDoing = true 时说明正在处理剪切板内容，不触发 selectionChange 事件
      if (env.isShowPreview || clipboardDoing) {
        return;
      }
      var range = rangeUtils.getRange(),
          zone = tableZone.getZone();
      if (!range && !zone.range) {
        return;
      }

      env.event.call(CONST.EVENT.ON_SELECTION_CHANGE, e);

      // TODO 以后 升级 WebView 后可以考虑删除
      // 针对 Mac 客户端 v2.7.1 WebView bug 修正（避免 table 内 单元格开头输入中文异常）
      range = rangeUtils.getRange();
      zone = tableZone.getZone();
      if (env.client.type.isMac && zone.range && range) {
        var startDetail = rangeUtils.getRangeDetail(range.startContainer, range.startOffset);
        var endDetail = rangeUtils.getRangeDetail(range.endContainer, range.endOffset);
        var target = zone.start.cell;
        if (!domUtils.isTag(target.firstChild, 'div')) {
          var div = domUtils.packageChildNodesByDiv(target);
          if (div.childNodes.length === 0) {
            div.innerHTML = '<br/>';
            rangeUtils.setRange(div, 0);
          } else {
            rangeUtils.setRange(startDetail.container, startDetail.offset, endDetail.container, endDetail.offset);
          }
        }
      }

      // IOS 在键盘输入时，需要修正光标位置，保证光标进入可视区
      if (env.client.type.isIOS) {
        rangeUtils.fixScroll();
      }
      frameViewUtils.onAdjustContainerSize();
      // console.log(JSON.stringify(rangeUtils.getRange().getClientRects()));
      // console.log(rangeUtils.getRange().getClientRects());
    },
    onTouchEnd: function onTouchEnd(e) {
      if (env.isShowPreview) {
        return;
      }
      env.event.call(CONST.EVENT.ON_TOUCH_END, e);
    },
    onTouchStart: function onTouchStart(e) {
      if (env.isShowPreview) {
        return;
      }
      env.event.call(CONST.EVENT.ON_TOUCH_START, e);
    }
  };

  this.TYPE = EditorEventType;
  this.bind = function () {
    _this.unbind();
    env.body.addEventListener('click', handler.onClick);
    env.body.addEventListener('compositionstart', handler.onCompositionstart);
    env.body.addEventListener('compositionend', handler.onCompositionend);
    env.body.addEventListener('DOMSubtreeModified', handler.onDOMSubtreeModified);
    env.body.addEventListener('dragstart', handler.onDragStart);
    env.body.addEventListener('dragenter', handler.onDragEnter);
    env.body.addEventListener('drop', handler.onDrop);
    env.body.addEventListener('keydown', handler.onKeydown);
    env.body.addEventListener('keyup', handler.onKeyup);
    env.body.addEventListener('mousemove', handler.onMousemove);
    env.body.addEventListener('mouseover', handler.onMouseover);
    env.body.addEventListener('mouseup', handler.onMouseup);
    env.body.addEventListener('paste', handler.onPaste);
    env.body.addEventListener('selectstart', handler.onSelectionStart);

    // 如果使用 env.body，当 编辑器 非 body 时，编辑器内无光标时不会触发 copy cut 两个事件，
    // 导致 选中多个 table 单元格时，无法被复制、剪切
    env.doc.addEventListener('copy', handler.onCopy);
    env.doc.addEventListener('cut', handler.onCut);
    // mousedown 使用 env.doc 主要用于配合 copy、cut
    env.doc.addEventListener('mousedown', handler.onMousedown);
    env.doc.addEventListener('orientationchange', handler.onOrientationchange);
    env.doc.addEventListener('scroll', handler.onScroll);
    env.doc.addEventListener('selectionchange', handler.onSelectionChange);

    if (env.supportTouchEvent) {
      env.body.addEventListener('touchend', handler.onTouchEnd);
      env.body.addEventListener('touchstart', handler.onTouchStart);
    }

    frameViewUtils.onAdjustContainerSize();
  };
  this.unbind = function () {
    env.body.removeEventListener('click', handler.onClick);
    env.body.removeEventListener('compositionstart', handler.onCompositionstart);
    env.body.removeEventListener('compositionend', handler.onCompositionend);
    env.body.removeEventListener('DOMSubtreeModified', handler.onDOMSubtreeModified);
    env.body.removeEventListener('dragstart', handler.onDragStart);
    env.body.removeEventListener('dragenter', handler.onDragEnter);
    env.body.removeEventListener('drop', handler.onDrop);
    env.body.removeEventListener('keydown', handler.onKeydown);
    env.body.removeEventListener('keyup', handler.onKeyup);
    env.body.removeEventListener('mousemove', handler.onMousemove);
    env.body.removeEventListener('mouseover', handler.onMouseover);
    env.body.removeEventListener('mouseup', handler.onMouseup);
    env.body.removeEventListener('paste', handler.onPaste);
    env.body.removeEventListener('selectstart', handler.onSelectionStart);
    env.body.removeEventListener('touchend', handler.onTouchEnd);
    env.body.removeEventListener('touchstart', handler.onTouchStart);

    env.doc.removeEventListener('copy', handler.onCopy);
    env.doc.removeEventListener('cut', handler.onCut);
    env.doc.removeEventListener('mousedown', handler.onMousedown);
    env.doc.removeEventListener('orientationchange', handler.onOrientationchange);
    env.doc.removeEventListener('scroll', handler.onScroll);
    env.doc.removeEventListener('selectionchange', handler.onSelectionChange);
  };
  this.addListener = function (eName, fun) {
    if (!fun || typeof fun !== 'function') {
      return;
    }
    var h = editorListener[eName];
    if (!h) {
      return;
    }
    for (var i = 0, j = h.length; i < j; i++) {
      if (h[i] === fun) {
        return;
      }
    }
    h.push(fun);
    if (eName === EditorEventType.SelectionChange) {
      env.event.add(CONST.EVENT.ON_SELECTION_CHANGE, getCaretStyle);
    }
  };
  this.removeListener = function (eName, fun) {
    if (fun && typeof fun !== 'function') {
      return;
    }
    var h = editorListener[eName];
    if (!h) {
      return;
    }
    for (var i = h.length - 1; i >= 0; i--) {
      if (h[i] === fun || !fun) {
        h.splice(i, 1);
      }
    }

    if (h.length === 0) {
      env.event.remove(CONST.EVENT.ON_SELECTION_CHANGE, getCaretStyle);
    }
  };
  this.startTrackEvent = function (eventName, id) {
    if (!eventTrackHandler[id]) {
      eventTrackHandler[id] = function (event) {
        env.client.sendCmdToWizClient(CONST.CLIENT_EVENT.WizEditorTrackEvent, {
          id: id,
          e: eventStringify(event)
        });
      };
      env.body.addEventListener(eventName, eventTrackHandler[id]);
    }
  };
  this.stopTrackEvent = function (eventName, id) {
    if (eventTrackHandler[id]) {
      env.body.removeEventListener(eventName, eventTrackHandler[id]);
      delete eventTrackHandler[id];
    }
  };
  this.triggerListener = function (eName, params) {
    var h = editorListener[eName];
    if (!h) {
      return;
    }
    for (var i = 0, j = h.length; i < j; i++) {
      var f = h[i];
      f.apply(_this, params);
    }
  };
};

module.exports = EditorEvent;

},{"../../config/const":388,"../../libs/utils":400}],368:[function(require,module,exports){
'use strict';

/**
 * 编辑器 基础工具包
 */
var CONST = require('../../config/const');
var utils = require('../../libs/utils');

var EditorUtils = function EditorUtils() {
  var _this = this;

  var core = null;
  var env = null;
  var amend = null;
  var amendUser = null;
  var amendUtils = null;
  var commandExtend = null;
  var domUtils = null;
  var frameViewUtils = null;
  var rangeUtils = null;
  var tableCore = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    amend = core.require.amend;
    amendUser = core.require.amendUser;
    amendUtils = core.require.amendUtils;
    commandExtend = core.require.commandExtend;
    domUtils = core.require.domUtils;
    frameViewUtils = core.require.frameViewUtils;
    rangeUtils = core.require.rangeUtils;
    tableCore = core.require.tableCore;
  };

  var afterInsertTimer = void 0;
  var afterInsert = function afterInsert(lastNode) {
    //Preserve the selection
    if (!lastNode) {
      return;
    }
    if (afterInsertTimer) {
      clearTimeout(afterInsertTimer);
    }
    var rangTimer = 30,
        scrollTimer = 30;

    if (env.client.type.isPhone) {
      rangTimer = 100;
      scrollTimer = 300;
    }

    afterInsertTimer = setTimeout(function () {
      var start = void 0,
          target = lastNode;
      if (domUtils.isSelfClosingTag(lastNode)) {
        target = target.parentNode;
        start = domUtils.getIndex(lastNode) + 1;
      } else {
        start = domUtils.getEndOffset(lastNode);
      }
      frameViewUtils.onAdjustContainerSize();

      if (domUtils.isEmptyDom(target)) {
        //避免 br 堆积
        start = 0;
      }
      rangeUtils.setRange(target, start, null, null);

      if (lastNode.nodeType === 1) {
        afterInsertTimer = setTimeout(function () {
          frameViewUtils.onAdjustContainerSize();
          rangeUtils.fixScroll();
          // lastNode.scrollIntoViewIfNeeded();
        }, scrollTimer);
      }
    }, rangTimer);
  };
  var getSelectedTxt = function getSelectedTxt() {
    return rangeUtils.getSelection().toString();
  };

  this.find = function (str, matchcase, searchBackward, loop) {
    if (!str) {
      return false;
    }
    var result = env.win.find(str, matchcase, searchBackward);
    if (!result && !!loop) {
      rangeUtils.setRange(env.body, searchBackward ? env.body.childNodes.length : 0);
      result = env.win.find(str, matchcase, searchBackward);
    }
    return result;
  };
  /**
   * 插入内容前准备工作
   */
  this.readyForInsert = function () {
    var sel = rangeUtils.getSelection(),
        range = rangeUtils.getRange(),
        startDom = void 0,
        startOffset = void 0,
        result = {
      parent: null,
      target: null
    },
        span = void 0,
        cannotInsertDom = void 0;

    if (!range) {
      //如果页面没有焦点， 则尝试恢复光标位置， 失败后自动让 body 获取焦点
      if (!rangeUtils.caretRestore()) {
        domUtils.focus();
      }
    }

    if (amend.isAmendEditing()) {
      //修订编辑模式下，先做修订的删除操作
      if (!range.collapsed) {
        amendUtils.removeSelection(amendUser.getCurUser());
        amendUtils.removeUserDel(null, amendUser.getCurUser());
        sel.collapseToEnd();
      }
    }

    // Iphone 端 添加 附件后，光标定位在附件的 <a> 标签后，添加图片会把图片添加到 <a> 内
    // 下面代码主要用于修正这种 bug
    range = rangeUtils.getRange();
    if (range.collapsed) {
      startDom = range.startContainer;
      startOffset = range.startOffset;
      // 判断光标是否在 附件的 <a> 标签内
      cannotInsertDom = domUtils.getParentByFilter(startDom, function (node) {
        if (node.nodeType !== 1) {
          return false;
        }
        var href = node.getAttribute('href');
        if (href && /^wiz:\/*open_attachment\?/i.test(href)) {
          return true;
        }
        return false;
      }, true);
      if (cannotInsertDom) {
        span = domUtils.createSpan();
        span.innerHTML = CONST.FILL_CHAR;
        if (startOffset === 0) {
          // 如果 光标在 <a> 前面 则将 span 插入到 <a> 前面
          domUtils.before(span, cannotInsertDom);
          rangeUtils.setRange(span, 0);
        } else {
          // 如果 光标在 <a> 中间 或 后面，则将 span 插入到 <a> 后面
          domUtils.after(span, cannotInsertDom);
          rangeUtils.setRange(span, 1);
        }
      }
    }

    //TODO 目前暂不考虑 插入 dom 和 html 时进行修订处理，仅保证不影响修订dom
    var fixed = amendUtils.fixedAmendRange();
    var newDom = amend.splitAmendDomByRange(fixed);

    range = rangeUtils.getRange();
    startDom = range.startContainer;
    startOffset = range.startOffset;

    if (newDom) {
      //直接找到新节点位置
      result.target = newDom;
      result.parent = newDom.parentNode;
    } else if (startDom.nodeType === 3 && startOffset > 0 && startOffset < startDom.nodeValue.length) {
      //处于 textNode 的中间
      result.target = domUtils.splitRangeText(startDom, startOffset, null, false);
      result.parent = result.target.parentNode;
    } else if (startDom.nodeType === 1 && startOffset > 0 && startOffset < startDom.childNodes.length) {
      //处于 element 节点中间
      result.target = startDom.childNodes[startOffset];
      result.parent = startDom;
    } else if (startDom === env.body || startDom === env.body.parentNode) {
      //处于 body 的根位置
      result.target = startOffset === 0 ? env.body.childNodes[0] : null;
      result.parent = env.body;
    } else if (startOffset === 0) {
      //处于 某 dom 的开始
      result.target = startDom;
      result.parent = startDom.parentNode;
    } else if (startDom.nodeType === 3) {
      //处于 textNode 的结尾
      result.target = startDom.nextSibling;
      result.parent = startDom.parentNode;
    } else {
      //处于 element 的结尾
      result.target = null;
      result.parent = startDom;
    }

    //如果下一个是 element 节点，并且为空， 则直接将内容写入到 该 element 内
    //主要针对 <div><br/></div>
    if (result.target && result.target.nodeType === 1 && !domUtils.isSelfClosingTag(result.target) && domUtils.isEmptyDom(result.target)) {
      result.parent = result.target;
      if (domUtils.isTag(result.parent.childNodes[0], 'br')) {
        //添加 DOM 在 br 前需要将 br 删除
        result.parent.removeChild(result.parent.childNodes[0]);
        result.target = result.parent.childNodes.length > 0 ? result.parent.childNodes[0] : null;
      } else {
        result.target = result.parent.childNodes[0];
      }
    }

    if (domUtils.isWizDom(result.parent)) {
      // 不能把 Wiz 专用 dom 当作 parent ，否则会导致 DOM 被插入到 Wiz 专用 Dom 内
      result.target = result.parent;
      result.parent = result.parent.parentNode;
    }
    return result;
  };
  this.insertDom = function (domList, notInsertEmptyDiv) {
    if (!domList) {
      return;
    }
    // 尽量避免 插入Dom 时，造成的 div 反复嵌套，在 结尾处，必须找到最后有 nextSibling 的父节点
    var getBlockEnd = function getBlockEnd(result) {
      if (result.parent && !result.target) {
        while (result.parent !== env.body && !result.target) {
          result.target = result.parent.nextSibling;
          result.parent = result.parent.parentNode;
        }
      }
    };
    var getImg = function getImg(tmpDom) {
      if (tmpDom.nodeType !== 1) {
        return null;
      }
      var tmpImgs = void 0;
      if (domUtils.isTag(tmpDom, 'img')) {
        return tmpDom;
      } else {
        tmpImgs = tmpDom.querySelectorAll('img');
        if (tmpImgs.length > 0) {
          return tmpImgs[tmpImgs.length - 1];
        }
      }
      return null;
    };

    var tmpDom = _this.readyForInsert(),
        tmpParent = void 0,
        lastDom = void 0,
        imgLast = void 0,
        tmpImgLast = void 0;

    if (notInsertEmptyDiv && domUtils.isEmptyDom(tmpDom.parent) && !domUtils.isTag(tmpDom.parent, ['td', 'th']) && !tmpDom.target) {
      tmpParent = tmpDom.parent;
      tmpDom.parent = tmpParent.parentNode;
      tmpDom.target = tmpParent.nextSibling;
      tmpDom.parent.removeChild(tmpParent);
    }
    if (!utils.isArray(domList)) {
      domList = [domList];
    }
    for (var i = 0, j = domList.length; i < j; i++) {
      var dom = domList[i];
      if (domUtils.isBlock(dom)) {
        getBlockEnd(dom);
      }
      tmpDom.parent.insertBefore(domList[i], tmpDom.target);
      tmpImgLast = getImg(domList[i]);
      if (tmpImgLast) {
        imgLast = tmpImgLast;
      }
      lastDom = domList[i];
    }

    afterInsert(lastDom);
    // 浏览器插入 img 后，渲染为异步过程，针对最后一张图片 load 事件修正，避免 afterInsert 无效
    if (imgLast) {
      imgLast.addEventListener('load', function () {
        afterInsert(lastDom);
      });
    }
  };
  this.insertHtml = function (html, notInsertEmptyDiv) {
    if (!html) {
      return;
    }
    var template = env.doc.createElement('div'),
        doms = [];
    template.innerHTML = html;
    for (var i = 0, j = template.childNodes.length; i < j; i++) {
      doms.push(template.childNodes[i]);
    }
    _this.insertDom(doms, notInsertEmptyDiv);
    template = null;
    env.event.call(CONST.EVENT.AFTER_INSERT_DOM);
  };
  this.modifySelectionDom = function (style, attr) {
    if (!tableCore.modifySelectionDom(style, attr)) {
      // 处理普通文本样式
      rangeUtils.modifySelectionDom(style, attr);
    }
  };
  this.replace = function (from, to, matchcase) {
    if (!from) {
      return false;
    }
    var selectedTxt = getSelectedTxt(),
        span = void 0,
        txt = void 0;
    if (selectedTxt === from) {
      //替换
      if (!to) {
        to = '';
      } else {
        txt = env.doc.createTextNode(to);
        span = env.doc.createElement('span');
        span.appendChild(txt);
        to = span.innerHTML;
        span = null;
        txt = null;
      }
      commandExtend.execCommand('insertHTML', false, to);
    }

    // 查找下一个
    return _this.find(from, matchcase);
  };
  this.replaceAll = function (from, to, matchcase) {
    if (!from) {
      return false;
    }
    rangeUtils.setRange(env.body, 0);
    while (_this.replace(from, to, matchcase)) {}
  };

  this.replaceSvg = function (dataList) {
    if (!dataList || dataList.length === 0) {
      return;
    }
    for (var i = 0; i < dataList.length; i++) {
      var data = dataList[i];
      var dom = env.body.querySelector('#' + data.id);
      if (dom) {
        // 在页面内找到 id 对应的 dom
        if (data.deleted) {
          // 删除
          domUtils.remove(dom);
          continue;
        }
        // 替换
        dom.outerHTML = data.html;
      } else if (!data.deleted) {
        // 在页面内没有找到 id 对应的 dom
        var template = env.doc.createElement('div');
        template.innerHTML = data.html;
        env.doc.body.appendChild(template.firstElementChild);
      }
    }
  };
};

module.exports = EditorUtils;

},{"../../config/const":388,"../../libs/utils":400}],369:[function(require,module,exports){
'use strict';

/**
 * frameView 操作核心包 core
 */
var CONST = require('../../config/const');

var FrameViewCore = function FrameViewCore() {
  var core = null;
  var env = null;
  var frameViewStyle = null;
  var frameViewUtils = null;
  var toolbarMarkdown = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    frameViewStyle = core.require.frameViewStyle;
    frameViewUtils = core.require.frameViewUtils;
    toolbarMarkdown = core.require.toolbarMarkdown;
  };

  this.init = function () {};
  this.off = function () {
    frameViewStyle.removeFrameStyle();
    frameViewUtils.off();
    if (toolbarMarkdown) {
      toolbarMarkdown.off();
    }
  };
  this.on = function () {
    if (env.options.container && env.options.useFrame) {
      frameViewStyle.insertFrameStyle();
    }
    if (!env.readonly && env.options.editor.type === CONST.NOTE_EDITOR_TYPE.MARKDOWN && env.frame.toolbarContainer) {
      // 只读 / 非 Markdown 编辑 / 关闭 Toolbar / 编辑容器为 body 时不显示 toolbar
      if (toolbarMarkdown) {
        toolbarMarkdown.on();
      }
      return;
    }
    frameViewUtils.on();
  };
};

module.exports = FrameViewCore;

},{"../../config/const":388}],370:[function(require,module,exports){
'use strict';

/**
 * todoList 相关样式处理
 */
var CONST = require('../../config/const');

var CSS = {
  // container:
  toolbar: '.' + CONST.CLASS.EDITING + '.' + CONST.CLASS.EDITOR_CONTAINER + ' {' + 'border: 1px solid silver;padding-top: 5px;' + '}' + '.' + CONST.CLASS.WIZ_EIDTOR_TOOlBAR_CONTAINER + ' {' + 'display:flex;' + '}' + '.' + CONST.CLASS.WIZ_EIDTOR_TOOlBAR_MAIN + ' {' + 'flex:1;' + '}' + '.' + CONST.CLASS.WIZ_EIDTOR_TOOlBAR_MAIN + ' .toolbar-split {' + 'width: 0;border-left: 1px solid #d9d9d9;border-right: 1px solid #fff;color: transparent;text-indent: -10px;margin: 0 6px;' + '}' + '.' + CONST.CLASS.WIZ_EIDTOR_TOOlBAR_CONTAINER + ' .editor-button {' + 'display:inline-block;position:relative;' + '}' + '.' + CONST.CLASS.WIZ_EIDTOR_TOOlBAR_CONTAINER + ' .editor-button .editor-submenu {' + 'position: absolute;display: none;width: 195px;padding: 5px 0;background: #fff;border-radius: 3px;border: 1px solid #E0E0E0;top:28px;left:-9px;box-shadow: 1px 1px 5px #d0d0d0;z-index:100;' + '}' + '.' + CONST.CLASS.WIZ_EIDTOR_TOOlBAR_CONTAINER + ' .editor-button.active .editor-submenu {' + 'display:block;' + '}' + '.' + CONST.CLASS.WIZ_EIDTOR_TOOlBAR_CONTAINER + ' .editor-button .editor-submenu-label{' + 'padding: 0 6px; font-size: 14px;' + '}' + '.' + CONST.CLASS.WIZ_EIDTOR_TOOlBAR_CONTAINER + ' .editor-button .editor-submenu table{' + 'border: 0;border-collapse: initial;border-spacing: 3px;background-color: white;margin: 0 auto;' + '}' + '.' + CONST.CLASS.WIZ_EIDTOR_TOOlBAR_CONTAINER + ' .editor-button .editor-submenu table td{' + 'border-collapse: collapse;border: 1px solid #bbbbbb;box-sizing: border-box;position: relative;padding: 3px;width: 16px;height: 16px;' + '}' + '.' + CONST.CLASS.WIZ_EIDTOR_TOOlBAR_CONTAINER + ' .editor-button .editor-submenu table td.selected{' + 'border-color: #448aff;' + '}' + '.' + CONST.CLASS.WIZ_EIDTOR_TOOlBAR_CONTAINER + ' .editor-icon {' + 'font-size:16px;padding:4px;border:1px solid transparent;border-radius: 3px;cursor: pointer;color:#2c3e50' + '}' + '.' + CONST.CLASS.WIZ_EIDTOR_TOOlBAR_CONTAINER + ' .editor-icon.hover {' + 'background:#fcfcfc;border-color:#95a5a6;' + '}' + '.' + CONST.CLASS.WIZ_EIDTOR_TOOlBAR_CONTAINER + ' .editor-icon.disabled,' + '.' + CONST.CLASS.WIZ_EIDTOR_TOOlBAR_CONTAINER + ' .editor-icon.disabled.hover {' + 'background:#fcfcfc;border-color:transparent;color:#94a0ad;' + '}',
  preview: '.' + CONST.CLASS.WIZ_EIDTOR_PREVIEW_CONTAINER + '{' + 'position:absolute;top:2px;bottom:0;left:0;right:0;background:#FFF;display:none;z-index:999;overflow:auto;' + '}' + '.' + CONST.CLASS.WIZ_EIDTOR_PREVIEW_CONTAINER + '.' + CONST.CLASS.EDITOR_PREVIEW_SHOW + '{' + 'display:block;' + '}',
  frame: 'body {overflow-y: hidden;}'
};

var FrameViewStyle = function FrameViewStyle() {
  var _this = this;

  var core = null;
  var env = null;
  var domUtils = null;
  var wizStyle = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
    wizStyle = core.require.wizStyle;
  };

  this.insertFrameStyle = function () {
    _this.removeFrameStyle();
    wizStyle.insertStyle({
      id: CONST.ID.WIZ_EIDTOR_FRAME_STYLE,
      name: CONST.NAME.TMP_STYLE
    }, CSS.frame);
  };
  this.insertPreviewStyle = function () {
    _this.removePreviewStyle();
    wizStyle.insertStyle({
      id: CONST.ID.WIZ_EIDTOR_PREVIEW_STYLE,
      name: CONST.NAME.TMP_STYLE
    }, CSS.preview);
  };
  this.insertToolbarStyle = function () {
    _this.removeToolbarStyle();
    var s = env.frame.toolbarDoc.getElementById(CONST.ID.WIZ_EIDTOR_TOOlBAR_STYLE);
    if (!s) {
      s = env.frame.toolbarDoc.createElement('style');
      s.id = CONST.ID.WIZ_EIDTOR_TOOlBAR_STYLE;
      env.frame.toolbarDoc.getElementsByTagName('HEAD')[0].insertBefore(s, null);
    }
    if (s) {
      s.innerHTML = CSS.toolbar;
    }
  };
  this.removeFrameStyle = function () {
    domUtils.remove(env.doc.getElementById(CONST.ID.WIZ_EIDTOR_FRAME_STYLE));
  };
  this.removePreviewStyle = function () {
    domUtils.remove(env.doc.getElementById(CONST.ID.WIZ_EIDTOR_PREVIEW_STYLE));
  };
  this.removeToolbarStyle = function () {
    domUtils.remove(env.frame.toolbarDoc.getElementById(CONST.ID.WIZ_EIDTOR_TOOlBAR_STYLE));
  };
};

module.exports = FrameViewStyle;

},{"../../config/const":388}],371:[function(require,module,exports){
'use strict';

/**
 * frame 操作工具包
 */
var CONST = require('../../config/const');

var FrameViewUtils = function FrameViewUtils() {
  var _this = this;

  var core = null;
  var env = null;
  var domUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
  };

  var adjustContainerTimer = void 0;
  var adjustScrollTimer = void 0;
  var lastChildBottomY = -1;
  var lastHeight = -1;
  var lastBodyMinHeight = -1;

  var _handler = {
    onAdjustContainerSize: function onAdjustContainerSize() {
      var bodyMinHeight = env.readonly ? env.options.reader.minHeight : env.options.editor.minHeight;
      if (!env.options.container || !env.options.useFrame) {
        if (env.options.container && !env.options.useFrame && bodyMinHeight) {
          env.body.style.minHeight = bodyMinHeight + 'px';
        }
        return;
      }
      clearTimeout(adjustContainerTimer);
      adjustContainerTimer = setTimeout(function () {
        // Excel 导入的笔记不需要动态改变高度
        var isExcelImport = domUtils.isTag(env.body, 'frameset');

        // 不直接使用 body 的 clientHeight ，因为 body 扩大后，不会自动缩小
        var last = !isExcelImport ? env.body.lastChild : null;
        while (last) {
          // 避免由于 last 为 textNote 导致的高度计算错误
          if (last.nodeType === 3 && !domUtils.isEmptyDom(last)) {
            var tmp = env.doc.createElement('span');
            domUtils.before(tmp, last);
            tmp.appendChild(last);
            last = tmp;
          }
          if (last.nodeType !== 1 || domUtils.checkInTmp(last) || domUtils.getComputedStyle(last, 'display') === 'none' || last.clientHeight === 0 && last.offsetHeight === 0) {
            last = last.previousSibling;
            continue;
          }
          var isAbsolute = /^(absolute|fixed)/ig.test(domUtils.getComputedStyle(last, 'position'));
          if (last.previousSibling && isAbsolute) {
            last = last.previousSibling;
            continue;
          }
          break;
        }

        var scrollObj = env.doc.documentElement;
        if (env.body !== env.doc.body) {
          scrollObj = env.body;
        }
        // +25 的作用非常大，可以避免在最下行输入回车时，界面抖动
        // let height = Math.max(last ? (last.offsetTop + last.offsetHeight + 25) : 0, bodyMinHeight);
        var height = 0;
        // Web端每次切换笔记时，都会先 destory，这时候会设置 body 为最小高度；
        // 所以有内容时可以放心使用 env.body.scrollHeight 获取 body 高度
        // 如果没有 destory，env.body.scrollHeight 会导致 body 永远都是最大的那个
        if (last) {
          var lastMarginBottom = parseInt(domUtils.getComputedStyle(last, 'margin-bottom'), 10) || 0;
          var bodyMarginBottom = parseInt(domUtils.getComputedStyle(env.body, 'margin-bottom'), 10) || 0;
          var bodyPaddingBottom = parseInt(domUtils.getComputedStyle(env.body, 'padding-bottom'), 10) || 0;

          var lastBottomY = last.offsetTop + last.offsetHeight;
          // let bodyHeight = Math.min(lastBottomY, env.body.scrollHeight);
          // height = Math.max(bodyHeight + bodyMarginBottom, bodyMinHeight);
          // 调整算法， last 仍然经常不准确，并且 Web 端保证先 destory 后可以直接采用 scrollHeight
          // 必须要去除 bodyMarginBottom，否则会导致编辑时 height 无限增加
          var bodyHeight = scrollObj.scrollHeight - bodyMarginBottom;
          height = Math.max(bodyHeight, bodyMinHeight);
          if (lastBodyMinHeight !== bodyMinHeight || lastHeight <= height && lastBottomY < lastChildBottomY) {
            // 如果 lastBottomY 变小需要修正高度，否则 body 不会自动缩小
            // 需要考虑 last 的 bottom 和 body 的 padding & margin
            height = Math.max(lastBottomY + lastMarginBottom + bodyPaddingBottom, bodyMinHeight);
          }
          lastChildBottomY = lastBottomY;
          lastBodyMinHeight = bodyMinHeight;
        } else if (env.isWizTemplate) {
          var _bodyHeight = scrollObj.scrollHeight;
          height = Math.max(_bodyHeight, bodyMinHeight);
        } else if (isExcelImport) {
          // 导入的笔记设置高度为 窗口的 50%
          height = env.win.top.document.documentElement.clientHeight * 0.5;
        } else {
          height = bodyMinHeight;
        }
        // console.log(height);
        // let height = Math.max(last ? (last.offsetTop + last.offsetHeight) : 0, bodyMinHeight);
        env.frame.bodyContainer.style.height = height + 'px';
        if (!env.options.useFrame) {
          env.body.style.height = height + 'px';
        }

        lastHeight = height;

        if (env.doc.documentElement.scrollTop) {
          // 避免 频繁按下回车键，使得 iframe 内的滚动条移位，从而导致 顶部内容显示不完整
          // 采用 setTimeout 可以有效避免频繁跳动
          clearTimeout(adjustScrollTimer);
          adjustScrollTimer = setTimeout(function () {
            env.doc.documentElement.scrollTop = 0;
          }, 300);
        }
        // env.body.removeChild(last);
      }, 50);
    }
  };
  var _event = {
    bind: function bind() {
      _event.unbind();
      if (env.readonly && env.options.container && env.options.useFrame) {
        env.doc.addEventListener('DOMSubtreeModified', _this.onAdjustContainerSize);
      }
      if (env.options.container && env.options.useFrame) {
        env.win.addEventListener('resize', _this.onAdjustContainerSize);
        if (env.client.type.isWeb && env.win.top !== env.win) {
          env.win.top.addEventListener('resize', _this.onAdjustContainerSize);
        }
      }
    },
    unbind: function unbind() {
      env.doc.removeEventListener('DOMSubtreeModified', _this.onAdjustContainerSize);
      env.win.removeEventListener('resize', _this.onAdjustContainerSize);
      env.win.top.removeEventListener('resize', _this.onAdjustContainerSize);
    }
  };

  this.init = function () {};
  this.off = function () {
    _event.unbind();
  };
  this.on = function () {
    _event.bind();
  };
  this.onAdjustContainerSize = _handler.onAdjustContainerSize;
};

module.exports = FrameViewUtils;

},{"../../config/const":388}],372:[function(require,module,exports){
'use strict';

/**
 * toolbar 操作核心包 core
 */
var CONST = require('../../config/const');
var utils = require('../../libs/utils');
var MarkdownRender = require('../../common/MarkdownRender');

var _class = {
  active: 'active',
  button: 'editor-button',
  disabled: 'disabled',
  icon: 'editor-icon',
  selected: 'selected',
  subMenu: 'editor-submenu',
  subMenuLabel: 'editor-submenu-label',
  subMenuTable: 'editor-submenu-table',
  toolbarSplit: 'toolbar-split',

  imgName: 'editor-img-name',
  progressTxt: 'editor-progress-txt',
  progressLine: 'editor-progress-line'
};

var _id = {
  tmpImg: 'wiz-upload-img',
  bold: 'wiz-toolbar-bold',
  code: 'wiz-toolbar-code',
  help: 'wiz-toolbar-help',
  image: 'wiz-toolbar-image',
  italic: 'wiz-toolbar-italic',
  link: 'wiz-toolbar-link',
  listOl: 'wiz-toolbar-list-ol',
  listUl: 'wiz-toolbar-list-ul',
  preview: 'wiz-toolbar-preview',
  quotes: 'wiz-toolbar-quotes',
  redo: 'wiz-toolbar-redo',
  split: 'wiz-toolbar-split',
  table: 'wiz-toolbar-table',
  undo: 'wiz-toolbar-undo'
};

var ToolbarMarkdown = function ToolbarMarkdown() {
  var core = null;
  var env = null;
  var lang = null;
  var codeUtils = null;
  var domUtils = null;
  var editorEvent = null;
  var frameViewStyle = null;
  var historyUtils = null;
  var imgUtils = null;

  var rangeUtils = null;
  var tableCore = null;
  var tableMenu = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    lang = core.lang;
    codeUtils = core.require.codeUtils;
    domUtils = core.require.domUtils;
    editorEvent = core.require.editorEvent;
    frameViewStyle = core.require.frameViewStyle;
    historyUtils = core.require.historyUtils;
    imgUtils = core.require.imgUtils;
    rangeUtils = core.require.rangeUtils;
    tableCore = core.require.tableCore;
    tableMenu = core.require.tableMenu;
  };

  var markdownRender = null;
  var ToolsButtonMap = {};
  var MainTools = [{
    id: _id.bold,
    icon: 'bold'
  }, {
    id: _id.italic,
    icon: 'italic'
  }, {
    id: _id.link,
    icon: 'link'
  }, { id: _id.split }, {
    id: _id.quotes,
    icon: 'quotes'
  }, {
    id: _id.listOl,
    icon: 'list_ol'
  }, {
    id: _id.listUl,
    icon: 'list_ul'
  }, { id: _id.split }, {
    id: _id.image,
    icon: 'image'
  }, {
    id: _id.table,
    icon: 'table'
  }, {
    id: _id.code,
    icon: 'code'
  }, { id: _id.split }, {
    id: _id.undo,
    icon: 'undo'
  }, {
    id: _id.redo,
    icon: 'redo'
  }];
  var SideTools = [{
    id: _id.preview,
    icon: 'eye'
  }, {
    id: _id.help,
    icon: 'question'
  }];

  var activeButton = null;
  var uploaderId = '';

  var _event = {
    bind: function bind() {
      _event.unbind();
      editorEvent.addListener(editorEvent.TYPE.SelectionChange, _event.handler.onSelectionChange);
      historyUtils.addCallback(_event.handler.onHistoryUndo);

      if (env.supportTouchEvent) {
        env.frame.toolbarContainer.addEventListener('touchstart', _event.handler.onHoverButton);
      } else {
        env.frame.toolbarContainer.addEventListener('mouseover', _event.handler.onHoverButton);
        env.frame.toolbarContainer.addEventListener('mouseout', _event.handler.onHoverOutButton);
      }

      env.frame.toolbarContainer.addEventListener('click', _event.handler.onClickButton);
    },
    bindSubMenu: function bindSubMenu() {
      _event.unbindSubMenu();
      env.doc.addEventListener('mousedown', _event.handler.onClickDoc);
      var table = activeButton.querySelector('.' + _class.subMenuTable);
      if (table) {
        table.addEventListener('mouseover', _event.handler.onMouseOverTable);
        table.addEventListener('click', _event.handler.onSelectTable);
      }
    },
    unbindSubMenu: function unbindSubMenu() {
      env.doc.removeEventListener('mousedown', _event.handler.onClickDoc);
      var table = activeButton.querySelector('.' + _class.subMenuTable);
      if (table) {
        table.removeEventListener('mouseover', _event.handler.onMouseOverTable);
        table.removeEventListener('click', _event.handler.onSelectTable);
      }
    },
    unbind: function unbind() {
      editorEvent.removeListener(editorEvent.TYPE.SelectionChange, _event.handler.onSelectionChange);
      historyUtils.removeCallback(_event.handler.onHistoryUndo);
      if (env.frame.toolbarContainer) {
        env.frame.toolbarContainer.removeEventListener('click', _event.handler.onClickButton);
      }
    },
    handler: {
      onHoverButton: function onHoverButton(e) {
        var buttonIcon = e.target;
        if (!domUtils.hasClass(buttonIcon, _class.icon) || domUtils.hasClass(buttonIcon, _class.disabled)) {
          return;
        }
        domUtils.addClass(buttonIcon, 'hover');
      },
      onHoverOutButton: function onHoverOutButton(e) {
        var buttonIcon = e.target;
        if (!domUtils.hasClass(buttonIcon, _class.icon) || domUtils.hasClass(buttonIcon, _class.disabled)) {
          return;
        }
        domUtils.removeClass(buttonIcon, 'hover');
      },
      onClickButton: function onClickButton(e) {
        var buttonIcon = e.target;
        if (!domUtils.hasClass(buttonIcon, _class.icon) || domUtils.hasClass(buttonIcon, _class.disabled)) {
          return;
        }
        domUtils.removeClass(buttonIcon, 'hover');

        var button = buttonIcon.parentNode;
        var id = buttonIcon.id;
        var textNode = void 0,
            subMenu = void 0;
        switch (id) {
          case _id.bold:
            if (!env.isShowPreview) {
              historyUtils.saveSnap(false);
              textNode = _view.insertText('****');
              rangeUtils.setRange(textNode, 2);
            }
            break;
          case _id.italic:
            if (!env.isShowPreview) {
              historyUtils.saveSnap(false);
              textNode = _view.insertText('**');
              rangeUtils.setRange(textNode, 1);
            }
            break;
          case _id.link:
            if (!env.isShowPreview) {
              historyUtils.saveSnap(false);
              textNode = _view.insertText('[' + lang.Toolbar.LinkTopic + '](http://)');
              rangeUtils.setRange(textNode, 3);
            }
            break;

          case _id.quotes:
            if (!env.isShowPreview) {
              _view.insertQuotes();
            }
            break;
          case _id.listOl:
            if (!env.isShowPreview) {
              _view.insertListOl();
            }
            break;
          case _id.listUl:
            if (!env.isShowPreview) {
              _view.insertListUl();
            }
            break;

          case _id.image:
            if (!button.getAttribute('for')) {
              // 如果 上传图片 按钮 没有绑定 file input，则触发 callback
              var _callback = env.options.editor.callback.onClickToolbarInsertImg;
              if (typeof _callback === 'function') {
                _callback();
              }
            } else {
              rangeUtils.caretBackup();
            }
            break;

          case _id.code:
            if (!env.isShowPreview) {
              historyUtils.saveSnap(false);
              _view.insertText('\n');
              _view.insertText('```');
              textNode = _view.insertText('\n');
              _view.insertText('```');
              _view.insertText('\n');
              rangeUtils.setRange(textNode, 0);
            }
            break;
          // 可视化界面只能保证新建笔记时操作，但重新打开笔记就只能看到 Markdown 原文，
          // 为了保证操作一致性，还是只使用 纯文本方式
          // if (!env.isShowPreview) {
          //   codeCore.insertCode();
          // }
          // break;
          case _id.table:
            if (!env.isShowPreview) {
              if (_view.isActive(button)) {
                _view.setActive(button, false);
                break;
              }
              subMenu = _view.createSubMenu(button);
              _view.createTableSubMenu(subMenu);
              _view.setActive(button, true);
            }
            break;

          case _id.undo:
            if (!env.isShowPreview) {
              historyUtils.undo();
            }
            break;
          case _id.redo:
            if (!env.isShowPreview) {
              historyUtils.redo();
            }
            break;

          case _id.preview:
            _view.preview();
            break;

          case _id.help:
            var callback = env.options.editor.callback.onClickToolbarHelp;
            if (typeof callback === 'function') {
              callback();
            }
            break;
        }

        setTimeout(function () {
          env.body.focus();
        }, 50);
      },
      onClickDoc: function onClickDoc(e) {
        var target = e.target;
        var button = domUtils.getParentByClass(target, _class.button);
        if (button && button === activeButton) {
          return;
        }
        _view.setActive(activeButton, false);
      },
      onHistoryUndo: function onHistoryUndo(data) {
        var undo = ToolsButtonMap[_id.undo];
        var redo = ToolsButtonMap[_id.redo];
        if (data.undoIndex === 0) {
          domUtils.addClass(undo, _class.disabled);
        } else {
          domUtils.removeClass(undo, _class.disabled);
        }
        if (data.undoIndex >= data.undoCount - 1) {
          domUtils.addClass(redo, _class.disabled);
        } else {
          domUtils.removeClass(redo, _class.disabled);
        }
      },
      onMouseOverTable: function onMouseOverTable(e) {
        var target = e.target,
            x = void 0;
        var cols = 0,
            rows = 0;
        if (target.nodeType === 1 && /^td$/i.test(target.tagName)) {
          x = target.getAttribute('data-index').split('-');
          rows = parseInt(x[0], 10);
          cols = parseInt(x[1], 10);
        }
        var subMenu = domUtils.getParentByClass(target, _class.subMenu);
        var table = domUtils.getParentByClass(target, _class.subMenuTable);
        var label = subMenu.querySelector('.' + _class.subMenuLabel);
        if (cols && rows) {
          label.innerHTML = rows + ' x ' + cols;
          table.selectRow = rows;
          table.selectCol = cols;
          for (var i = 0; i < 10; i++) {
            for (var j = 0; j < 10; j++) {
              table.rows[i].cells[j].className = i < rows && j < cols ? _class.selected : '';
            }
          }
        }
      },
      onSelectTable: function onSelectTable(e) {
        var target = e.target;
        var button = domUtils.getParentByClass(target, _class.button);
        var table = domUtils.getParentByClass(target, _class.subMenuTable, true);
        if (table && table.selectRow && table.selectCol) {
          tableCore.insertTable(table.selectCol, table.selectRow);
          _view.setActive(button, false);
        }
      },
      onSelectionChange: function onSelectionChange(data) {
        var bold = ToolsButtonMap[_id.bold];
        var italic = ToolsButtonMap[_id.italic];
        var link = ToolsButtonMap[_id.link];
        var quotes = ToolsButtonMap[_id.quotes];
        var listOl = ToolsButtonMap[_id.listOl];
        var listUl = ToolsButtonMap[_id.listUl];
        var code = ToolsButtonMap[_id.code];
        var image = ToolsButtonMap[_id.image];
        var table = ToolsButtonMap[_id.table];
        var undo = ToolsButtonMap[_id.undo];
        var redo = ToolsButtonMap[_id.redo];
        if (!data) {
          domUtils.addClass([bold, italic, link, quotes, listOl, listUl, code, image, table, undo, redo], _class.disabled);
          return;
        } else if (code && data.isInCode === '1' || table && data.isInTable === '1') {
          domUtils.addClass([bold, italic, link, quotes, listOl, listUl, code, image, table], _class.disabled);
        } else {
          domUtils.removeClass([bold, italic, link, quotes, listOl, listUl, code, image, table], _class.disabled);
        }
        _event.handler.onHistoryUndo(historyUtils.getUndoState());
      }
    }
  };
  var _view = {
    checkBlock: function checkBlock(block) {
      if (!block) {
        return false;
      }
      // 检查 block 是否合法
      return !(domUtils.getParentByClass(block, CONST.CLASS.CODE_CONTAINER, true) || domUtils.getParentByClass(block, CONST.CLASS.TABLE_CONTAINER, true));
    },
    checkDomInList: function checkDomInList(dom, list) {
      for (var i = 0; i < list.length; i++) {
        if (list[i] === dom) {
          return true;
        }
      }
      return false;
    },
    clearImgUploadingTmp: function clearImgUploadingTmp(imgId) {
      var tmpImg = _view.getImgUploadingTmp(imgId);
      if (tmpImg) {
        domUtils.remove(tmpImg);
      }
    },
    createSubMenu: function createSubMenu(button) {
      var subMenu = button.querySelector('.' + _class.subMenu);
      if (subMenu) {
        return subMenu;
      }
      subMenu = env.doc.createElement('div');
      domUtils.addClass(subMenu, _class.subMenu);
      button.appendChild(subMenu);
      return subMenu;
    },
    createTableSubMenu: function createTableSubMenu(subMenu) {
      var table = subMenu.querySelector('.' + _class.subMenuTable);
      var label = void 0,
          tbody = void 0;
      var selectedList = void 0;
      if (table) {
        // 每次都要清理之前已经选中的区域
        selectedList = table.querySelectorAll('.' + _class.selected);
        for (var i = selectedList.length - 1; i >= 0; i--) {
          domUtils.removeClass(selectedList[i], _class.selected);
        }
        var _label = subMenu.querySelector('.' + _class.subMenuLabel);
        _label.innerHTML = '0 x 0';
        return table;
      }
      label = env.doc.createElement('div');
      domUtils.addClass(label, _class.subMenuLabel);
      label.innerHTML = '0 x 0';

      table = env.doc.createElement('table');
      tbody = env.doc.createElement('tbody');
      for (var _i = 1; _i < 11; _i++) {
        var tr = env.doc.createElement('tr');
        for (var j = 1; j < 11; j++) {
          var td = env.doc.createElement('td');
          domUtils.attr(td, {
            'data-index': _i + '-' + j,
            'unselectable': 'on',
            'onmousedown': 'return false;'
          });
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
      domUtils.addClass(table, _class.subMenuTable);
      table.appendChild(tbody);
      subMenu.appendChild(label);
      subMenu.appendChild(table);

      return subMenu;
    },
    createToolbar: function createToolbar() {
      if (env.frame.toolbarContainer.children.length > 0) {
        return;
      }

      var mainToolsDiv = env.doc.createElement('div');
      domUtils.addClass(mainToolsDiv, CONST.CLASS.WIZ_EIDTOR_TOOlBAR_MAIN);
      var sideToolsDiv = env.doc.createElement('div');
      domUtils.addClass(sideToolsDiv, CONST.CLASS.WIZ_EIDTOR_TOOlBAR_SIDE);
      env.frame.toolbarContainer.appendChild(mainToolsDiv);
      env.frame.toolbarContainer.appendChild(sideToolsDiv);

      var mainTools = MainTools;
      var sideTools = SideTools;
      utils.forEach(mainTools, function (tool) {
        mainToolsDiv.appendChild(_view.createToolIcon(tool));
      });
      utils.forEach(sideTools, function (tool) {
        sideToolsDiv.appendChild(_view.createToolIcon(tool));
      });
    },
    createToolIcon: function createToolIcon(tool) {
      var button = env.doc.createElement('div');
      var toolIcon = env.doc.createElement('i');
      var id = void 0;
      if (tool.id === _id.split) {
        domUtils.addClass(toolIcon, _class.toolbarSplit);
      } else {
        if (tool.id === _id.undo || tool.id === _id.redo) {
          domUtils.addClass(toolIcon, _class.disabled);
        }
        domUtils.addClass(toolIcon, _class.icon);

        domUtils.addClass(toolIcon, 'icon-' + tool.icon);
        domUtils.attr(toolIcon, {
          'unselectable': 'on',
          'onmousedown': 'return false;'
        });
        id = tool.id;
        toolIcon.id = id;
        ToolsButtonMap[id] = toolIcon;
      }
      domUtils.addClass(button, _class.button);
      if (tool.id === _id.image) {
        var label = env.doc.createElement('label');
        domUtils.attr(label, { for: uploaderId });
        label.appendChild(toolIcon);
        button.appendChild(label);
      } else {
        button.appendChild(toolIcon);
      }

      return button;
    },
    getImgUploadingTmp: function getImgUploadingTmp(imgId) {
      return env.body.querySelector('#' + _view.getImgUploadingTmpId(imgId));
    },
    getImgUploadingTmpId: function getImgUploadingTmpId(imgId) {
      return _id.tmpImg + '_' + imgId;
    },
    getLineStartList: function getLineStartList() {
      var range = rangeUtils.getRange();
      var result = [],
          blockList = [],
          block = void 0,
          lineStart = void 0;
      if (!range) {
        return result;
      }
      //首先获取 block 块集合
      var startDetail = rangeUtils.getRangeDetail(range.startContainer, range.startOffset);
      var startBlock = domUtils.getPrevBlock(!range.collapsed && startDetail.isEnd ? domUtils.getNextNode(startDetail.container) : startDetail.container);
      var endDetail = void 0,
          endBlock = void 0;
      if (!range.collapsed) {
        endDetail = rangeUtils.getRangeDetail(range.endContainer, range.endOffset);
        endBlock = domUtils.getPrevBlock(endDetail.offset === 0 ? domUtils.getPreviousNode(endDetail.container) : endDetail.container);
        if (_view.checkBlock(endBlock)) {
          blockList.push(endBlock);
        }
        block = domUtils.getPrevBlock(domUtils.getPreviousNode(endBlock));
        while (endBlock !== env.body && endBlock !== startBlock && !!block && block !== env.body) {
          if (_view.checkBlock(block)) {
            blockList.splice(0, 0, block);
          }
          if (block === startBlock) {
            break;
          }
          block = domUtils.getPrevBlock(domUtils.getPreviousNode(block));
        }
      } else if (_view.checkBlock(startBlock)) {
        blockList.push(startBlock);
      }

      // 遍历 block 块集合，获取 每行首元素集合
      for (var i = 0; i < blockList.length; i++) {
        block = blockList[i];
        if (domUtils.isTag(block, 'br')) {
          lineStart = block.nextSibling;
          if (!lineStart && domUtils.isEmptyDom(block.parentNode)) {
            lineStart = block;
          }
        } else {
          lineStart = domUtils.getFirstDeepChild(block);
        }
        if (!_view.checkDomInList(lineStart, result)) {
          result.push(lineStart);
        }
      }
      return result;
    },
    hide: function hide() {
      if (env.frame.toolbarContainer) {
        env.frame.toolbarContainer.style.display = 'none';
      }
    },
    insertImgUploadingTmp: function insertImgUploadingTmp(imgId, imgData) {
      var range = rangeUtils.getRange();
      if (!range) {
        if (!rangeUtils.caretRestore()) {
          env.body.focus();
        }
        range = rangeUtils.getRange();
      }
      if (!range) {
        return;
      }
      range.deleteContents();
      _view.clearImgUploadingTmp(imgId);

      // range.insertNode 连续多次使用，先添加的实际上会放在后面！！
      var emptyLine = env.doc.createElement('br');
      // emptyLine.appendChild(env.doc.createElement('br'));
      range.insertNode(emptyLine);

      var isMarkdownEditor = env.options.editor.type === 'markdown';
      var tmpImg = env.doc.createElement(CONST.TAG.TMP_TAG);
      if (isMarkdownEditor) {
        tmpImg.innerHTML = imgData.markdownSrc.replace('uploading', '<span class="progress_txt">0%</span>)');
      } else {
        tmpImg.innerHTML = '<div style="border:1px solid #BDBDBD;color:#BDBDBD;width:200px;text-align:center;">' + '<div class="' + _class.imgName + '" style="padding:8px;font-size:14px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;">' + imgData.name + '</div>' + '<div class="progress_txt" style="padding-bottom:8px;font-size:12px;">0%</div>' + '<div class="progress_line" style="width:0%;height:2px;background:#66BB6A;"></div>' + '</div>';
      }
      tmpImg.style.color = '#BDBDBD';
      tmpImg.id = _view.getImgUploadingTmpId(imgId);
      domUtils.setContenteditable(tmpImg, false);
      range.insertNode(tmpImg);

      range.insertNode(env.doc.createElement('br'));

      var emptyLineIndex = domUtils.getIndex(emptyLine);
      rangeUtils.setRange(emptyLine.parentNode, emptyLineIndex + 1);
    },
    insertListOl: function insertListOl() {
      _view.insertTextAtLineStart('1.' + String.fromCharCode(160), _view.getLineStartList());
    },
    insertListUl: function insertListUl() {
      _view.insertTextAtLineStart('*' + String.fromCharCode(160), _view.getLineStartList());
    },
    insertQuotes: function insertQuotes() {
      _view.insertTextAtLineStart('>' + String.fromCharCode(160), _view.getLineStartList());
    },
    insertText: function insertText(text) {
      var range = rangeUtils.getRange();
      var textNode = void 0,
          div = void 0;
      if (text === '\n') {
        textNode = env.doc.createElement('div');
        textNode.appendChild(env.doc.createElement('br'));
      } else {
        textNode = env.doc.createTextNode(text);
      }

      if (!range) {
        if (textNode.nodeType === 3) {
          div = env.doc.createElement('div');
          div.appendChild(textNode);
          env.body.appendChild(div);
        } else {
          env.body.appendChild(textNode);
        }
      } else {
        range.deleteContents();
        rangeUtils.insertNode(textNode);
        rangeUtils.setRange(textNode, domUtils.getEndOffset(textNode));
      }
      return textNode;
    },
    insertTextAtLineStart: function insertTextAtLineStart(text, lineStartList) {
      var dom = void 0,
          range = void 0;
      if (lineStartList.length === 0) {
        range = rangeUtils.getRange();
        if (!range) {
          dom = _view.insertText(text);
          rangeUtils.setRange(dom, dom.nodeValue.length);
        }
        return;
      }

      for (var i = 0; i < lineStartList.length; i++) {
        var lineStart = lineStartList[i];
        dom = env.doc.createTextNode(text);
        if (domUtils.isTag(lineStart, 'br') && domUtils.isEmptyDom(lineStart.parentNode)) {
          domUtils.before(dom, lineStart);
          domUtils.remove(lineStart);
        } else {
          domUtils.before(dom, lineStart);
        }
        // 最后一个 dom 需要修正 光标位置
        if (i === lineStartList.length - 1) {
          dom = domUtils.getBlockParent(dom, true);
          rangeUtils.setRange(dom, domUtils.getEndOffset(dom));
        }
      }
    },
    isActive: function isActive(button) {
      return domUtils.hasClass(button, _class.active);
    },
    preview: function preview() {
      var previewContainer = env.body.querySelector('.' + CONST.CLASS.WIZ_EIDTOR_PREVIEW_CONTAINER);
      if (!previewContainer) {
        previewContainer = env.doc.createElement(CONST.TAG.TMP_TAG);
        domUtils.addClass(previewContainer, CONST.CLASS.WIZ_EIDTOR_PREVIEW_CONTAINER);
        domUtils.addClass(previewContainer, CONST.CLASS.READONLY);
        env.body.appendChild(previewContainer);
      } else {
        if (codeUtils) {
          codeUtils.clearCodeMirror(previewContainer.querySelectorAll('.' + CONST.CLASS.CODE_CONTAINER));
        }
        previewContainer.innerHTML = '';
      }

      tableMenu.hide();

      if (env.isShowPreview) {
        env.isShowPreview = false;
        domUtils.setContenteditable(env.body, true);
        domUtils.removeClass(previewContainer, CONST.CLASS.EDITOR_PREVIEW_SHOW);
        env.event.call(CONST.EVENT.ON_SELECTION_CHANGE);
        return;
      }

      env.isShowPreview = true;
      _event.handler.onSelectionChange();
      domUtils.setContenteditable(env.body, false);
      domUtils.addClass(previewContainer, CONST.CLASS.EDITOR_PREVIEW_SHOW);

      previewContainer.innerHTML = '';
      var tmp = env.doc.createElement('div');
      tmp.innerHTML = env.body.innerHTML;
      var wizDomList = tmp.querySelectorAll(CONST.TAG.TMP_TAG);
      for (var i = wizDomList.length - 1; i >= 0; i--) {
        domUtils.remove(wizDomList[i]);
      }
      while (tmp.firstChild) {
        previewContainer.appendChild(tmp.firstChild);
      }

      markdownRender.do({ container: previewContainer }, function () {});
    },
    setActive: function setActive(button, isActive) {
      if (!isActive) {
        domUtils.removeClass(button, _class.active);
        if (activeButton === button) {
          _event.unbindSubMenu();
          activeButton = null;
        }
        return;
      }

      if (activeButton === button) {
        return;
      }
      domUtils.removeClass(activeButton, _class.active);
      activeButton = button;
      domUtils.addClass(button, _class.active);
      _event.bindSubMenu();
    },
    show: function show() {
      _view.createToolbar();
      env.frame.toolbarContainer.style.display = 'flex';
    }
  };

  this.off = function () {
    env.isShowPreview = false;
    _event.unbind();
    _view.hide();
    // 关闭的时候不再删除 style（因为同一个页面会有多个 编辑器）
    // frameViewStyle.removeToolbarStyle();
    // frameViewStyle.removePreviewStyle();
  };
  this.on = function () {
    if (!env.readonly) {
      frameViewStyle.insertToolbarStyle();
      frameViewStyle.insertPreviewStyle();
    }

    if (!markdownRender) {
      markdownRender = new MarkdownRender({
        win: env.win,
        doc: env.doc,
        callback: function callback() {}
      });
      markdownRender.initCore(core);
    }

    _view.show();
    _event.bind();
  };
  this.setImgUploaderId = function (_uploaderId) {
    uploaderId = _uploaderId;
    var imageIcon = void 0;
    if (!env.readonly && env.frame.toolbarContainer) {
      imageIcon = env.frame.toolbarContainer.querySelector('#' + _id.image);
      if (!imageIcon) {
        return;
      }
      domUtils.attr(imageIcon.parentNode, { for: uploaderId });
    }
  };
  this.onImgUploadBegin = function (imgId, imgData) {
    _view.insertImgUploadingTmp(imgId, imgData);
  };
  this.onImgUploadComplete = function (imgId, imgData) {
    var tmpImg = _view.getImgUploadingTmp(imgId);
    if (!tmpImg) {
      return;
    }
    var img = void 0;
    if (env.options.editor.type === CONST.NOTE_EDITOR_TYPE.MARKDOWN) {
      img = env.doc.createTextNode(imgData.markdownSrc);
    } else {
      img = imgUtils.makeDomByPath(imgData.url);
    }

    domUtils.before(img, tmpImg);
    domUtils.remove(tmpImg);
  };
  this.onImgUploadError = function (imgId) {
    _view.clearImgUploadingTmp(imgId);
  };
  this.onImgUploadProgress = function (imgId, imgData) {
    var tmpImg = _view.getImgUploadingTmp(imgId);
    if (!tmpImg) {
      return;
    }

    var progressTxt = tmpImg.querySelector('.progress_txt');
    var progressLine = tmpImg.querySelector('.progress_line');
    if (progressTxt) {
      progressTxt.firstChild.nodeValue = imgData.progress + '%';
    }
    if (progressLine) {
      progressLine.style.width = imgData.progress + '%';
    }
  };
};

module.exports = ToolbarMarkdown;

},{"../../common/MarkdownRender":347,"../../config/const":388,"../../libs/utils":400}],373:[function(require,module,exports){
'use strict';

/**
 * 点击 Img 操作
 */
var CONST = require('../../config/const');
var utils = require('../../libs/utils');

var ImgClick = function ImgClick() {
  var core = null;
  var env = null;
  var domUtils = null;
  var imgUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
    imgUtils = core.require.imgUtils;
  };

  var imgCheck = function imgCheck(img) {
    var imgClassExp = new RegExp('(' + CONST.CLASS.IMG_NOT_DRAG + ')|(' + CONST.CLASS.IMG_ATTACHMENT + ')', 'i');
    var result = !!(img && domUtils.isTag(img, 'img') && !imgClassExp.test(img.className) && img.src);
    if (!result) {
      return result;
    }

    var p = void 0;
    if (env.readonly) {
      // 阅读模式
      // 对于 超链接内的 img 不阻止点击事件，因为响应 超链接 更重要
      p = domUtils.getParentByFilter(img, function (node) {
        return node && domUtils.isTag(node, 'a') && /^(http|https|wiz|wiznote|wiznotecmd):/.test(node.getAttribute('href'));
      }, true);
      return !p;
    } else {
      // 编辑模式
      // 对于 添加附件 生成的 img 不允许编辑
      p = domUtils.getParentByFilter(img, function (node) {
        return node && domUtils.isTag(node, 'a') && /^(wiz|wiznote|wiznotecmd):open_attachment/.test(node.getAttribute('href'));
      }, true);
      return !p;
    }
  };
  var clickImgForRead = function clickImgForRead(e) {
    var target = e.target;
    if (!imgCheck(target)) {
      return;
    }

    env.client.sendCmdToWizClient(CONST.CLIENT_EVENT.WizReaderClickImg, {
      src: target.src,
      imgList: env.client.type.isIOS ? null : imgUtils.getAll(true)
    });
    utils.stopEvent(e);
    return false;
  };
  var clickImgForEdit = function clickImgForEdit(e) {
    var target = e.target;
    if (!imgCheck(target)) {
      return;
    }

    // 删除之前遗漏的 img 状态
    var imgList = env.body.querySelectorAll('img[' + CONST.ATTR.IMG_EDITING + ']'),
        attr = {};
    attr[CONST.ATTR.IMG_EDITING] = '';
    for (var i = imgList.length - 1; i >= 0; i--) {
      domUtils.attr(imgList[i], attr);
    }

    attr[CONST.ATTR.IMG_EDITING] = 1;
    domUtils.attr(target, attr);

    env.client.sendCmdToWizClient(CONST.CLIENT_EVENT.WizEditorClickImg, {
      src: target.src
    });
  };
  var init = function init() {};

  var _event = {
    bind: function bind() {
      _event.unbind();
      if (env.client.type.isIOS || env.client.type.isAndroid) {
        env.event.add(CONST.EVENT.ON_CLICK, _event.handler.onClick);
      } else if (env.readonly && (env.client.type.isWin || env.client.type.isMac || env.client.type.isLinux)) {
        env.event.add(CONST.EVENT.ON_DBLCLICK, _event.handler.onClick);
      }
    },
    unbind: function unbind() {
      env.event.remove(CONST.EVENT.ON_CLICK, _event.handler.onClick);
      env.event.remove(CONST.EVENT.ON_DBLCLICK, _event.handler.onClick);
    },
    handler: {
      onClick: function onClick(e) {
        if (env.readonly) {
          clickImgForRead(e);
        } else if (env.client.type.isAndroid) {
          clickImgForEdit(e);
        }
      }
    }
  };

  this.init = init;
  this.bind = _event.bind;
  this.unbind = _event.unbind;
};

module.exports = ImgClick;

},{"../../config/const":388,"../../libs/utils":400}],374:[function(require,module,exports){
'use strict';

/**
 * img 组件注册
 */
var ImgCore = function ImgCore() {
  var core = null;
  var env = null;
  var domUtils = null;
  var imgClick = null;
  var imgResize = null;
  var svgClick = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
    imgClick = core.require.imgClick;
    imgResize = core.require.imgResize;
    svgClick = core.require.svgClick;
  };

  this.on = function () {
    if (!env.readonly && !env.client.type.isPhone && !env.client.type.isPad) {
      imgResize.init();
      imgResize.bind();
    }

    imgClick.init();
    imgClick.bind();
    svgClick.init();
    svgClick.bind();
  };

  this.off = function () {
    imgResize.unbind();
    imgClick.unbind();
    svgClick.unbind();
  };

  this.setImgFullPath = function () {
    // 为了保证 客户端不同笔记之间复制图片能够正常获取 路径
    var imgList = env.body.querySelectorAll('img');
    var indexFilesPathReg = new RegExp('^(\\.\\/)?' + env.indexFilesPath.escapeRegex() + '\\/', 'i');
    // console.log(indexFilesPathReg);
    for (var i = imgList.length - 1; i >= 0; i--) {
      var img = imgList[i];
      var src = img.getAttribute('src');
      // console.log(src);
      if (indexFilesPathReg.test(src)) {
        domUtils.attr(img, { src: src.replace(indexFilesPathReg, env.indexFilesFullPath) });
      }
    }
  };
};

module.exports = ImgCore;

},{}],375:[function(require,module,exports){
'use strict';

/**
 * img Resize 工具
 */

var CONST = require('../../config/const');
var utils = require('../../libs/utils');

var WIZ_STYLE = 'wiz_style';
// const handleSuffix = ['lt', 'tm', 'rt', 'rm', 'rb', 'bm', 'lb', 'lm'];
// 目前样式设置 img 只能等比例缩放，所以取消 中间的操作模块
var handleSuffix = ['lt', 'rt', 'rb', 'lb'];

var ImgResize = function ImgResize() {
  var core = null;
  var env = null;
  var domUtils = null;
  var rangeUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
    rangeUtils = core.require.rangeUtils;
  };

  var resizingHandle = '';

  var startOffsetX = void 0;
  var startOffsetY = void 0;
  var lastMousex = void 0;
  var lastMousey = void 0;
  var oppCornerX = void 0;
  var oppCornerY = void 0;

  // patch Window Client WebView bug
  // 修正 Chrome 内核 bug —— 图片未选中时，无法拖拽
  var dragImgStart = false;
  var dragImg = null;

  var curImg = void 0;
  var cursorOri = void 0;
  var cursor = void 0;

  var canDragResize = function canDragResize(img) {
    if (!img) return false;
    //
    var className = img.getAttribute('class');
    if (className && -1 !== className.indexOf(CONST.CLASS.IMG_NOT_DRAG)) return false;
    //
    return true;
  };
  var clearHandles = function clearHandles() {
    removeImgAttributes();
    removeHandles();
    curImg = null;
    env.body.style.cursor = cursorOri;
  };
  var createHandles = function createHandles() {
    var container = getHandleContainer();
    if (container) {
      return container;
    }
    container = env.doc.createElement(CONST.TAG.TMP_TAG);
    domUtils.addClass(container, CONST.CLASS.IMG_RESIZE_CONTAINER);
    domUtils.setContenteditable(container, false);
    var attr = {};
    attr[WIZ_STYLE] = 'unsave';
    domUtils.attr(container, attr);

    for (var i = 0; i < handleSuffix.length; i++) {
      var handle = env.doc.createElement('div');
      domUtils.addClass(handle, CONST.CLASS.IMG_RESIZE_HANDLE);
      domUtils.addClass(handle, handleSuffix[i]);
      domUtils.attr(handle, {
        'data-type': handleSuffix[i]
      });
      container.appendChild(handle);
    }
    env.body.appendChild(container);
    return container;
  };
  var getHandleContainer = function getHandleContainer() {
    var container = env.body.querySelector('.' + CONST.CLASS.IMG_RESIZE_CONTAINER);
    if (!container || container.length < 1) {
      return null;
    }
    return container;
  };
  var init = function init() {
    cursorOri = env.body.style.cursor || '';
    // TODO 临时为 pc端处理，pc端整合后， 直接删除
    env.win.WizImgResizeOnGetHTML = function () {};
  };
  var initImage = function initImage(img) {
    if (!img) {
      return;
    }
    removeImgAttributes();
    domUtils.addClass(img, CONST.CLASS.IMG_RESIZE_ACTIVE);
    img.attributes[CONST.ATTR.IMG_RATE] = img.width / img.height;
    curImg = img;
    var imgIndex = domUtils.getIndex(img);
    rangeUtils.setRange(img.parentNode, imgIndex, img.parentNode, imgIndex + 1);
  };
  var initImageDragResize = function initImageDragResize(img) {
    if (!img || !img.tagName || img.tagName.toLowerCase() !== 'img') return;
    if (!canDragResize(img)) return;
    //
    var container = createHandles();
    if (!container) {
      return;
    }
    resetHandlesSize(img);
    initImage(img);

    _event.bindContainer(container);
  };
  var removeHandles = function removeHandles() {
    var container = getHandleContainer();
    if (!container) {
      return;
    }
    _event.unbindContainer(container);
    domUtils.remove(container);
  };
  var removeImgAttributes = function removeImgAttributes() {
    var imgList = env.body.querySelectorAll('.' + CONST.CLASS.IMG_RESIZE_ACTIVE);
    if (!imgList || imgList.length === 0) {
      return;
    }
    for (var i = imgList.length - 1; i >= 0; i--) {
      domUtils.removeClass(imgList[i], CONST.CLASS.IMG_RESIZE_ACTIVE);
    }
  };
  var resetHandlesSize = function resetHandlesSize(img) {
    if (!img) {
      return;
    }
    var container = getHandleContainer();
    if (!container) {
      return;
    }
    var handles = container.querySelectorAll('.' + CONST.CLASS.IMG_RESIZE_HANDLE);

    var imgOptions = {
      offset: domUtils.getOffset(img),
      width: img.width,
      height: img.height
    };
    var containerOffset = domUtils.getOffset(env.body);
    for (var i = 0; i < handles.length; i++) {
      var handle = handles[i];
      setHandleSize(handle, imgOptions, containerOffset);
      handle.style.visibility = 'inherit';
    }
  };
  var scaleImgSize = function scaleImgSize(rate, widthDraged, heightDraged, img) {
    if (!img) {
      return;
    }

    var widthSized = heightDraged * rate;
    var heightSized = widthDraged / rate;

    if (widthSized < widthDraged) {
      widthSized = widthDraged;
    } else {
      heightSized = heightDraged;
    }

    img.width = widthSized;
    img.height = heightSized;
  };
  var setHandleSize = function setHandleSize(handle, imgOptions, containerOffset) {
    if (!imgOptions || !handle) {
      return;
    }
    var offset = imgOptions.offset;
    var x = offset.left - containerOffset.left,
        y = offset.top - containerOffset.top,
        width = imgOptions.width,
        height = imgOptions.height;

    var handleName = handle.getAttribute('data-type');
    var left = 0,
        top = 0;
    switch (handleName) {
      case 'lt':
        left = x - 7;
        top = y - 7;
        break;
      case 'tm':
        left = x + (width - 7) / 2;
        top = y - 7;
        break;
      case 'rt':
        left = x + width;
        top = y - 7;
        break;
      case 'rm':
        left = x + width;
        top = y + (height - 7) / 2;
        break;
      case 'rb':
        left = x + width;
        top = y + height;
        break;
      case 'bm':
        left = x + (width - 7) / 2;
        top = y + height;
        break;
      case 'lb':
        left = x - 7;
        top = y + height;
        break;
      case 'lm':
        left = x - 7;
        top = y + (height - 7) / 2;
        break;
    }
    domUtils.css(handle, {
      left: left + 'px',
      top: top + 'px'
    });
  };
  var showHandles = function showHandles(show) {
    var container = getHandleContainer();
    if (!container) {
      return;
    }
    container.style.display = show ? 'block' : 'none';
    if (!show) {
      clearHandles();
    }
  };

  var _event = {
    bind: function bind() {
      _event.unbind();
      env.event.add(CONST.EVENT.BEFORE_GET_DOCHTML, _event.handler.beforeGetDocHtml);
      env.event.add(CONST.EVENT.ON_CUT, _event.handler.onCut);
      env.event.add(CONST.EVENT.ON_KEY_DOWN, _event.handler.onKeyDown);
      env.event.add(CONST.EVENT.ON_MOUSE_DOWN, _event.handler.onMouseDown);
      env.event.add(CONST.EVENT.ON_MOUSE_MOVE, _event.handler.onMouseMove);
      env.event.add(CONST.EVENT.ON_MOUSE_UP, _event.handler.onMouseUp);
    },
    bindContainer: function bindContainer(container) {
      _event.unbindContainer(container);
      container.addEventListener('mousedown', _event.handler.onContainerMouseDown);
    },
    unbind: function unbind() {
      env.event.remove(CONST.EVENT.BEFORE_GET_DOCHTML, _event.handler.beforeGetDocHtml);
      env.event.remove(CONST.EVENT.ON_CUT, _event.handler.onCut);
      env.event.remove(CONST.EVENT.ON_KEY_DOWN, _event.handler.onKeyDown);
      env.event.remove(CONST.EVENT.ON_MOUSE_DOWN, _event.handler.onMouseDown);
      env.event.remove(CONST.EVENT.ON_MOUSE_MOVE, _event.handler.onMouseMove);
      env.event.remove(CONST.EVENT.ON_MOUSE_UP, _event.handler.onMouseUp);
    },
    unbindContainer: function unbindContainer(container) {
      container.removeEventListener('mousedown', _event.handler.onContainerMouseDown);
    },
    handler: {
      beforeGetDocHtml: function beforeGetDocHtml() {
        clearHandles();
      },
      onContainerMouseDown: function onContainerMouseDown(e) {
        var elm = e.target || e.srcElement;
        resizingHandle = elm.getAttribute('data-type');
        var img = env.body.querySelector('.' + CONST.CLASS.IMG_RESIZE_ACTIVE);
        var mousex = void 0,
            mousey = void 0,
            offset = void 0;
        if (!img) {
          return;
        }

        mousex = e.pageX;
        mousey = e.pageY;
        offset = domUtils.getOffset(img);
        //
        switch (resizingHandle) {
          case 'lt':
            startOffsetX = offset.left - mousex;
            startOffsetY = offset.top - mousey;
            //
            oppCornerX = offset.left + img.width;
            oppCornerY = offset.top + img.height;
            //
            cursor = 'nw-resize';
            break;
          case 'tm':
            startOffsetX = undefined;
            startOffsetY = offset.top - mousey;
            //
            cursor = 'n-resize';
            break;
          case 'rt':
            startOffsetX = mousex - img.width - offset.left;
            startOffsetY = offset.top - mousey;
            //
            oppCornerX = offset.left;
            oppCornerY = offset.top + img.height;
            //
            cursor = 'ne-resize';
            break;
          case 'rm':
            startOffsetX = mousex - img.width - offset.left;
            startOffsetY = undefined;
            //
            cursor = 'e-resize';
            break;
          case 'rb':
            startOffsetX = mousex - img.width - offset.left;
            startOffsetY = mousey - img.height - offset.top;
            //
            cursor = 'se-resize';
            break;
          case 'bm':
            startOffsetX = undefined;
            startOffsetY = mousey - img.height - offset.top;
            //
            oppCornerX = offset.left / 2;
            oppCornerY = offset.top;
            //
            cursor = 's-resize';
            break;
          case 'lb':
            startOffsetX = offset.left - mousex;
            startOffsetY = mousey - img.height - offset.top;
            //
            oppCornerX = offset.left + img.width;
            oppCornerY = offset.top;
            //
            cursor = 'sw-resize';
            break;
          case 'lm':
            startOffsetX = offset.left - mousex;
            startOffsetY = undefined;
            //
            cursor = 'w-resize';
            break;
        }
        utils.stopEvent(e);
      },
      onCut: function onCut(e) {
        showHandles(false);
      },
      onDrop: function onDrop(e) {
        env.doc.removeEventListener('drop', _event.handler.onDrop);
        if (curImg === dragImg) {
          clearHandles();
        }
        dragImgStart = false;
        dragImg = null;
      },
      onKeyDown: function onKeyDown(e) {
        var keyCode = e.keyCode || e.which;
        var start = void 0,
            startOffset = void 0;
        if (curImg && (keyCode === 8 || keyCode === 46)) {
          start = curImg.parentNode;
          if (start) {
            startOffset = domUtils.getIndex(curImg);
            rangeUtils.setRange(start, startOffset, start, startOffset + 1);
          }
        }
        showHandles(false);
      },
      onMouseDown: function onMouseDown(e) {
        var elm = e.target || e.srcElement;
        if (domUtils.isTag(elm, 'img')) {
          dragImgStart = true;
          dragImg = elm;
          env.doc.addEventListener('drop', _event.handler.onDrop);
        } else {
          dragImgStart = false;
          dragImg = null;
        }
        if (e.target === curImg) {
          return;
        }
        showHandles(false);
        removeImgAttributes();
      },
      onMouseMove: function onMouseMove(e) {
        var offset = void 0,
            mousex = void 0,
            mousey = void 0;
        var index = void 0,
            img = void 0;
        var elm = e.target || e.srcElement;

        if (elm && elm === dragImg) {
          index = domUtils.getIndex(e.target);
          img = elm;
          rangeUtils.setRange(img.parentNode, index, img.parentNode, index + 1);
        }

        img = env.body.querySelector('.' + CONST.CLASS.IMG_RESIZE_ACTIVE);
        if (!img) {
          return;
        }
        offset = domUtils.getOffset(img);
        //
        if (resizingHandle) {
          //
          mousex = e.pageX;
          mousey = e.pageY;
          //
          env.body.style.cursor = cursor;
          // console.log('mousex: ' + mousex + ', mousey: ' + mousey);
          // console.log('lastMousex: ' + lastMousex + ', lastMousey: ' + lastMousey);
          var rate = void 0;
          var widthDraged = void 0;
          var heightDraged = void 0;
          var widthSized = void 0;
          var heightSized = void 0;
          //
          if (!lastMousex || !lastMousey) {
            lastMousex = mousex;
            lastMousey = mousey;
          }
          //
          switch (resizingHandle) {
            case 'tm':
              img.width = img.width;
              if (mousey < offset.top) {
                img.height += lastMousey - mousey;
              } else {
                heightSized = img.height - (mousey - lastMousey) - startOffsetY;
                img.height = heightSized < 0 ? 0 : heightSized;
              }
              break;
            case 'rm':
              widthSized = mousex - offset.left - startOffsetX;
              img.width = widthSized < 0 ? 0 : widthSized;
              img.height = img.height;
              img.attributes[CONST.ATTR.IMG_RATE] = img.width / img.height;
              break;
            case 'bm':
              img.width = img.width;
              img.height = heightSized < 0 ? 0 : heightSized;
              img.attributes[CONST.ATTR.IMG_RATE] = img.width / img.height;
              break;
            case 'lm':
              img.height = img.height;
              if (mousex < offset.left) {
                img.width += lastMousex - mousex;
              } else {
                widthSized = img.width - (mousex - lastMousex) - startOffsetX;
                img.width = widthSized < 0 ? 0 : widthSized;
              }
              break;
            case 'lt':
              rate = Number(img.attributes[CONST.ATTR.IMG_RATE]);
              //
              widthDraged = oppCornerX - mousex;
              heightDraged = oppCornerY - mousey;
              //
              widthDraged -= startOffsetX;
              heightDraged -= startOffsetY;
              //
              widthDraged = widthDraged < 0 ? 0 : widthDraged;
              heightDraged = heightDraged < 0 ? 0 : heightDraged;
              //
              scaleImgSize(rate, widthDraged, heightDraged, img);
              break;
            case 'rt':
              rate = Number(img.attributes[CONST.ATTR.IMG_RATE]);
              //
              widthDraged = mousex - oppCornerX;
              heightDraged = oppCornerY - mousey;
              //
              widthDraged -= startOffsetX;
              heightDraged -= startOffsetY;
              //
              widthDraged = widthDraged < 0 ? 0 : widthDraged;
              heightDraged = heightDraged < 0 ? 0 : heightDraged;
              //
              scaleImgSize(rate, widthDraged, heightDraged, img);
              break;
            case 'lb':
              rate = Number(img.attributes[CONST.ATTR.IMG_RATE]);
              //
              widthDraged = oppCornerX - mousex;
              heightDraged = mousey - oppCornerY;
              //
              widthDraged -= startOffsetX;
              heightDraged -= startOffsetY;
              //
              widthDraged = widthDraged < 0 ? 0 : widthDraged;
              heightDraged = heightDraged < 0 ? 0 : heightDraged;
              //
              scaleImgSize(rate, widthDraged, heightDraged, img);
              break;
            case 'rb':
              rate = Number(img.attributes[CONST.ATTR.IMG_RATE]);
              // console.log('mousex: ' + mousex + 'mousey: ' + mousey);
              widthDraged = mousex - offset.left;
              heightDraged = mousey - offset.top;
              //
              widthDraged -= startOffsetX;
              heightDraged -= startOffsetY;
              //
              widthDraged = widthDraged < 0 ? 0 : widthDraged;
              heightDraged = heightDraged < 0 ? 0 : heightDraged;
              //
              scaleImgSize(rate, widthDraged, heightDraged, img);
              //
              // console.log('rate: ' + rate + ', ' + 'widthDraged: ' + widthDraged + ', ' + 'heightDraged: ' + heightDraged + ', ' + 'widthSized: ' +
              // 	widthSized + ', ' + 'heightSized: ' + heightSized);
              break;
          }
          //
          if (img.style.cssText) {
            var cssText = img.style.cssText;
            cssText = cssText.replace(/width:\s*\d+.?\d+px;?/ig, 'width: ' + img.width + 'px').replace(/height:\s*\d+.?\d+px;?/ig, 'height: ' + img.height + 'px');
            //
            img.style.cssText = cssText;
          }
          //
          lastMousex = mousex;
          lastMousey = mousey;

          resetHandlesSize(img);
          env.event.call(CONST.EVENT.UPDATE_RENDER, null);
        }
      },
      onMouseUp: function onMouseUp(e) {
        env.doc.removeEventListener('drop', _event.handler.onDrop);
        dragImgStart = false;
        dragImg = null;

        var elm = e.target || e.srcElement;

        if (domUtils.isTag(elm, 'img')) {
          initImageDragResize(elm);
        }
        //
        resizingHandle = '';
        //
        lastMousex = undefined;
        lastMousey = undefined;
        //
        oppCornerX = undefined;
        oppCornerY = undefined;
        //
        startOffsetX = undefined;
        startOffsetY = undefined;
        //
        env.body.style.cursor = cursorOri;
      }
    }
  };

  this.init = init;
  this.bind = _event.bind;
  this.unbind = _event.unbind;
};

module.exports = ImgResize;

},{"../../config/const":388,"../../libs/utils":400}],376:[function(require,module,exports){
'use strict';

/**
 * img 操作基本方法集合
 */
var CONST = require('../../config/const');

var ImgUtils = function ImgUtils() {
  var _this = this;

  var core = null;
  var env = null;
  var domUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
  };

  var imgFilter = function imgFilter(img, onlyLocal) {
    if (!img || img.className && img.className.indexOf('wiz-todo') > -1) {
      //checklist 的图片不进行获取
      return false;
    }
    var path = img.src;
    if (!path) {
      return false;
    }
    var rLocal = /^(http|https|ftp):/,
        rNoBase64 = /^(data):/,
        result = void 0;

    result = !rNoBase64.test(path);
    if (!result || !onlyLocal) {
      return result;
    }
    return !rLocal.test(path);
  };

  this.getAll = function (onlyLocal) {
    var images = env.doc.images,
        imageSrcs = [],
        tmp = {};
    for (var img in images) {
      if (images.hasOwnProperty(img)) {
        //有特殊字符的文件名， 得到src 时是被转义后的名字，所以必须 decode 处理
        var src = decodeURIComponent(images[img].src);
        if (imgFilter(images[img], onlyLocal) && !tmp[src]) {
          imageSrcs.push(src);
          tmp[src] = true;
        }
      }
    }
    return imageSrcs;
  };
  this.getImageData = function (img) {
    var size = _this.getImageSize(img.src);
    // Create an empty canvas element
    var canvas = env.doc.createElement("canvas");
    canvas.width = size.width;
    canvas.height = size.height;

    // Copy the image contents to the canvas
    var ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0);

    // Get the data-URL formatted image
    // Firefox supports PNG and JPEG. You could check img.src to
    // guess the original format, but be aware the using "image/jpg"
    // will re-encode the image.
    var dataURL = canvas.toDataURL("image/png");

    return dataURL.replace(/^data:image\/(png|jpg);base64,/, "");
  };
  this.getImageSize = function (imgSrc) {
    var newImg = new Image();
    newImg.src = imgSrc;
    var height = newImg.height;
    var width = newImg.width;
    return { width: width, height: height };
  };
  this.makeAttachmentDom = function (guid, imgPath) {
    var result = [],
        main = void 0,
        a = void 0,
        img = void 0;
    main = env.doc.createElement("div");
    main.style.margin = '10px auto';
    a = env.doc.createElement("a");
    a.href = 'wiz://open_attachment?guid=' + guid;
    img = env.doc.createElement("img");
    img.src = imgPath;
    img.style.verticalAlign = 'bottom';
    img.style.maxWidth = '280px';
    domUtils.addClass(img, CONST.CLASS.IMG_ATTACHMENT);
    a.appendChild(img);
    main.appendChild(a);
    result.push(main);
    main = env.doc.createElement("div");
    main.appendChild(env.doc.createElement("br"));
    result.push(main);

    return result;
  };
  this.makeDomByPath = function (imgPath) {
    var result = [],
        paths = [];
    if (imgPath.indexOf('*')) {
      paths = imgPath.split("*");
    } else {
      paths.push(imgPath);
    }

    for (var i = 0, j = paths.length; i < j; i++) {
      var main = env.doc.createElement("div");
      result.push(main);
      var img = env.doc.createElement("img");
      img.src = paths[i];
      img.style.verticalAlign = 'bottom';
      img.style.maxWidth = '100%';
      main.insertBefore(img, null);

      main = env.doc.createElement("div");
      main.insertBefore(env.doc.createElement("br"), null);
      result.push(main);
    }
    // main = env.doc.createElement("div");
    // main.insertBefore(env.doc.createElement("br"), null);
    // result.push(main);
    return result;
  };
  this.remove = function (selector) {
    var imgList = env.body.querySelectorAll(selector);
    for (var i = imgList.length - 1; i >= 0; i--) {
      var img = imgList[i];
      img.parentElement.removeChild(img);
    }
  };
  this.replaceSrc = function (selector, targetSrc) {
    var imgList = env.body.querySelectorAll(selector),
        attr = {};
    attr[CONST.ATTR.IMG_EDITING] = '';
    for (var i = imgList.length - 1; i >= 0; i--) {
      var img = imgList[i];
      img.src = targetSrc;
      domUtils.attr(img, attr);
    }
  };
};

module.exports = ImgUtils;

},{"../../config/const":388}],377:[function(require,module,exports){
'use strict';

/**
 * 点击 Img 操作
 */
var CONST = require('../../config/const');
var utils = require('../../libs/utils');

var SvgClick = function SvgClick() {
  var core = null;
  var env = null;
  var domUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
  };

  var svgCheck = function svgCheck(target) {
    var svgClassExp = new RegExp('(' + CONST.CLASS.SVG_BASE + ')', 'i');
    return !!(target && domUtils.isTag(target, 'svg') && svgClassExp.test(target.getAttribute('class')));
  };
  var clickSvgForEdit = function clickSvgForEdit(e) {
    var target = e.target;
    if (!svgCheck(target)) {
      return;
    }

    var svgList = env.body.querySelectorAll('svg.' + CONST.CLASS.SVG_BASE);
    var resultData = {
      index: 0,
      svgList: []
    };
    for (var i = 0; i < svgList.length; i++) {
      var svg = svgList[i];
      resultData.svgList.push(svg.outerHTML);
      if (target === svg) {
        resultData.index = i;
      }
    }

    env.client.sendCmdToWizClient(CONST.CLIENT_EVENT.WizEditorClickSvg, resultData);
    utils.stopEvent(e);
  };
  var init = function init() {};

  var _event = {
    bind: function bind() {
      _event.unbind();
      if (env.readonly) {
        return;
      }
      env.event.add(CONST.EVENT.ON_CLICK, _event.handler.onClick);
    },
    unbind: function unbind() {
      env.event.remove(CONST.EVENT.ON_CLICK, _event.handler.onClick);
    },
    handler: {
      onClick: function onClick(e) {
        if (!env.readonly) {
          clickSvgForEdit(e);
        }
      }
    }
  };

  this.init = init;
  this.bind = _event.bind;
  this.unbind = _event.unbind;
};

module.exports = SvgClick;

},{"../../config/const":388,"../../libs/utils":400}],378:[function(require,module,exports){
'use strict';

/**
 * 阅读器 基础工具包
 */
var CONST = require('../../config/const');
var domPatch = require('../../libs/domPatch');
var dependLoader = require('../../libs/dependLoader');

var Reader = function Reader() {
  var _this = this;

  var core = null;
  var env = null;
  var blockCore = null;
  var codeCore = null;
  var contentCore = null;
  var domUtils = null;
  var frameViewCore = null;
  var highlightUtils = null;
  var imgCore = null;
  var readerEvent = null;
  var selectPlugin = null;
  var tableCore = null;
  var todoCore = null;
  var wizStyle = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    blockCore = core.require.blockCore;
    codeCore = core.require.codeCore;
    contentCore = core.require.contentCore;
    domUtils = core.require.domUtils;
    frameViewCore = core.require.frameViewCore;
    highlightUtils = core.require.highlightUtils;
    imgCore = core.require.imgCore;
    readerEvent = core.require.readerEvent;
    selectPlugin = core.require.selectPlugin;
    tableCore = core.require.tableCore;
    todoCore = core.require.todoCore;
    wizStyle = core.require.wizStyle;
  };

  var noteSrc = '';

  var setDomReadOnly = function setDomReadOnly(tag, readonly) {
    var domList = env.body.getElementsByTagName(tag);
    for (var i = 0; i < domList.length; i++) {
      var obj = domList[i];
      obj.readOnly = readonly;
    }
  };

  this.afterRender = function (callback) {
    // let debugTimerId = 'afterRender()';
    // window.wizDebugTimer.start(debugTimerId);

    var onCodeRender = function onCodeRender() {
      // window.wizDebugTimer.add(debugTimerId, 'onCodeRender() run');

      imgCore.setImgFullPath();
      // window.wizDebugTimer.add(debugTimerId, 'imgCore.setImgFullPath');

      //禁用 输入框（主要用于 九宫格 处理）
      setDomReadOnly('input', true);
      setDomReadOnly('textarea', true);
      // window.wizDebugTimer.add(debugTimerId, 'setDomReadOnly input & textarea');

      if (typeof callback === 'function') {
        callback();
      }
    };

    // 阅读模式有 markdown、mathjax 渲染，是异步操作，必须要等待其结束后执行
    domUtils.fixOrderList();
    // window.wizDebugTimer.add(debugTimerId, 'fixOrderList');

    readerEvent.on();
    // window.wizDebugTimer.add(debugTimerId, 'fixOrderList');

    imgCore.on();
    // window.wizDebugTimer.add(debugTimerId, 'fixOrderList');

    selectPlugin.on();

    tableCore.on();
    // window.wizDebugTimer.add(debugTimerId, 'fixOrderList');

    if (todoCore) {
      todoCore.on();
    }
    // window.wizDebugTimer.add(debugTimerId, 'fixOrderList');

    blockCore.on();
    // window.wizDebugTimer.add(debugTimerId, 'fixOrderList');

    //  markdown 笔记在渲染 markdown 时，已经处理过 codeCore，避免循环嵌套，这里不需要反复处理
    if (!codeCore || env.options.reader.type === CONST.NOTE_READER_TYPE.MARKDOWN) {
      onCodeRender();
    } else {
      // window.wizDebugTimer.add(debugTimerId, 'CodeCore.on Start');
      codeCore.on({}, onCodeRender);
    }
  };

  this.off = function (options, callback) {
    options = options || {};
    _this.offEvent();

    if (typeof options.noteSrc === 'string') {
      noteSrc = options.noteSrc;
    } else if (options.useContentExtractionHtml) {
      var html = contentCore && contentCore.getContentExtractionHtml();
      if (html) {
        noteSrc = html;
        env.options.pureReadMode.needContentExtraction = false;
      }
    }

    if (!noteSrc) {
      callback();
      return;
    }

    // 设置 useContentExtractionHtml 后，必须使用 纯净阅读的内容 替换 原始内容
    if (env.options.reader.type === CONST.NOTE_READER_TYPE.COMMON && !options.useContentExtractionHtml) {
      // domUtils.removeByName(CONST.NAME.TMP_STYLE);
      domUtils.removeByTag(CONST.TAG.TMP_TAG);
      setDomReadOnly('input', false);
      setDomReadOnly('textarea', false);
    } else if (env.options.container && !env.options.useFrame) {
      env.body.innerHTML = noteSrc;
      domUtils.removeClass(env.body, CONST.CLASS.MARKDOWN_BODY);
    } else {
      // 如果 noteSrc 不完整，必须要补全，否则会导致 含有 Mathjax 的 Markdown 笔记在切换编辑、阅读状态时出现异常
      if (!/<body(\s|>)/ig.test(noteSrc)) {
        noteSrc = CONST.EMPTY_NOTE_TEMPLATE.replace('${body}', noteSrc.escapeReplace());
      }

      // 必须先设置 body 不显示滚动条，然后再 rewrite，
      // 由于客户端 chrome 内核版本有bug，否则会导致设置样式的滚动条无法显示
      env.doc.body.style.overflow = 'hidden';
      setTimeout(function () {
        env.doc.open("text/html", "replace");
        env.doc.write(noteSrc);
        env.doc.close();
        // 因为 doc 内 所有 元素被重写，所以必须更新 env.body
        env.body = env.doc.body;
        domUtils.attr(env.body, { spellcheck: 'false' });
        domPatch.run(env.win);

        env.scrollContainer = domUtils.getScrollContainer();
        callback();
      }, 0);
      return;
    }
    callback();
  };

  this.offEvent = function () {
    highlightUtils.off();

    readerEvent.off();
    blockCore.off();
    if (todoCore) {
      todoCore.off();
    }
    if (codeCore) {
      codeCore.off();
    }
    tableCore.off();
    selectPlugin.off();
    imgCore.off();
    frameViewCore.off();
  };

  this.on = function () {
    // let debugTimerId = 'Reader.on()';
    // window.wizDebugTimer.start(debugTimerId);

    env.readonly = true;

    domUtils.removeClass(env.body, CONST.CLASS.EDITING);
    domUtils.addClass(env.body, CONST.CLASS.READONLY);
    if (env.options.container) {
      domUtils.removeClass(env.options.container, CONST.CLASS.EDITING);
      domUtils.addClass(env.options.container, CONST.CLASS.READONLY);
    }
    // window.wizDebugTimer.add(debugTimerId, 'fix class');

    frameViewCore.on();
    // window.wizDebugTimer.add(debugTimerId, 'frameViewCore.on()');

    // noteSrc 获取数据会导致 半秒左右的性能问题，
    // 但目前不能使用 setTimeout 处理， 否则对于 markdown 笔记会有可能导致 noteSrc 获取 markdown 处理后的内容
    noteSrc = domUtils.getContentHtml({
      isSaveTemp: true
    });
    var clearTmpOpacity = /(<body [^>]*)opacity:[ ]*0;?/ig;
    noteSrc = noteSrc.replace(clearTmpOpacity, '$1');

    // window.wizDebugTimer.add(debugTimerId, 'set noteSrc');

    if (env.frame.toolbarContainer && env.options.document !== env.doc) {
      dependLoader.loadCss(env.options.document, [env.dependency.files.css.fonts]);
    }
    dependLoader.loadCss(env.doc, [env.dependency.files.css.fonts]);

    // 为避免 markdown、mathjax 渲染时 内容闪动，预先加载时，先让 body 透明，当渲染完毕后再删除该样式
    // 预先保存 笔记内容时，需要强行删除此临时样式，避免切换 编辑 和 阅读模式时出现白屏
    // 删除 STYLE_FOR_LOAD 最终没有放到 callback 内，主要避免 白屏事件过长，所以此方法可屏蔽
    // noteSrc = domUtils.removeStyleByNameFromHtml(noteSrc, [CONST.NAME.STYLE_FOR_LOAD]);
    wizStyle.insertTmpReaderStyle();
    // window.wizDebugTimer.add(debugTimerId, ' wizStyle.insertTmpReaderStyle();');
    // window.wizDebugTimer.end(debugTimerId);
  };
};
module.exports = Reader;

},{"../../config/const":388,"../../libs/dependLoader":397,"../../libs/domPatch":398}],379:[function(require,module,exports){
'use strict';

/**
 * reader 使用的基本事件处理
 */
var CONST = require('../../config/const');
var utils = require('../../libs/utils');

var ReaderEvent = function ReaderEvent() {
  var _this = this;

  var core = null;
  var env = null;
  var domUtils = null;
  var clipboardUtils = null;
  var codeUtils = null;
  var linkUtils = null;
  var rangeUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
    clipboardUtils = core.require.clipboardUtils;
    codeUtils = core.require.codeUtils;
    linkUtils = core.require.linkUtils;
    rangeUtils = core.require.rangeUtils;
  };

  this.isScrolled = false;

  /**
   * 复制/剪切 选中区域
   */
  var copySelection = function copySelection(e, callback) {
    var range = rangeUtils.getRange(),
        fragment = void 0,
        hasCodeMirror = false,
        tmp = void 0;
    var startContainer = void 0,
        endContainer = void 0;

    // 检查复制的区域内是否存在 codeMirror
    if (range && !range.collapsed) {
      // body contenteditable= false 时，可以普通文本和 CodeMirror内文本同时选择，
      // 所以编辑时 和 阅读时 处理规则不一致
      startContainer = codeUtils && codeUtils.getContainerFromChild(range.startContainer);
      endContainer = codeUtils && codeUtils.getContainerFromChild(range.endContainer);

      // 同一个 CodeMirror 内 复制操作 WizEditor 不进行任何干预
      // 移动端 不使用 CodeMirror 内的复制操作（nocursor 会导致复制错误）
      if (startContainer && startContainer === endContainer) {
        if (!env.client.type.isPhone && !env.client.type.isPad) {
          callback();
          return;
        } else {
          hasCodeMirror = true;
        }
      } else {
        tmp = range.cloneContents();
        hasCodeMirror = !!tmp.querySelector('.' + CONST.CLASS.CODE_CONTAINER);
      }
    }

    // 只有选中 CodeMirror 区域 才干涉选中内容
    if (!range || range.collapsed || !hasCodeMirror) {
      callback();
      return;
    }

    fragment = rangeUtils.getFragmentForCopy();

    if (fragment) {
      var text = fragment.innerText;
      var html = fragment.innerHTML;

      fragment.innerHTML = '';
      env.body.removeChild(fragment);
      fragment = null;

      var _callback = function _callback() {
        callback();
      };

      clipboardUtils.setData(e, html, text, _callback);
    } else {
      fragment = null;
      callback();
    }
  };

  var handler = {
    onDblclick: function onDblclick(e) {
      env.event.call(CONST.EVENT.ON_DBLCLICK, e);
    },
    onClick: function onClick(e) {
      linkUtils.onClickLink(e);
      if (env.options.reader.callback.onClick && !env.options.reader.callback.onClick(e)) {
        return;
      }
      env.event.call(CONST.EVENT.ON_CLICK, e);
    },
    onCopy: function onCopy(e) {
      copySelection(e, function () {});
    },
    onMousedown: function onMousedown(e) {
      env.event.call(CONST.EVENT.ON_MOUSE_DOWN, e);
    },
    onMousemove: function onMousemove(e) {
      env.event.call(CONST.EVENT.ON_MOUSE_MOVE, e);
    },
    onScroll: function onScroll(e) {
      _this.isScrolled = true;
      env.event.call(CONST.EVENT.ON_SCROLL, e);
    },
    onTouchEnd: function onTouchEnd(e) {
      env.event.call(CONST.EVENT.ON_TOUCH_END, e);
    },
    onTouchStart: function onTouchStart(e) {
      env.event.call(CONST.EVENT.ON_TOUCH_START, e);
    }
  };

  this.on = function () {
    _this.bind();
  };
  this.off = function () {
    _this.unbind();
  };
  this.bind = function () {
    _this.unbind();
    env.body.addEventListener('dblclick', handler.onDblclick);
    env.body.addEventListener('click', handler.onClick);
    env.body.addEventListener('copy', handler.onCopy);
    env.body.addEventListener('cut', handler.onCopy);
    env.body.addEventListener('mousedown', handler.onMousedown);
    env.body.addEventListener('mousemove', handler.onMousemove);
    if (env.supportTouchEvent) {
      env.body.addEventListener('touchend', handler.onTouchEnd);
      env.body.addEventListener('touchstart', handler.onTouchStart);
    }

    env.doc.addEventListener('scroll', handler.onScroll);
  };
  this.unbind = function () {
    env.body.removeEventListener('dblclick', handler.onDblclick);
    env.body.removeEventListener('click', handler.onClick);
    env.body.removeEventListener('copy', handler.onCopy);
    env.body.removeEventListener('cut', handler.onCopy);
    env.body.removeEventListener('mousedown', handler.onMousedown);
    env.body.removeEventListener('mousemove', handler.onMousemove);
    env.body.removeEventListener('touchend', handler.onTouchEnd);
    env.body.removeEventListener('touchstart', handler.onTouchStart);

    env.doc.removeEventListener('scroll', handler.onScroll);
  };
};

module.exports = ReaderEvent;

},{"../../config/const":388,"../../libs/utils":400}],380:[function(require,module,exports){
'use strict';

/**
 * 表格操作核心包 core
 */
var CONST = require('../../config/const');
var utils = require('../../libs/utils');

var TableCore = function TableCore() {
  var _this = this;

  var core = null;
  var env = null;
  var blockUtils = null;
  var codeUtils = null;
  var domUtils = null;
  var historyUtils = null;
  var rangeUtils = null;
  var tableMenu = null;
  var tableUtils = null;
  var tableZone = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    blockUtils = core.require.blockUtils;
    codeUtils = core.require.codeUtils;
    domUtils = core.require.domUtils;
    historyUtils = core.require.historyUtils;
    rangeUtils = core.require.rangeUtils;
    tableMenu = core.require.tableMenu;
    tableUtils = core.require.tableUtils;
    tableZone = core.require.tableZone;
  };

  var _event = {
    bind: function bind() {
      _event.unbind();
      env.event.add(CONST.EVENT.ON_DRAG_START, _event.handler.onDragStart);
      env.event.add(CONST.EVENT.ON_KEY_UP, _event.handler.onKeyUp);

      if (env.client.type.isPhone || env.client.type.isPad) {
        env.event.add(CONST.EVENT.ON_TOUCH_START, _event.handler.onMouseDown);
        env.event.add(CONST.EVENT.ON_TOUCH_END, _event.handler.onMouseUp);
      } else {
        env.event.add(CONST.EVENT.ON_MOUSE_DOWN, _event.handler.onMouseDown);
        env.event.add(CONST.EVENT.ON_MOUSE_OVER, _event.handler.onMouseOver);
        env.event.add(CONST.EVENT.ON_MOUSE_UP, _event.handler.onMouseUp);
      }
      env.event.add(CONST.EVENT.ON_SELECTION_CHANGE, _event.handler.onSelectionChange);
      env.event.add(CONST.EVENT.AFTER_RESTORE_HISTORY, _event.handler.afterRestoreHistory);
    },
    unbind: function unbind() {
      env.event.remove(CONST.EVENT.ON_DRAG_START, _event.handler.onDragStart);
      env.event.remove(CONST.EVENT.ON_KEY_UP, _event.handler.onKeyUp);
      env.event.remove(CONST.EVENT.ON_MOUSE_DOWN, _event.handler.onMouseDown);
      env.event.remove(CONST.EVENT.ON_MOUSE_OVER, _event.handler.onMouseOver);
      env.event.remove(CONST.EVENT.ON_MOUSE_UP, _event.handler.onMouseUp);
      env.event.remove(CONST.EVENT.ON_TOUCH_START, _event.handler.onMouseDown);
      env.event.remove(CONST.EVENT.ON_TOUCH_END, _event.handler.onMouseUp);
      env.event.remove(CONST.EVENT.ON_SELECTION_CHANGE, _event.handler.onSelectionChange);
      env.event.remove(CONST.EVENT.AFTER_RESTORE_HISTORY, _event.handler.afterRestoreHistory);
    },
    handler: {
      afterRestoreHistory: function afterRestoreHistory() {
        //恢复历史后，需要修正 zone
        var tmpCells = void 0,
            cells = [];

        tmpCells = env.doc.getElementsByClassName(CONST.CLASS.SELECTED_CELL);

        if (tmpCells.length === 0) {
          tableZone.clear();
          return;
        }

        for (var i = 0, j = tmpCells.length; i < j; i++) {
          var cell = tmpCells[i];
          if (!domUtils.checkInTmp(cell)) {
            cells.push(cell);
          }
        }

        var table = domUtils.getParentByTagName(cells[0], 'table', true, null);
        if (!table) {
          tableZone.clear();
          return;
        }

        tableZone.setStart(cells[0]);

        var zone = tableZone.getZone();
        var endCell = cells[cells.length - 1],
            endCellRange = tableUtils.getRangeByCellData(tableUtils.getCellData(zone.grid, endCell)),
            cellRange = void 0;

        for (var _i = 1; _i < cells.length - 1; _i++) {
          var _cell = cells[_i];
          if (_cell.rowSpan === 1) {
            continue;
          }
          cellRange = tableUtils.getRangeByCellData(tableUtils.getCellData(zone.grid, _cell));
          if (cellRange.maxY > endCellRange.maxY || (cellRange.maxY = endCellRange.maxY && cellRange.maxX > endCellRange.maxX)) {
            endCell = _cell;
            endCellRange = cellRange;
          }
        }

        tableZone.setEnd(endCell);

        //修正 Menu
        tableMenu.show();
      },
      onDragStart: function onDragStart(e) {
        //表格内禁止拖拽操作
        var table = domUtils.getParentByTagName(e.target, 'table', true, null);
        if (table) {
          utils.stopEvent(e);
        }
      },
      onKeyDown: function onKeyDown(e) {
        var sel = rangeUtils.getSelection();
        var zone = tableZone.getZone();
        if (!zone.range || !sel || !sel.modify) {
          return true;
        }

        var method = e.shiftKey ? 'extend' : 'move';
        var code = e.keyCode || e.which,
            direct = void 0,
            charMove = false,
            oldCur = sel.focusNode,
            newCur = void 0,
            startX = void 0;
        switch (code) {
          case 37:
            //left
            if (!e.ctrlKey && !e.metaKey && oldCur) {
              charMove = true;
              sel.modify(method, 'backward', 'character');
            }
            direct = { x: -1, y: 0 };
            break;
          case 38:
            //up
            if (!e.ctrlKey && !e.metaKey && oldCur) {
              charMove = true;
              sel.modify('move', 'backward', 'line');
            }
            direct = { x: 0, y: -1 };
            break;
          case 9:
            //Tab
            if (!e.shiftKey) {
              direct = { x: 1, y: 0, canChangeRow: true };
            }
            break;
          case 39:
            //right
            if (!e.ctrlKey && !e.metaKey && oldCur) {
              charMove = true;
              sel.modify(method, 'forward', 'character');
            }
            direct = { x: 1, y: 0 };
            break;
          case 13:
            //Enter
            if (!e.ctrlKey && !e.metaKey) {
              break;
            }
          case 40:
            //down
            if (!e.ctrlKey && !e.metaKey && oldCur) {
              charMove = true;
              sel.modify('move', 'forward', 'line');
            }
            direct = { x: 0, y: 1 };
            break;
        }

        var last = void 0,
            cellData = void 0,
            check = void 0,
            codeContainer = void 0,
            cm = void 0;

        if (charMove) {
          newCur = sel.focusNode;
          oldCur = domUtils.getParentByTagName(oldCur, ['td', 'th'], true, null);
          newCur = domUtils.getParentByTagName(newCur, ['td', 'th'], true, null);
          if (newCur && newCur !== oldCur) {
            if (code === 38 || code === 40 || code === 13) {
              charMove = false;
            } else {
              tableZone.setStart(newCur).setEnd(newCur);
            }
          }

          if (charMove) {
            // 如果光标移动到表格外，则清除 表格选中区域 以及表格工具栏
            check = tableUtils.checkCaretInTableContainer(e);
            if (!newCur && !check.tableContainer) {
              tableZone.clear();
              tableMenu.show();
            } else if (check.before) {
              // 如果移动到表格最前面，设置光标为单元格最前面
              rangeUtils.setRange(zone.start.cell, 0);
              tableZone.setStart(zone.start.cell).setEnd(zone.start.cell);
            }

            utils.stopEvent(e);
            return false;
          } else if (code === 38 && zone.start.cell === zone.end.cell && zone.start.y_src === 0) {
            // 表格第一行 按 up 键，直接进入 table 上面的段落
            startX = zone.start.x;
            newCur = domUtils.getPreviousNode(tableUtils.getContainer(oldCur));
            while (newCur && !domUtils.isTag(newCur, 'br') && domUtils.isEmptyDom(newCur)) {
              newCur = domUtils.getPreviousNode(newCur);
            }
            if (newCur) {
              // 如果 table 上面的段落不是 table，则 x = 0 的 cell 直接进入行首，否则行尾
              tableZone.clear();
              tableMenu.show();
              codeContainer = codeUtils && codeUtils.getContainerFromChild(newCur);
              if (codeContainer) {
                codeUtils.focusToLast(codeContainer.codeMirror);
              } else {
                rangeUtils.setRange(newCur, domUtils.getEndOffset(newCur));
                if (startX === 0 && !domUtils.getParentByTagName(newCur, ['table'], true, null)) {
                  sel.modify('move', 'backward', 'lineboundary');
                }
                rangeUtils.fixScroll();
              }
            } else {
              // 如果 table 上面无内容，则保持原样
              rangeUtils.setRange(zone.start.cell, 0);
              tableZone.setStart(zone.start.cell).setEnd(zone.start.cell);
            }
            utils.stopEvent(e);
            return false;
          } else if (code === 40 && zone.start.cell === zone.end.cell && zone.start.y_src + zone.start.cell.rowSpan >= zone.grid.length) {
            // 表格最后一行 按 down 键，直接进入 table 下面的段落
            startX = zone.start.x;
            newCur = domUtils.getNextNode(tableUtils.getContainer(oldCur));
            while (newCur && !domUtils.isTag(newCur, 'br') && domUtils.isEmptyDom(newCur)) {
              newCur = domUtils.getNextNode(newCur);
            }
            if (newCur) {
              // 如果 table 下面的段落不是 table，则 x = 0 的 cell 直接进入行首，否则行尾
              tableZone.clear();
              tableMenu.show();
              codeContainer = codeUtils && codeUtils.getContainerFromChild(newCur);
              if (codeContainer) {
                codeUtils.focusToFirst(codeContainer.codeMirror);
              } else {
                rangeUtils.setRange(newCur, domUtils.getEndOffset(newCur));
                if (startX === 0 && !domUtils.getParentByTagName(newCur, ['table'], true, null)) {
                  sel.modify('move', 'backward', 'lineboundary');
                }
                rangeUtils.fixScroll();
              }
            } else {
              // 如果 table 上面无内容，则保持原样
              tableZone.setStart(zone.start.cell).setEnd(zone.start.cell);
            }
            utils.stopEvent(e);
            return false;
          }
        }

        if (direct) {
          if (e.shiftKey) {
            last = zone.end || zone.start;
          } else {
            last = zone.start;
          }

          cellData = tableZone.switchCell(last, direct);
          if (cellData === last) {
            // 如果目标 cell 不变，则不进行任何处理
            utils.stopEvent(e);
            return false;
          } else if (cellData) {
            if (e.shiftKey) {
              tableZone.setEnd(cellData.cell, true);
            } else {
              // if (direct.x + direct.y > 0) {
              //     rangeUtils.setRange(cellData.cell, 0);
              // }
              tableZone.setStart(cellData.cell, cellData.x, cellData.y).setEnd(cellData.cell);
            }
            rangeUtils.fixScroll();
            utils.stopEvent(e);
            return false;
          }
        }
        return true;
      },
      onKeyUp: function onKeyUp(e) {
        var keyCode = e.keyCode || e.which;
        if (!env.browser.isMac && (e.ctrlKey && keyCode === 65 || keyCode === 17) || env.browser.isMac && (e.metaKey && keyCode === 65 || keyCode === 91 || keyCode === 93)) {
          //Mac系统 Cmd + A & 非 Mac 系统 Ctrl + A 全选时，不进行处理/ Ctrl 抬起的时候，也不能进行处理
          return;
        }

        var zone = tableZone.getZone(),
            range = rangeUtils.getRange(),
            cell = void 0;
        //从非表格的地方 用键盘移动光标到 单元格内，直接选中该单元格
        if (!zone.range && range && range.collapsed) {
          cell = domUtils.getParentByTagName(range.startContainer, ['td', 'th'], true, null);
          if (cell) {
            tableZone.setStart(cell).setEnd(cell);
            tableMenu.show();
          }
        }

        tableUtils.fixSelection(e);
      },
      onMouseDown: function onMouseDown(e) {
        var isLeft = e.type !== 'mousedown' || e.button === 0 || e.button === 1;
        if (!isLeft) {
          tableMenu.hide();
          return;
        }

        var isMenu = tableUtils.isMenu(e.target);
        if (isMenu) {
          return;
        }

        var cell = domUtils.getParentByTagName(e.target, ['th', 'td'], true, null);
        var table = cell ? domUtils.getParentByTagName(cell, 'table', false, null) : null;
        var pos = tableUtils.getMousePosition(e, table);
        var isZoneBorder = tableZone.isZoneBorder(e);

        if (isZoneBorder.isBodyBorder || isZoneBorder.isContainer) {
          if (!env.client.type.isPhone && !env.client.type.isPad) {
            //手机端不能阻止事件，否则会导致点击这些区域无法滚动屏幕
            utils.stopEvent(e);
          }
          return;
        }

        if (!env.client.type.isPhone && !env.client.type.isPad) {
          if (isZoneBorder.isRight) {
            tableZone.startDragColLine(e.target, pos.x);
            return;
          }
          if (isZoneBorder.isBottom) {
            tableZone.startDragRowLine(e.target, pos.y);
            return;
          }
          if (isZoneBorder.isDot) {
            return;
          }
        }

        if (isZoneBorder.isBorder || isZoneBorder.isScroll) {
          return;
        }

        tableZone.setStart(cell);
        tableMenu.show();
      },
      onMouseOver: function onMouseOver(e) {
        var end = domUtils.getParentByTagName(e.target, ['td', 'th'], true, null);
        tableZone.modify(end);
      },
      onMouseUp: function onMouseUp(e) {
        tableUtils.fixSelection(e);

        var isLeft = e.type !== 'mouseup' || e.button === 0 || e.button === 1;
        if (!isLeft) {
          return;
        }
        var isMenu = void 0,
            isZoneBorder = void 0;
        var zone = tableZone.getZone();
        //当前正在选择单元格时， 不考虑 up 的位置是否 menu 等
        if (!zone.active) {
          isMenu = tableUtils.isMenu(e.target);
          if (isMenu) {
            return;
          }

          isZoneBorder = tableZone.isZoneBorder(e);
          if (isZoneBorder.isRight && !tableZone.isRangeActiving()) {
            return;
          }
          if (isZoneBorder.isBottom && !tableZone.isRangeActiving()) {
            return;
          }
          if (isZoneBorder.isDot) {
            return;
          }
          if (isZoneBorder.isBorder || isZoneBorder.isScroll) {
            return;
          }
        }
        var cell = domUtils.getParentByTagName(e.target, ['td', 'th'], true, null);
        tableZone.setEnd(cell);
        tableMenu.show();
      },
      onSelectionChange: function onSelectionChange(e) {
        var check = tableUtils.checkCaretInTableContainer(e);
        var cell = void 0;
        // 保证自动修正 cell 后，还能正常显示光标，所以不再判断 zone.table
        // let zone = tableZone.getZone();
        // if (check.tableContainer && zone.table !== check.tableContainer.querySelector('table')) {
        var range = rangeUtils.getRange(),
            tableContainer = void 0;
        if (range && !range.collapsed) {
          tableContainer = tableUtils.getContainer(range.startContainer);
          if (tableContainer) {
            // 避免拖拽文字进入 tableContainer 边缘
            domUtils.moveOutFromTableContainer(tableContainer);
          }
          // table container 在 <p> 内时， 拖拽多行文本到 容器末尾，
          // 会导致部分文本在新的 container 内
          tableContainer = tableUtils.getContainer(range.endContainer);
          if (tableContainer) {
            // 避免拖拽文字进入 tableContainer 边缘
            domUtils.moveOutFromTableContainer(tableContainer);
          }
        }
        var zone = tableZone.getZone();
        if (check.tableContainer && zone.table && !zone.table.parentNode) {
          // 只有一个单元格的 Table 删除字符时，浏览器会自动删除整个table
          tableMenu.hide();
          tableZone.clear();
        } else if (check.tableContainer && !zone.range) {
          //如果光标定位在 table & table container 之间，则定位到 table 内第一个 td
          cell = check.tableContainer.querySelectorAll('td');
          cell = check.tableMenu || check.after ? cell[cell.length - 1] : check.before ? cell[0] : null;
          if (cell) {
            tableZone.setStart(cell).setEnd(cell);
            tableMenu.show();
          }
        }
      }
    }
  };

  this.on = function () {
    if (!env.readonly) {
      _event.bind();
    }
    tableUtils.fixTable();
    tableUtils.initTableContainer(null);
    tableZone.clear();
  };
  this.off = function () {
    tableZone.clear();
  };
  this.canCreateTable = function () {
    return tableUtils.canCreateTable(tableZone.getZone());
  };
  this.clearCellValue = function () {
    var zone = tableZone.getZone();
    if (!zone.range) {
      return;
    }
    historyUtils.saveSnap(false);
    tableUtils.clearCellValue(zone.grid, zone.range);
  };
  this.deleteCols = function () {
    var zone = tableZone.getZone();
    if (!zone.range) {
      return;
    }
    if (zone.range.minX === 0 && zone.range.maxX === zone.grid[0].length - 1) {
      _this.deleteTable();
      return;
    }

    historyUtils.saveSnap(false);
    for (var i = zone.range.maxX; i >= zone.range.minX; i--) {
      tableUtils.deleteCols(zone.grid, i);
    }
    tableZone.clear();
  };
  this.deleteRows = function () {
    var zone = tableZone.getZone();
    if (!zone.range) {
      return;
    }
    if (zone.range.minY === 0 && zone.range.maxY === zone.grid.length - 1) {
      _this.deleteTable();
      return;
    }

    historyUtils.saveSnap(false);
    for (var i = zone.range.maxY; i >= zone.range.minY; i--) {
      tableUtils.deleteRows(zone.grid, i);
    }
    tableZone.clear();
  };
  this.deleteTable = function () {
    var zone = tableZone.getZone();
    if (!zone.table) {
      return;
    }
    historyUtils.saveSnap(false);

    var parent = zone.table.parentNode;
    if (parent) {
      parent.removeChild(zone.table);
    }
    tableMenu.remove();
    tableZone.remove();
    parent = domUtils.getParentByFilter(parent, function (dom) {
      return domUtils.hasClass(dom, CONST.CLASS.TABLE_CONTAINER);
    }, true);

    var enter = void 0;
    if (parent) {
      if (parent.parentNode === env.body) {
        enter = env.doc.createElement('div');
        enter.appendChild(env.doc.createElement('br'));
      } else {
        enter = env.doc.createElement('br');
      }
      domUtils.before(enter, parent);
      domUtils.remove(parent);
      rangeUtils.setRange(enter, 0);
    }
  };
  this.distributeCols = function () {
    var zone = tableZone.getZone();
    if (!zone.range) {
      return;
    }
    historyUtils.saveSnap(false);
    tableUtils.distributeCols(zone.table, zone.grid);
    tableZone.updateGrid();
  };
  this.insertCol = function (before) {
    var zone = tableZone.getZone();
    if (!zone.range) {
      return;
    }
    historyUtils.saveSnap(false);
    tableUtils.insertCol(zone.grid, before ? zone.range.minX : zone.range.maxX + 1);
    tableZone.updateGrid();
  };
  this.insertRow = function (before) {
    var zone = tableZone.getZone();
    if (!zone.range) {
      return;
    }
    historyUtils.saveSnap(false);
    tableUtils.insertRow(zone.grid, before ? zone.range.minY : zone.range.maxY + 1);
    tableZone.updateGrid();
  };
  this.insertTable = function (col, row) {
    historyUtils.saveSnap(false);
    var range = rangeUtils.getRange();
    var tmpCell = void 0;

    if (!_this.canCreateTable()) {
      return;
    }
    var curObj = void 0,
        container = void 0,
        table = void 0;
    if (range) {
      range.deleteContents();
      curObj = rangeUtils.getRangeDetail(range.startContainer, range.startOffset);
      curObj = domUtils.getBlockParent(curObj.container, true);
      if (curObj && curObj !== env.body && domUtils.isEmptyDom(curObj) && domUtils.isTag(curObj, 'div')) {
        container = curObj;
        curObj.innerHTML = '';
      }
    }
    table = tableUtils.createTable(col, row);
    container = container ? container : env.doc.createElement('div');
    container.appendChild(table);
    if (!container.parentNode) {
      container = blockUtils.insertBlock(table);
    }
    tableUtils.initTableContainer(table);

    //修正 光标
    tmpCell = table.querySelector('td');
    tableZone.setStart(tmpCell).setEnd(tmpCell);

    env.event.call(CONST.EVENT.UPDATE_RENDER);
  };
  this.merge = function () {
    var zone = tableZone.getZone();
    if (!zone.range) {
      return;
    }
    historyUtils.saveSnap(false);
    var cell = tableUtils.mergeCell(zone.grid, zone.range);
    if (cell) {
      tableZone.updateGrid();
      tableZone.setStart(cell).setEnd(cell);
    }
  };
  /**
   * 修改单元格 Dom 样式 & 属性
   */
  this.modifySelectionDom = function (style, attr) {
    var range = rangeUtils.getRange(),
        zone = tableZone.getZone();

    if ((!range || range.collapsed) && zone.range) {
      tableUtils.modifySelectionDom(zone, style, attr);
      return true;
    }
    return false;
  };
  this.onKeyDown = _event.handler.onKeyDown;
  this.setCellAlign = function (align, valign) {
    var zone = tableZone.getZone();
    if (!zone.range) {
      return;
    }
    historyUtils.saveSnap(false);
    tableUtils.setCellAlign(zone.grid, zone.range, {
      align: align,
      valign: valign
    });
    tableZone.setStartRange();
  };
  this.setCellBg = function (bgColor) {
    var zone = tableZone.getZone();
    if (!zone.range) {
      return;
    }
    historyUtils.saveSnap(false);
    tableUtils.setCellBg(zone.grid, zone.range, bgColor);
    tableZone.setStartRange();
  };
  this.split = function () {
    var zone = tableZone.getZone();
    var range = tableUtils.splitCell(zone.table, zone.grid, zone.range);
    if (range) {
      historyUtils.saveSnap(false);
      tableZone.updateGrid();
      zone = tableZone.getZone();
      tableZone.setStart(zone.grid[range.minY][range.minX].cell).setEnd(zone.grid[range.maxY][range.maxX].cell);
    }
  };
};

module.exports = TableCore;

},{"../../config/const":388,"../../libs/utils":400}],381:[function(require,module,exports){
'use strict';

/*
 表格菜单 控制
 */
var CONST = require('../../config/const');

var _id = {
  col: 'wiz-menu-col',
  align: 'wiz-menu-align',
  bg: 'wiz-menu-bg',
  bgDemo: 'wiz-menu-bg-demo',
  cells: 'wiz-menu-cells',
  more: 'wiz-menu-more'
};
var _class = {
  active: 'active',
  disabled: 'disabled',
  clickItem: 'click-item',
  colorPadItem: 'wiz-table-color-pad-item',
  alignItem: 'wiz-table-cell-align-item'
};
var _subType = {
  list: 1,
  custom: 2
};

var TableMenu = function TableMenu() {
  var _this = this;

  var core = null;
  var env = null;
  var lang = null;
  var domUtils = null;
  var tableCore = null;
  var tableUtils = null;
  var tableZone = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    lang = core.lang;
    domUtils = core.require.domUtils;
    tableCore = core.require.tableCore;
    tableUtils = core.require.tableUtils;
    tableZone = core.require.tableZone;
  };

  var colorPadDemo = void 0;
  var menuObj = void 0;

  var createMenu = function createMenu() {
    var menu = env.body.querySelector('.' + CONST.CLASS.TABLE_TOOLS);
    if (menu) {
      return menu;
    }

    var menuData = [{
      id: _id.col,
      exClass: 'icon-insert editor-icon',
      subMenu: {
        type: _subType.list,
        data: [{
          type: CONST.TYPE.TABLE.INSERT_ROW_UP,
          name: lang.Table.InsertRowUp,
          isSplit: false
        }, {
          type: CONST.TYPE.TABLE.INSERT_ROW_DOWN,
          name: lang.Table.InsertRowDown,
          isSplit: false
        }, {
          type: CONST.TYPE.TABLE.INSERT_COL_LEFT,
          name: lang.Table.InsertColLeft,
          isSplit: false
        }, {
          type: CONST.TYPE.TABLE.INSERT_COL_RIGHT,
          name: lang.Table.InsertColRight,
          isSplit: false
        }, {
          type: CONST.TYPE.TABLE.DELETE_ROW,
          name: lang.Table.DeleteRow,
          isSplit: true
        }, {
          type: CONST.TYPE.TABLE.DELETE_COL,
          name: lang.Table.DeleteCol,
          isSplit: false
        }]
      }
    }, {
      id: _id.align,
      exClass: 'icon-align editor-icon',
      subMenu: {
        type: _subType.custom,
        make: function make() {
          var typeList = [['top', 'middle', 'bottom'], ['left', 'center', 'right']];
          var str = '<div class="wiz-table-menu-sub wiz-table-cell-align">';
          for (var i = 0; i < typeList.length; i++) {
            str += '<div>';
            for (var j = 0; j < typeList[i].length; j++) {
              var dataAlignType = i === 0 ? 'valign' : 'align';
              str += '<div class="' + _class.alignItem + ' ' + _class.clickItem + '" data-type="' + CONST.TYPE.TABLE.SET_CELL_ALIGN + '" data-align-type="' + dataAlignType + '" data-align-value="' + typeList[i][j] + '">';
              if (i === 0) {
                str += '<i class="editor-icon icon-box"></i>';
                str += '<i class="editor-icon valign icon-valign_' + typeList[i][j] + '"></i>';
              } else {
                str += '<i class="editor-icon align icon-align_' + typeList[i][j] + '"></i>';
              }

              str += '</div>';
            }
            str += '</div>';
          }
          str += '</div>';

          return str;
        }
      }
    }, {
      id: _id.bg,
      exClass: 'icon-box editor-icon',
      subMenu: {
        type: _subType.custom,
        make: function make() {
          var colors = [['', '#f7b6ff', '#fecf9c'], ['#acf3fe', '#b2ffa1', '#b6caff'], ['#ffc7c8', '#eeeeee', '#fef49c']];
          var str = '<div class="wiz-table-menu-sub wiz-table-color-pad">';
          for (var i = 0; i < colors.length; i++) {
            str += '<div>';
            for (var j = 0; j < colors[i].length; j++) {
              str += '<div class="' + _class.colorPadItem + ' ' + _class.clickItem + '" data-color="' + colors[i][j] + '" data-type="' + CONST.TYPE.TABLE.SET_CELL_BG + '">';
              str += '<i class="editor-icon icon-box"></i>';
              if (i === 0 && j === 0) {
                str += '<i class="pad-demo editor-icon icon-oblique_line"></i>';
              } else {
                str += '<i class="pad-demo editor-icon icon-inner_box" style="color:' + colors[i][j] + ';"></i>';
              }
              str += '</div>';
            }
            str += '</div>';
          }
          str += '</div>';
          return str;
        }
      }
    }, {
      id: _id.cells,
      exClass: 'icon-merge editor-icon',
      subMenu: {
        type: _subType.list,
        data: [{
          type: CONST.TYPE.TABLE.MERGE_CELL,
          name: lang.Table.MergeCell,
          // exClass: tableZone.isSingleCell() ? 'disabled' : '',
          isSplit: false
        }, {
          type: CONST.TYPE.TABLE.SPLIT_CELL,
          name: lang.Table.SplitCell,
          // exClass: tableZone.hasMergeCell() ? '' : 'disabled',
          isSplit: false
        }, {
          type: CONST.TYPE.TABLE.CLEAR_CELL,
          name: lang.Table.ClearCell,
          isSplit: false
        }]
      }
    }, {
      id: _id.more,
      exClass: 'icon-more editor-icon',
      subMenu: {
        type: _subType.list,
        data: [{
          type: CONST.TYPE.TABLE.DISTRIBUTE_COLS,
          name: lang.Table.DistributeCols,
          exClass: '',
          isSplit: false
        }, {
          type: CONST.TYPE.TABLE.DELETE_TABLE,
          name: lang.Table.DeleteTable,
          exClass: '',
          isSplit: true
        }]
      }
    }];

    menu = env.doc.createElement(CONST.TAG.TMP_TAG);
    domUtils.addClass(menu, CONST.CLASS.TABLE_TOOLS);

    var menuHtml = '<ul>';
    for (var i = 0; i < menuData.length; i++) {
      var m = menuData[i];
      menuHtml += '<li id="' + m.id + '" class="' + CONST.CLASS.TABLE_MENU_ITEM + '">' + '<div class="' + CONST.CLASS.TABLE_MENU_BUTTON + '">' + '<i class="' + m.exClass + '"></i>';
      if (m.id === _id.bg) {
        menuHtml += '<i id="' + _id.bgDemo + '" class="editor-icon icon-inner_box"></i>';
      }
      menuHtml += '</div>';
      if (m.subMenu.type === _subType.list) {
        menuHtml += createSubMenuForList(m.subMenu.data);
      } else {
        menuHtml += m.subMenu.make();
      }
      menuHtml += '</li>';
    }
    menuHtml += '</ul>';
    menu.innerHTML = menuHtml;

    colorPadDemo = menu.querySelector('#' + _id.bgDemo);
    if (colorPadDemo) {
      colorPadDemo.style.color = '#fff';
    }

    return menu;
  };
  var createSubMenuForList = function createSubMenuForList(data) {
    var html = '<ul class="wiz-table-menu-sub">';
    for (var i = 0; i < data.length; i++) {
      var m = data[i];
      html += '<li class="wiz-table-menu-sub-item ' + _class.clickItem;
      if (m.isSplit) {
        html += ' split';
      }
      html += '" data-type="' + m.type + '">' + m.name;
      html += '</li>';
    }
    html += '</ul>';
    return html;
  };
  var getMenuTop = function getMenuTop() {
    var top = void 0,
        tableBody = menuObj.parentNode.querySelector('.' + CONST.CLASS.TABLE_BODY),
        tableBodyTop = tableBody ? tableBody.offsetTop : 0;
    top = tableBodyTop - menuObj.offsetHeight - 2;
    return top + 'px';
  };
  var fixMenuPos = function fixMenuPos() {
    var container = menuObj.parentNode,
        offset = domUtils.getOffset(container),
        scrollTop = domUtils.getPageScroll().top;

    if (scrollTop > offset.top - 30 && scrollTop < container.offsetHeight + offset.top - menuObj.offsetHeight * 2.5) {
      domUtils.css(menuObj, {
        position: 'fixed',
        top: '0',
        left: offset.left + 'px'
      });
    } else {
      domUtils.css(menuObj, {
        position: '',
        top: getMenuTop(),
        left: ''
      });
    }
  };

  var _event = {
    bind: function bind() {
      _event.unbind();
      if (menuObj) {
        menuObj.addEventListener('click', _event.handler.onClick);
        menuObj.addEventListener('mouseover', _event.handler.onMouseOver);
      }
      env.event.add(CONST.EVENT.BEFORE_SAVESNAP, _event.handler.onBeforeSaveSnap);
      env.event.add(CONST.EVENT.ON_SCROLL, _event.handler.onScroll);
    },
    unbind: function unbind() {
      if (menuObj) {
        menuObj.removeEventListener('click', _event.handler.onClick);
        menuObj.removeEventListener('mouseover', _event.handler.onMouseOver);
      }
      env.event.remove(CONST.EVENT.BEFORE_SAVESNAP, _event.handler.onBeforeSaveSnap);
      env.event.remove(CONST.EVENT.ON_SCROLL, _event.handler.onScroll);
    },
    handler: {
      onBeforeSaveSnap: function onBeforeSaveSnap() {
        // 目前不在保存快照前处理
        // this.hideSub();
      },
      onClick: function onClick(e) {
        //点击 一级菜单
        var item = domUtils.getParentByFilter(e.target, function (dom) {
          return domUtils.hasClass(dom, CONST.CLASS.TABLE_MENU_BUTTON);
        }, true);
        if (item) {
          _this.showSub(item.parentNode);
          return;
        }

        //点击 菜单具体功能
        var container = void 0;
        item = domUtils.getParentByFilter(e.target, function (dom) {
          return domUtils.hasClass(dom, _class.clickItem);
        }, true);
        if (!item || domUtils.hasClass(item, _class.disabled)) {
          return;
        }
        var type = item.getAttribute('data-type');
        var todo = true;
        switch (type) {
          case CONST.TYPE.TABLE.CLEAR_CELL:
            tableCore.clearCellValue();
            break;
          case CONST.TYPE.TABLE.MERGE_CELL:
            tableCore.merge();
            break;
          case CONST.TYPE.TABLE.SPLIT_CELL:
            tableCore.split();
            break;
          case CONST.TYPE.TABLE.INSERT_ROW_UP:
            tableCore.insertRow(true);
            break;
          case CONST.TYPE.TABLE.INSERT_ROW_DOWN:
            tableCore.insertRow();
            break;
          case CONST.TYPE.TABLE.INSERT_COL_LEFT:
            tableCore.insertCol(true);
            break;
          case CONST.TYPE.TABLE.INSERT_COL_RIGHT:
            tableCore.insertCol();
            break;
          case CONST.TYPE.TABLE.DELETE_ROW:
            tableCore.deleteRows();
            break;
          case CONST.TYPE.TABLE.DELETE_COL:
            tableCore.deleteCols();
            break;
          case CONST.TYPE.TABLE.SET_CELL_BG:
            var bg = item.getAttribute('data-color');
            tableCore.setCellBg(bg);
            container = domUtils.getParentByFilter(item, function (dom) {
              return domUtils.hasClass(dom, 'wiz-table-color-pad');
            }, false);
            domUtils.removeClass(container.querySelectorAll('.wiz-table-color-pad .' + _class.colorPadItem + '.' + _class.active), _class.active);
            domUtils.addClass(item, _class.active);
            domUtils.attr(colorPadDemo, { 'data-last-color': bg });
            break;
          case CONST.TYPE.TABLE.SET_CELL_ALIGN:
            //设置 对齐方式 时，不自动隐藏二级菜单
            var align = null,
                valign = null;
            if (item.getAttribute('data-align-type') === 'align') {
              align = item.getAttribute('data-align-value');
            } else {
              valign = item.getAttribute('data-align-value');
            }
            tableCore.setCellAlign(align, valign);

            container = item.parentNode;
            domUtils.removeClass(container.querySelectorAll('.' + _class.active), _class.active);
            domUtils.addClass(item, _class.active);
            todo = false;
            break;
          case CONST.TYPE.TABLE.DELETE_TABLE:
            tableCore.deleteTable();
            break;
          case CONST.TYPE.TABLE.DISTRIBUTE_COLS:
            tableCore.distributeCols();
            break;
          default:
            todo = false;
        }

        if (todo) {
          _this.hideSub();
        }
      },
      onMouseOver: function onMouseOver(e) {
        var colorItem = domUtils.getParentByFilter(e.target, function (dom) {
          return domUtils.hasClass(dom, _class.colorPadItem);
        }, true);
        if (colorItem && colorPadDemo) {
          colorPadDemo.style.color = colorItem.getAttribute('data-color') || '#fff';
        }
      },
      onScroll: function onScroll() {
        if (!menuObj || menuObj.style.display === 'none') {
          return;
        }
        fixMenuPos();
      }
    }
  };

  this.hide = function () {
    if (menuObj) {
      menuObj.style.display = 'none';
    }
    _event.unbind();
  };
  this.hideSub = function () {
    if (!menuObj) {
      return;
    }
    var sub = menuObj.querySelectorAll('.' + CONST.CLASS.TABLE_MENU_ITEM + '.' + _class.active);
    domUtils.removeClass(sub, _class.active);

    if (colorPadDemo) {
      colorPadDemo.style.color = colorPadDemo.getAttribute('data-last-color') || '#fff';
    }
  };
  this.remove = function () {
    if (menuObj) {
      domUtils.remove(menuObj);
      menuObj = null;
    }
  };
  this.show = function () {
    if (env.client.type.isPhone || env.client.type.isPad) {
      return;
    }
    var zone = tableZone.getZone();
    if (!zone.grid || !zone.range) {
      _this.hide();
      return;
    }

    var container = domUtils.getParentByFilter(zone.table, function (dom) {
      return domUtils.hasClass(dom, CONST.CLASS.TABLE_CONTAINER);
    }, false);
    menuObj = createMenu();
    domUtils.setContenteditable(menuObj, false);
    _this.hideSub();
    container.appendChild(menuObj);
    domUtils.css(menuObj, {
      top: getMenuTop()
    });
    menuObj.style.display = 'block';

    fixMenuPos();
    _event.bind();
  };
  this.showSub = function (item) {
    if (domUtils.hasClass(item, _class.active)) {
      domUtils.removeClass(item, _class.active);
      return;
    }

    //控制二级菜单 默认值
    var canMerge = void 0,
        canSplit = void 0,
        cellAlign = void 0,
        subItem = void 0,
        zone = tableZone.getZone();
    if (item.id === _id.cells) {
      canMerge = tableUtils.canMerge(zone.grid, zone.range);
      canSplit = tableUtils.canSplit(zone.grid, zone.range);

      subItem = item.querySelector('[data-type=' + CONST.TYPE.TABLE.MERGE_CELL + ']');
      if (subItem && canMerge) {
        domUtils.removeClass(subItem, _class.disabled);
      } else if (subItem) {
        domUtils.addClass(subItem, _class.disabled);
      }

      subItem = item.querySelector('[data-type=' + CONST.TYPE.TABLE.SPLIT_CELL + ']');
      if (subItem && canSplit) {
        domUtils.removeClass(subItem, _class.disabled);
      } else if (subItem) {
        domUtils.addClass(subItem, _class.disabled);
      }
    } else if (item.id === _id.align) {
      cellAlign = tableUtils.getAlign(zone.grid, zone.range);
      subItem = item.querySelector('.' + _class.alignItem + '.' + _class.active + '[data-align-type=align]');
      if (subItem && (!cellAlign.align || subItem.getAttribute('data-align-value').toLowerCase() !== cellAlign.align)) {
        domUtils.removeClass(subItem, _class.active);
        subItem = null;
      }
      if (!subItem && cellAlign.align) {
        subItem = item.querySelector('[data-align-value=' + cellAlign.align + ']');
        domUtils.addClass(subItem, _class.active);
      }

      subItem = item.querySelector('.' + _class.alignItem + '.' + _class.active + '[data-align-type=valign]');
      if (subItem && (!cellAlign.valign || subItem.getAttribute('data-align-value').toLowerCase() !== cellAlign.valign)) {
        domUtils.removeClass(subItem, _class.active);
        subItem = null;
      }
      if (!subItem && cellAlign.valign) {
        subItem = item.querySelector('[data-align-value=' + cellAlign.valign + ']');
        domUtils.addClass(subItem, _class.active);
      }
    }

    _this.hideSub();
    domUtils.addClass(item, _class.active);
  };
};

module.exports = TableMenu;

},{"../../config/const":388}],382:[function(require,module,exports){
'use strict';

/**
 * 表格操作的基本方法集合
 */
var CONST = require('../../config/const');
var utils = require('../../libs/utils');

var TableUtils = function TableUtils() {
  var _this = this;

  var core = null;
  var env = null;
  var domUtils = null;
  var rangeUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
    rangeUtils = core.require.rangeUtils;
  };

  /**
   * 判断当前是否允许新建表格
   */
  this.canCreateTable = function (zone) {
    var range = rangeUtils.getRange(),
        tmpCell = void 0;
    if (range) {
      tmpCell = domUtils.getParentByTagName(range.startContainer, ['table'], true, null) || domUtils.getParentByTagName(range.endContainer, ['table'], true, null);
      if (tmpCell) {
        return false;
      }
      if (domUtils.getParentByClass(range.startContainer, CONST.CLASS.CODE_CONTAINER, true)) {
        // CodeMirror 内
        return false;
      }
    }
    return !zone.range;
  };
  /**
   * 判断选择的单元格是否能进行 合并操作
   */
  this.canMerge = function (grid, range) {
    return grid && range && grid[range.minY][range.minX].cell !== grid[range.maxY][range.maxX].cell;
  };
  /**
   * 判断选择的单元格是否能被拆分
   */
  this.canSplit = function (grid, range) {
    if (!grid || !range) {
      return false;
    }
    var splitMap = {},
        canSplit = false;
    _this.eachRange(grid, range, function (cellData) {
      var key = cellData.x_src + '_' + cellData.y_src;
      if (cellData.fake && !splitMap[key]) {
        splitMap[key] = grid[cellData.y_src][cellData.x_src];
        canSplit = true;
      }
    });
    return canSplit ? splitMap : false;
  };
  /**
   * 检查 光标是否处于 table & tableContainer 之间
   */
  this.checkCaretInTableContainer = function (e) {
    var eType = /^(mouse|touch)/i;
    var result = {
      tableContainer: null,
      tableMenu: false,
      before: false,
      after: false
    };
    var range = void 0,
        tableContainer = void 0,
        target = void 0,
        startOffset = void 0,
        start = void 0;

    if (e && eType.test(e.type)) {
      //mouse || touch 事件触发时， selection 并没有被改变，所以不能使用 range 进行判断
      target = e.target;
    } else {
      range = rangeUtils.getRange();
      if (!range || !range.collapsed) {
        //选择区域 由 keyUp & mouseUp 中的 this.fixSelection(e); 进行过滤
        return result;
      }
      start = rangeUtils.getRangeDetail(range.startContainer, range.startOffset);
      target = start.container;
      startOffset = start.offset;
    }

    if (domUtils.isTag(target, 'table')) {
      _this.initTableContainer(target);
    }

    if (_this.isMenu(target)) {
      result.tableContainer = _this.getContainerExcludeTable(target);
      result.tableMenu = true;
      return result;
    }

    tableContainer = _this.getContainerExcludeTable(target);

    if (tableContainer) {
      result.tableContainer = tableContainer;
      if (e && eType.test(e.type)) {
        // table = tableContainer.querySelector('table');
      } else if (startOffset > 0) {
        result.after = true;
      } else {
        result.before = true;
      }
    }
    return result;
  };
  /**
   * 清空选中区域单元格内的数据
   */
  this.clearCellValue = function (grid, range) {
    if (!grid || !range) {
      return;
    }
    _this.eachRange(grid, range, function (cellData) {
      if (!cellData.fake) {
        cellData.cell.innerHTML = '<br/>';
      }
    });
  };
  /**
   * 复制单元格 Dom
   */
  this.cloneCell = function (cell, isClear) {
    var newCell = env.doc.createElement(cell.tagName);
    newCell.style.cssText = cell.style.cssText;
    if (isClear) {
      newCell.innerHTML = '<br/>';
    } else {
      newCell.colSpan = cell.colSpan;
      newCell.rowSpan = cell.rowSpan;
      newCell.innerHTML = cell.innerHTML;
    }
    // TODO 处理 已选中的 cell
    return newCell;
  };
  /**
   * 创建 单元格
   */
  this.createCell = function (width) {
    var td = env.doc.createElement('td');
    var attr = {
      align: 'left',
      valign: 'middle'
    };
    if (width) {
      attr.style = 'width:' + width + 'px';
    }
    domUtils.attr(td, attr);
    td.appendChild(env.doc.createElement('br'));
    return td;
  };
  /**
   * 创建 表格
   */
  this.createTable = function (col, row) {
    if (!col || !row) {
      return;
    }

    var table = env.doc.createElement('table'),
        tbody = env.doc.createElement('tbody');

    for (var r = 0; r < row; r++) {
      var tr = env.doc.createElement('tr');
      for (var c = 0; c < col; c++) {
        tr.appendChild(_this.createCell(env.options.table.colWidth));
      }
      tbody.appendChild(tr);
    }

    table.appendChild(tbody);
    table.style.width = env.options.table.colWidth * col + 'px';
    return table;
  };
  /**
   * 删除指定的列
   */
  this.deleteCols = function (grid, col) {
    if (!grid || grid.length === 0 || col > grid[0].length) {
      return;
    }
    var table = domUtils.getParentByTagName(grid[0][0].cell, 'table', false, null);

    var tmpCellList = [],
        width = env.options.table.colWidth;

    for (var y = 0; y < grid.length; y++) {
      var g = grid[y][col];
      if (g.y_src === y && g.cell.colSpan > 1) {
        g.cell.colSpan--;
        tmpCellList.push(g.cell);
      } else if (g.y_src === y) {
        width = _this.getCellWidth(g.cell);
        g.cell.parentElement.removeChild(g.cell);
      }
      grid[y].splice(col, 1);
    }

    for (var _y = 0; _y < tmpCellList.length; _y++) {
      var cell = tmpCellList[_y];
      cell.style.width = _this.getCellWidth(cell) - width + 'px';
    }

    //如果所有单元格都删除了，则删除表格
    if (!table.getElementsByTagName('td').length && !table.getElementsByTagName('th').length) {
      table.parentElement.removeChild(table);
    } else {
      _this.fixTableWidth(table);
    }
  };
  /**
   * 删除指定的行
   */
  this.deleteRows = function (grid, row) {
    if (!grid || grid.length === 0 || row > grid.length) {
      return;
    }

    var table = domUtils.getParentByTagName(grid[0][0].cell, 'table', false, null),
        rows = table.rows;
    for (var x = grid[row].length - 1; x >= 0; x--) {
      var g = grid[row][x];
      if (g.x_src === x && g.y_src < g.y) {
        g.cell.rowSpan--;
      } else if (g.x_src === x && g.y_src === g.y && g.cell.rowSpan > 1 && row + 1 < grid.length) {
        //row+1 防止表格异常的 rowSpan 设置
        g.cell.rowSpan--;
        var cellData = _this.getNextCellDataInRow(grid[row + 1], x);
        cellData = cellData ? cellData.cell : null;
        rows[row + 1].insertBefore(g.cell, cellData);
      }
    }
    grid.splice(row, 1);
    rows[row].parentElement.removeChild(rows[row]);

    //如果所有单元格都删除了，则删除表格
    if (!table.getElementsByTagName('tr').length) {
      table.parentElement.removeChild(table);
    } else {
      _this.fixTableWidth(table);
    }
  };
  /**
   * 平均分配每列
   */
  this.distributeCols = function (table, grid) {
    if (!table || !grid) {
      return;
    }
    var colCount = grid[0].length;
    if (colCount === 0) {
      return;
    }

    var rows = table.rows,
        w = table.offsetWidth / colCount;

    for (var y = rows.length - 1; y >= 0; y--) {
      for (var x = rows[y].cells.length - 1; x >= 0; x--) {
        var cell = rows[y].cells[x];
        cell.style.width = w * cell.colSpan + 'px';
      }
    }
    table.style.width = table.offsetWidth + 'px';
  };
  /**
   * each 循环遍历 选中区域的单元格
   */
  this.eachRange = function (grid, range, callback) {
    if (!grid || !range || !callback || typeof callback !== 'function') {
      return;
    }
    var cbBreak = true;
    for (var y = range.minY; cbBreak !== false && y < grid.length && y <= range.maxY; y++) {
      for (var x = range.minX; cbBreak !== false && x < grid[y].length && x <= range.maxX; x++) {
        cbBreak = callback(grid[y][x]);
      }
    }
  };

  this.fixColTimer = -1;
  this.fixColWidth = function (table, tableWidth, cells, cellMap, dx) {
    if (dx >= 0) {
      return;
    }
    // 表格其特殊性，导致 单元格宽度修改后，必须要进行校验，
    // 因为有些在 单元格内的内容是不允许改变 width 的，导致单元格也无法 缩小 width
    if (_this.fixColTimer) {
      clearTimeout(_this.fixColTimer);
    }
    _this.fixColTimer = setTimeout(function () {
      var maxDx = dx;
      table.style.width = tableWidth + 'px';
      for (var i = 0, j = cells.length; i < j; i++) {
        var g = cells[i];
        var tmpDx = g.cell.offsetWidth - cellMap[_this.getKeyForColWidth(g)] + dx;
        // dx < 0 所以找到变化最小的 单元格应该 是 max
        maxDx = i === 0 ? tmpDx : Math.max(maxDx, tmpDx);
      }

      if (maxDx > dx) {
        // console.log('maxDx = ' + maxDx);
        table.style.width = tableWidth - dx + maxDx + 'px';
        // 缩减 width 时，修正 width
        for (var _i = 0, _j = cells.length; _i < _j; _i++) {
          var _g = cells[_i];
          _g.cell.style.width = cellMap[_this.getKeyForColWidth(_g)] - dx + maxDx + 'px';
          // console.log(cellMap[this.getKeyForColWidth(g)] + ' -> ' + (cellMap[this.getKeyForColWidth(g)] - dx + maxDx));
        }
        env.event.call(CONST.EVENT.UPDATE_RENDER);
      }
    }, 0);
  };
  /**
   * 修正选中区域的 selection
   */
  this.fixSelection = function () {
    //避免选择文本时， 选中到 表格内部
    var range = rangeUtils.getRange();
    if (!range || range.collapsed) {
      return;
    }

    var start = range.startContainer,
        startOffset = range.startOffset,
        end = range.endContainer,
        endOffset = range.endOffset,
        startTr = _this.getContainer(start),
        endTr = _this.getContainer(end);
    if (!startTr && !endTr || startTr && endTr) {
      return;
    }

    var table = void 0,
        target = startTr ? startTr : endTr;

    while (table = _this.getContainer(target)) {
      if (startTr) {
        target = domUtils.getNextNode(table, false, end);
      } else {
        target = domUtils.getPreviousNode(table, false, start);
      }
    }

    if (startTr) {
      start = target ? target : end;
      startOffset = 0;
    } else {
      end = target ? target : start;
      endOffset = domUtils.getEndOffset(end);
    }

    if (startTr) {
      rangeUtils.setRange(end, endOffset, start, startOffset);
    } else {
      rangeUtils.setRange(start, startOffset, end, endOffset);
    }
  };
  /**
   * 修正 嵌套的 table
   * 只要有嵌套的 table，就拆解最外层的 table
   */
  this.fixTable = function () {
    var breakTable = function breakTable(tr) {
      if (!tr) {
        return;
      }
      // 首先将 以问题的 tr 为关键 dom，将 外面的 table 进行切割
      var container = _this.getContainer(tr);
      if (!container) {
        container = domUtils.getParentByTagName(tr, ['table']);
      }
      domUtils.splitDomSingle(container, tr);
      // 然后将 剥离出的包含 table 的 主 table 进行剥离
      var table = domUtils.getParentByTagName(tr, ['table']);
      var trList = tr.parentNode.children;
      for (var i = 0; i < trList.length; i++) {
        var _tr = trList[i];
        var tdList = _tr.children;
        var div = env.doc.createElement('div');
        domUtils.before(div, table);
        for (var j = 0; j < tdList.length; j++) {
          var td = tdList[j];
          while (td.firstChild) {
            div.appendChild(td.firstChild);
          }
          var space = env.doc.createElement('span');
          space.innerText = '    ';
          div.appendChild(space);
        }
      }

      var tableContainer = _this.getContainer(table);
      var tableBody = _this.getTableBody(table);
      domUtils.removeClass(tableContainer, CONST.CLASS.TABLE_CONTAINER);
      domUtils.removeClass(tableBody, CONST.CLASS.TABLE_BODY);
      domUtils.attr(tableContainer, { contenteditable: null });
      domUtils.attr(tableBody, { contenteditable: null });
      domUtils.remove(table);
    };

    var tableList = env.body.querySelectorAll('.' + CONST.CLASS.WIZ_BODY + ' table table');
    for (var i = tableList.length - 1; i >= 0; i--) {
      var table = tableList[i];
      if (!domUtils.checkInTmp(table)) {
        breakTable(domUtils.getParentByTagName(table, ['tr'], false));
      }
    }
  };
  /**
   * 修正 table 宽度
   */
  this.fixTableWidth = function (table) {
    if (!table) {
      return;
    }
    var rows = table.rows,
        tableWidth = 0;
    for (var i = 0; i < rows[0].cells.length; i++) {
      var cell = rows[0].cells[i];
      tableWidth += _this.getCellWidth(cell);
    }
    table.style.width = tableWidth + 'px';
  };
  /**
   * 获取 选中区域内综合的单元格对齐方式
   */
  this.getAlign = function (grid, range) {
    if (!grid || !range) {
      return false;
    }
    var align = void 0,
        valign = void 0,
        cell = void 0,
        result = {
      align: '',
      valign: ''
    };
    _this.eachRange(grid, range, function (cellData) {
      cell = cellData.cell;
      if (!cellData.fake) {
        align = cell.align.toLowerCase();
        valign = cell.vAlign.toLowerCase();
      }

      if (result.align === '') {
        result.align = align;
        result.valign = valign;
      }

      if (result.align !== null) {
        result.align = result.align === align ? align : null;
      }
      if (result.valign !== null) {
        result.valign = result.valign === valign ? valign : null;
      }

      return result.align !== null || result.valign !== null;
    });

    return result;
  };
  /**
   * 获取单元格宽度
   */
  this.getCellWidth = function (cell) {
    return parseInt(cell.style.width || cell.offsetWidth, 10);
  };
  /**
   * 根据 单元格 dom 获取 grid 内对应的 data 数据
   */
  this.getCellData = function (grid, cell) {
    if (!grid || !cell) {
      return null;
    }
    for (var i = 0; i < grid.length; i++) {
      for (var j = 0; j < grid[i].length; j++) {
        var g = grid[i][j];
        if (g.cell === cell) {
          return g;
        }
      }
    }
    return null;
  };
  /**
   * 根据 rang 范围 获取 单元格的 data 列表
   */
  this.getCellsByRange = function (grid, range) {
    var cellList = [];
    if (!grid || !range) {
      return cellList;
    }
    _this.eachRange(grid, range, function (cellData) {
      if (!cellData.fake) {
        cellList.push(cellData.cell);
      }
    });
    return cellList;
  };
  this.getContainer = function (target) {
    var c = domUtils.getParentByClass(target, CONST.CLASS.TABLE_CONTAINER, true);
    // 需要排除在临时图层内的 Table 容器
    if (c && domUtils.checkInTmp(c)) {
      c = null;
    }
    return c;
  };
  this.getTableBody = function (target) {
    return domUtils.getParentByFilter(target, function (dom) {
      return domUtils.hasClass(dom, CONST.CLASS.TABLE_BODY);
    }, true);
  };
  /**
   * 根据 target 目标 dom 判断是否处于 table 容器内且 在 table 之外
   */
  this.getContainerExcludeTable = function (target) {
    var cell = domUtils.getParentByTagName(target, ['th', 'td'], true, null);
    return !cell ? _this.getContainer(target) : null;
  };
  /**
   * 从 cell 集合中遍历获取 cell 内的叶子节点集合
   */
  this.getDomsByCellList = function (cellList) {
    var domList = [];
    if (!cellList) {
      return domList;
    }
    for (var i = 0, j = cellList.length; i < j; i++) {
      var cell = cellList[i];
      var tmpList = domUtils.getListA2B({
        startDom: cell.firstChild,
        startOffset: 0,
        endDom: cell.lastChild,
        endOffset: 1,
        noSplit: true
      });
      domList = domList.concat(tmpList.list);
    }
    return domList;
  };
  this.getKeyForColWidth = function (g) {
    return g.x_src + '_' + g.y_src;
  };
  /**
   * 在表格内根据指定单元格 获取 下一个 单元格，到达最后一列时，自动从下一行查找
   */
  this.getNextCellInTable = function (cell) {
    var nextCell = cell.nextElementSibling;
    if (nextCell) {
      return nextCell;
    }
    var tr = cell.parentNode.nextElementSibling;
    while (tr) {
      if (tr.cells.length > 0) {
        return tr.cells[0];
      }
      tr = tr.nextElementSibling;
    }
    return null;
  };
  /**
   * 在一行内 根据列数获取下一个单元格
   */
  this.getNextCellDataInRow = function (gridRow, col) {
    if (!gridRow) {
      return null;
    }
    for (var i = col; i < gridRow.length; i++) {
      if (!gridRow[i].fake) {
        return gridRow[i];
      }
    }
    return null;
  };
  /**
   * 根据 mouse 相关事件，获取 对应的 坐标位置
   */
  this.getMousePosition = function (e, table) {
    var eventClient = utils.getEventClientPos(e);
    var tableBody = _this.getTableBody(table || e.target);
    var pageScroll = domUtils.getPageScroll();
    var clientX = eventClient.x + pageScroll.left + (tableBody ? tableBody.scrollLeft : 0);
    var clientY = eventClient.y + pageScroll.top + (tableBody ? tableBody.scrollTop : 0);
    return {
      x: clientX,
      y: clientY
    };
  };
  // /**
  //  * 在一行内 根据列数获取上一个单元格
  //  */
  // this.getPreviousCellDataInRow = (gridRow, col) => {
  //   if (!gridRow) {
  //     return null;
  //   }
  //   for (let i = col; i >= 0; i--) {
  //     if (!gridRow[i].fake) {
  //       return gridRow[i];
  //     }
  //   }
  //   return null;
  // };
  /**
   * 根据 节点的 cellData 获取单元格所占面积
   */
  this.getRangeByCellData = function (cellData) {
    if (!cellData) {
      return {
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0
      };
    }
    return {
      minX: cellData.x_src,
      minY: cellData.y_src,
      maxX: cellData.x_src + cellData.cell.colSpan - 1,
      maxY: cellData.y_src + cellData.cell.rowSpan - 1
    };
  };
  /**
   * 根据起始单元格的 data 数据 获取 grid 中的 range
   */
  this.getRangeByCellsData = function (grid, startData, endData) {
    if (!grid || !startData || !endData) {
      return null;
    }
    var startRange = _this.getRangeByCellData(startData);
    if (startData.cell === endData.cell) {
      return startRange;
    }
    var endRange = _this.getRangeByCellData(endData);
    var minX = Math.min(startRange.minX, endRange.minX),
        minY = Math.min(startRange.minY, endRange.minY),
        maxX = Math.max(startRange.maxX, endRange.maxX),
        maxY = Math.max(startRange.maxY, endRange.maxY);
    var cellMap = {},
        changeRange = true;
    // console.log(minX + ',' + minY + ' - ' + maxX + ',' + maxY);
    while (changeRange) {
      changeRange = false;
      var _minX = minX;
      var _minY = minY;
      var _maxX = maxX;
      var _maxY = maxY;
      for (var y = minY; y <= maxY; y++) {
        for (var x = minX; x <= maxX; x++) {
          // console.log('['+x+','+y+']' +minX + ',' + minY + ' - ' + maxX + ',' + maxY);
          //遍历范围时，只需要寻找边缘的 Cell 即可
          if (y > minY && y < maxY && x < maxX - 1) {
            x = maxX - 1;
            continue;
          }
          var g = grid[y][x];
          var k = g.x_src + '_' + g.y_src;
          if (cellMap[k]) {
            //如果该 Cell 已经被计算过，则不需要重新计算
            continue;
          }
          var gRange = _this.getRangeByCellData(g);
          minX = Math.min(minX, gRange.minX);
          minY = Math.min(minY, gRange.minY);
          maxX = Math.max(maxX, gRange.maxX);
          maxY = Math.max(maxY, gRange.maxY);
          if (minX !== _minX || minY !== _minY || maxX !== _maxX || maxY !== _maxY) {
            changeRange = true;
            break;
          }
        }
        if (changeRange) {
          break;
        }
      }
    }
    return {
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY
    };
  };
  /**
   * 根据 表格 获取 grid
   */
  this.getTableGrid = function (table) {
    if (!table || !domUtils.isTag(table, 'table')) {
      return null;
    }
    var getX = function getX(index, y) {
      while (grid[y][index]) {
        index++;
      }
      return index;
    };

    var grid = [];
    var rows = table.rows,
        x_src = void 0,
        y_src = void 0,
        startX = void 0;

    for (var r = 0; r < rows.length; r++) {
      var row = rows[r];
      var cells = row.cells;

      if (!grid[r]) {
        grid[r] = [];
      }
      for (var c = 0; c < cells.length; c++) {
        var cell = cells[c];
        var colSpan = cell.colSpan;
        var rowSpan = cell.rowSpan;

        // 从 excel 复制并粘贴的 table 可能 td 内为空
        if (!cell.firstChild) {
          cell.innerHTML = '<br>';
        }

        startX = getX(c, r);
        for (var i = 0; i < rowSpan; i++) {
          if (!grid[r + i]) {
            grid[r + i] = [];
          }
          for (var j = 0; j < colSpan; j++) {
            var y = r + i;
            var x = getX(startX + j, y);
            if (i === 0 && j === 0) {
              x_src = x;
              y_src = y;
            }
            grid[y][x] = {
              cell: cell,
              x: x,
              y: y,
              x_src: x_src,
              y_src: y_src,
              fake: i > 0 || j > 0
            };
          }
        }
      }
    }

    return grid;
  };
  /**
   * 分析 并处理 剪切板内得到的 html 代码
   */
  this.getTemplateByHtmlForPaste = function (html) {
    var pasteTables = void 0,
        pasteIsTable = false,
        pasteDom = void 0,
        template = env.doc.createElement('div');

    template.innerHTML = html;
    //清理无效dom
    domUtils.childNodesFilter(template);

    pasteTables = template.querySelectorAll('table');
    if (pasteTables.length === 1) {
      var pasteTable = pasteTables[0];
      domUtils.remove(pasteTable);
      if (domUtils.isEmptyDom(template)) {
        pasteIsTable = true;
        pasteDom = pasteTable;
      } else {
        //如果不是单一表格，恢复 innerHTML 便于后面标准处理
        template.innerHTML = html;
      }
    }

    if (!pasteIsTable) {
      pasteTables = template.querySelectorAll('table');
      //表格内 禁止粘贴表格，所以需要把表格全部变为 text
      for (var i = pasteTables.length - 1; i >= 0; i--) {
        var _pasteTable = pasteTables[i];
        domUtils.before(env.doc.createTextNode(_pasteTable.innerText), _pasteTable);
        domUtils.remove(_pasteTable);
      }
      //清理 template 内的多余 nodeType
      for (var _i2 = template.childNodes.length - 1; _i2 >= 0; _i2--) {
        var j = template.childNodes[_i2];
        if (j.nodeType !== 1 && j.nodeType !== 3 && domUtils.isEmptyDom(j)) {
          template.removeChild(j);
        }
      }
      pasteDom = template;
    }
    return {
      isTable: pasteIsTable,
      pasteDom: pasteDom
    };
  };
  /**
   * 分析 并处理 剪切板内得到的 text 代码
   */
  this.getTemplateByTxtForPaste = function (txt) {
    txt = (txt || '').trim();
    var rows = txt.split(/\r?\n/),
        table = env.doc.createElement('table'),
        tbody = env.doc.createElement('tbody'),
        maxX = 0;

    table.appendChild(tbody);
    for (var y = 0; y < rows.length; y++) {
      var cols = rows[y].split('\t');
      var tr = env.doc.createElement('tr');
      for (var x = 0; x < cols.length; x++) {
        var td = _this.createCell();
        if (cols[x]) {
          td.innerHTML = '';
          td.appendChild(env.doc.createTextNode(cols[x]));
        }
        tr.appendChild(td);
      }
      maxX = Math.max(maxX, tr.cells.length);
      tbody.appendChild(tr);
    }

    //避免 table 列数不一致
    rows = table.rows;
    for (var _y2 = 0; _y2 < rows.length; _y2++) {
      var _tr2 = rows[_y2];
      var _cols = _tr2.cells;
      for (var _x = _cols.length; _x < maxX; _x++) {
        _tr2.appendChild(_this.createCell());
      }
    }

    return {
      isTable: true,
      pasteDom: table
    };
  };
  /**
   * 初始化 表格 样式
   */
  this.initTable = function (table) {
    for (var i = table.rows.length - 1; i >= 0; i--) {
      for (var j = table.rows[i].cells.length - 1; j >= 0; j--) {
        var cell = table.rows[i].cells[j];
        cell.style.width = cell.offsetWidth + 'px';
      }
    }
    table.style.width = table.offsetWidth + 'px';
  };
  /**
   * 检查 并 初始化表格容器
   */
  this.initTableContainer = function (_table) {
    var tableList = _table ? [_table] : env.body.querySelectorAll('.' + CONST.CLASS.WIZ_BODY + ' table');
    var checkParent = function checkParent(obj, filter) {
      var parent = obj.parentNode;
      if (!filter(parent)) {
        parent = env.doc.createElement('div');
        domUtils.before(parent, obj);
        parent.appendChild(obj);
      } else if (domUtils.isTag(parent, 'blockquote')) {
        var tmp = parent;
        parent = env.doc.createElement('div');
        domUtils.before(parent, tmp);
        parent.appendChild(obj);
        domUtils.remove(tmp);
      }
      return parent;
    };
    for (var i = 0, j = tableList.length; i < j; i++) {
      var table = tableList[i];
      // 临时区域内的 Table 一概不处理
      if (domUtils.checkInTmp(table)) {
        continue;
      }
      var tableBody = checkParent(table, function (parent) {
        // 需要兼容 WizTemplate 的模板
        if (parent === env.body || domUtils.hasClass(parent, CONST.CLASS.TEMPLATE_EDITABLE)) {
          return false;
        }
        if (parent.childNodes.length === 1) {
          domUtils.addClass(parent, CONST.CLASS.TABLE_BODY);
          return true;
        }
        return domUtils.hasClass(parent, CONST.CLASS.TABLE_BODY);
      });

      var container = checkParent(tableBody, function (parent) {
        // 需要兼容 WizTemplate 的模板
        if (parent === env.body || domUtils.hasClass(parent, CONST.CLASS.TEMPLATE_EDITABLE)) {
          return false;
        }
        if (parent.childNodes.length === 1) {
          domUtils.addClass(parent, CONST.CLASS.TABLE_CONTAINER);
          return true;
        }
        return domUtils.hasClass(parent, CONST.CLASS.TABLE_CONTAINER);
      });

      domUtils.addClass(container, CONST.CLASS.TABLE_CONTAINER);
      //避免 编辑、阅读状态切换时， 表格位置闪动，所以做成 inline 模式
      domUtils.css(container, {
        position: 'relative',
        padding: '0px'
      });
      domUtils.addClass(tableBody, CONST.CLASS.TABLE_BODY);
      domUtils.removeClass(tableBody, CONST.CLASS.TABLE_MOVING);
      // patch for Firefox & Ie  避免出现系统默认的 resize 控制条
      domUtils.setContenteditable(container, false);
      domUtils.setContenteditable(tableBody, !env.readonly);
    }
  };
  /**
   * 在指定的位置插入列
   */
  this.insertCol = function (grid, col) {
    if (!grid) {
      return;
    }
    col = col || 0;
    var g = void 0,
        cell = void 0,
        newCell = void 0,
        nextCellData = void 0;
    var table = domUtils.getParentByTagName(grid[0][0].cell, 'table', false, null),
        rows = table.rows,
        lastCell = null;
    for (var y = 0; y < grid.length; y++) {
      var gRow = grid[y];

      if (gRow.length > col) {
        g = grid[y][col];
        cell = g.cell;
      } else {
        g = null;
        cell = null;
      }
      if (cell && cell !== lastCell && g.x_src < col) {
        //cell.colSpan > 1
        g.cell.colSpan++;
        // 需要调整 style
        g.cell.style.width = _this.getCellWidth(g.cell) + env.options.table.colWidth + 'px';
      } else if (!cell || cell && g.x_src === col) {
        newCell = _this.createCell(env.options.table.colWidth);
        if (cell && g.y_src < g.y) {
          //cell.rowSpan > 1
          nextCellData = _this.getNextCellDataInRow(grid[y], col);
          rows[y].insertBefore(newCell, nextCellData ? nextCellData.cell : null);
        } else {
          rows[y].insertBefore(newCell, cell);
        }
      }
      lastCell = g ? g.cell : null;
    }
    _this.fixTableWidth(table);
  };
  /**
   * 在指定的位置插入行
   */
  this.insertRow = function (grid, row) {
    if (!grid) {
      return;
    }
    row = row || 0;
    var newCell = void 0;
    var tr = env.doc.createElement('tr');
    var rowIndex = grid.length > row ? row : grid.length - 1;
    var gRow = grid[rowIndex];
    for (var x = 0; x < gRow.length; x++) {
      var g = gRow[x];
      if (grid.length > row && g.y_src < g.y && g.x_src === g.x) {
        //cell.rowSpan > 1
        g.cell.rowSpan++;
        // TODO 需要调整 style( height)
      } else if (grid.length <= row || g.y_src === g.y) {
        newCell = _this.cloneCell(g.cell, true);
        if (g.cell.colSpan > 1) {
          newCell.style.width = g.cell.offsetWidth / g.cell.colSpan + 'px';
        }
        tr.appendChild(newCell);
      }
    }

    var table = domUtils.getParentByTagName(grid[0][0].cell, 'table', false, null),
        rows = table.rows;
    var target = rows[rowIndex],
        parent = target.parentElement;
    if (grid.length <= row) {
      target = null;
    }
    parent.insertBefore(tr, target);
  };
  this.isMenu = function (dom) {
    if (!dom) {
      return false;
    }
    return !!domUtils.getParentByFilter(dom, function (p) {
      return domUtils.hasClass(p, CONST.CLASS.TABLE_TOOLS);
    }, true);
  };
  /**
   * 将指定的单元格范围进行合并
   */
  this.mergeCell = function (grid, range) {
    if (!_this.canMerge(grid, range)) {
      return null;
    }

    var dy = range.maxY - range.minY + 1,
        dx = range.maxX - range.minX + 1;

    var target = grid[range.minY][range.minX].cell;
    var temp = env.doc.createElement('div');
    _this.eachRange(grid, range, function (cellData) {
      if (!cellData.fake && cellData.cell !== target) {
        if (!domUtils.isEmptyDom(cellData.cell)) {
          if (temp.lastChild) {
            temp.appendChild(env.doc.createElement('br'));
          }
          while (cellData.cell.firstChild) {
            temp.appendChild(cellData.cell.firstChild);
          }
        }
        domUtils.remove(cellData.cell);
      }
    });
    while (temp.firstChild) {
      target.appendChild(temp.firstChild);
    }
    target.rowSpan = dy;
    target.colSpan = dx;
    return target;
  };
  /**
   * 修改单元格 Dom 样式 & 属性
   */
  this.modifySelectionDom = function (zone, style, attr) {
    //处理单元格样式
    var align = style['text-align'] || null;
    var valign = style['text-valign'] || null;
    delete style['text-align'];
    delete style['text-valign'];

    _this.eachRange(zone.grid, zone.range, function (cellData) {
      if (!cellData.fake) {
        domUtils.modifyNodesStyleAndClear(cellData.cell.childNodes, style, attr, []);
      }
    });
    if (align || valign) {
      _this.setCellAlign(zone.grid, zone.range, {
        align: align,
        valign: valign
      });
    }
  };
  /**
   * 设置单元格对齐方式
   */
  this.setCellAlign = function (grid, range, _alignType) {
    if (!grid || !range) {
      return;
    }

    var alignType = {};
    if (_alignType.align != null) {
      alignType.align = _alignType.align || 'left';
    }
    if (_alignType.valign != null) {
      alignType.valign = _alignType.valign || 'middle';
    }

    _this.eachRange(grid, range, function (cellData) {
      if (!cellData.fake) {
        if (alignType.align) {
          domUtils.css(cellData.cell, { 'text-align': '' });
        }
        if (alignType.valign) {
          domUtils.css(cellData.cell, { 'text-valign': '' });
        }
        domUtils.attr(cellData.cell, alignType);
      }
    });
  };
  /**
   * 设置单元格背景颜色
   */
  this.setCellBg = function (grid, range, bgColor) {
    if (!grid || !range) {
      return;
    }

    bgColor = bgColor || '';
    if (bgColor.toLowerCase() === 'transparent') {
      bgColor = '';
    }
    _this.eachRange(grid, range, function (cellData) {
      if (!cellData.fake) {
        domUtils.css(cellData.cell, {
          'background-color': bgColor
        });
      }
    });
  };
  /**
   * 设置列宽
   */
  this.setColWidth = function (table, grid, col, dx) {
    var fixDx = function fixDx() {
      var cell = void 0,
          maxDx = dx;
      for (var y = 0; y < grid.length; y++) {
        var g = grid[y][col];
        var tmpDx = env.options.table.colWidthMin - g.cell.offsetWidth;
        if (g.cell.colSpan === 1) {
          maxDx = tmpDx;
          cell = g.cell;
          break;
        }
        if (maxDx < tmpDx) {
          maxDx = tmpDx;
          cell = g.cell;
        }
      }
      if (dx < maxDx) {
        return maxDx;
      } else {
        return dx;
      }
    };
    dx = fixDx();
    var tableWidth = table.offsetWidth + dx;
    var cells = [],
        cellMap = {};
    for (var i = 0, j = grid.length; i < j; i++) {
      var g = grid[i][col];
      var key = _this.getKeyForColWidth(g);
      if (!cellMap[key]) {
        cellMap[key] = g.cell.offsetWidth + dx;
        cells.push(g);
      }
    }

    table.style.width = tableWidth + 'px';
    for (var _i3 = 0, _j2 = cells.length; _i3 < _j2; _i3++) {
      var _g2 = cells[_i3];
      _g2.cell.style.width = cellMap[_this.getKeyForColWidth(_g2)] + 'px';
    }
    _this.fixColWidth(table, tableWidth, cells, cellMap, dx);
  };
  /**
   * 设置行高
   */
  this.setRowHeight = function (table, grid, row, dy) {
    var g = void 0,
        cell = void 0,
        maxDy = dy;
    for (var x = 0; x < grid[row].length; x++) {
      g = grid[row][x];
      var tmpDy = env.options.table.rowHeightMin - g.cell.offsetHeight;
      if (g.cell.rowSpan === 1) {
        maxDy = tmpDy;
        cell = g.cell;
        break;
      }
      if (maxDy < tmpDy) {
        maxDy = tmpDy;
        cell = g.cell;
      }
    }

    if (cell) {
      if (dy < maxDy) {
        cell.parentNode.style.height = env.options.table.rowHeightMin + 'px';
      } else {
        cell.parentNode.style.height = g.cell.offsetHeight + dy + 'px';
      }
    }
  };
  /**
   * 拆分单元格
   */
  this.splitCell = function (table, grid, range) {
    var splitMap = _this.canSplit(grid, range);
    if (!splitMap) {
      return null;
    }
    for (var key in splitMap) {
      if (splitMap.hasOwnProperty(key)) {
        var g = splitMap[key];
        var dy = g.cell.rowSpan;
        var dx = g.cell.colSpan;
        for (var y = g.y_src; y < g.y_src + dy; y++) {
          for (var x = g.x_src; x < g.x_src + dx; x++) {
            var item = grid[y][x];
            if (item.fake) {
              var nextCell = _this.getNextCellDataInRow(grid[y], x);
              nextCell = nextCell ? nextCell.cell : null;
              var newCell = _this.cloneCell(item.cell, true);
              table.rows[y].insertBefore(newCell, nextCell);
              item.fake = false;
              item.cell = newCell;
              item.y_src = y;
              item.x_src = x;
            } else {
              item.cell.rowSpan = 1;
              item.cell.colSpan = 1;
            }

            //TODO 需要多做测试检测这样是否可行
            item.cell.style.width = '';
          }
        }
      }
    }
    return range;
  };
};

module.exports = TableUtils;

},{"../../config/const":388,"../../libs/utils":400}],383:[function(require,module,exports){
'use strict';

/**
 * 表格选择区域 控制
 */
var CONST = require('../../config/const');
var utils = require('../../libs/utils');

var TableZone = function TableZone() {
  var _this = this;

  var core = null;
  var env = null;
  var domUtils = null;
  var historyUtils = null;
  var rangeUtils = null;
  var tableUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
    historyUtils = core.require.historyUtils;
    rangeUtils = core.require.rangeUtils;
    tableUtils = core.require.tableUtils;
  };

  var zone = {
    active: false,
    table: null,
    start: null,
    end: null,
    range: null,
    grid: null
  };
  var updateRenderTimer = void 0,
      updateRenderTimes = void 0,
      domModifiedTimer = void 0;
  var clearSelectedCell = function clearSelectedCell() {
    if (!zone.table) {
      return;
    }
    var cells = zone.table.getElementsByClassName(CONST.CLASS.SELECTED_CELL);
    for (var i = cells.length - 1; i >= 0; i--) {
      domUtils.removeClass(cells[i], [CONST.CLASS.SELECTED_CELL, CONST.CLASS.SELECTED_CELL_MULTI]);
    }
  };
  var colLineRender = function colLineRender(x) {
    if (!zone.table) {
      return;
    }
    var rangeBorder = getRangeBorder();
    var minX = rangeBorder.colLine.minLeft;
    if (x < minX) {
      x = minX;
    }
    domUtils.css(rangeBorder.colLine, {
      top: zone.table.offsetTop + 'px',
      left: x + 'px',
      height: zone.table.offsetHeight + 'px',
      display: 'block'
    });
    rangeBorder.container.style.display = 'block';
  };
  var getCellsDataByRange = function getCellsDataByRange() {
    if (!zone.grid || !zone.range) {
      return null;
    }
    var cells = [];
    tableUtils.eachRange(zone.grid, zone.range, function (cellData) {
      if (!cellData.fake) {
        cells.push(cellData);
      }
    });
    return cells;
  };
  var getDomById = function getDomById(parent, id, tagName) {
    var dom = parent.querySelector('#' + id);
    if (!dom) {
      dom = env.doc.createElement(tagName);
      dom.id = id;
      parent.appendChild(dom);
    }
    return dom;
  };
  var getRangeBorder = function getRangeBorder() {
    var rangeBorder = {
      container: null,
      rowLine: null,
      colLine: null,
      start: {
        dom: null,
        top: null,
        right: null,
        bottom: null,
        left: null,
        dot: null
      },
      range: {
        dom: null,
        top: null,
        right: null,
        bottom: null,
        left: null,
        dot: null
      }
    };
    rangeBorder.container = getDomById(env.body, CONST.ID.TABLE_RANGE_BORDER, CONST.TAG.TMP_TAG);
    domUtils.setContenteditable(rangeBorder.container, false);
    rangeBorder.colLine = getDomById(rangeBorder.container, CONST.ID.TABLE_COL_LINE, 'div');
    rangeBorder.rowLine = getDomById(rangeBorder.container, CONST.ID.TABLE_ROW_LINE, 'div');

    rangeBorder.start.dom = getDomById(rangeBorder.container, CONST.ID.TABLE_RANGE_BORDER + '_start', 'div');
    rangeBorder.start.top = getDomById(rangeBorder.start.dom, CONST.ID.TABLE_RANGE_BORDER + '_start_top', 'div');
    rangeBorder.start.right = getDomById(rangeBorder.start.dom, CONST.ID.TABLE_RANGE_BORDER + '_start_right', 'div');
    rangeBorder.start.bottom = getDomById(rangeBorder.start.dom, CONST.ID.TABLE_RANGE_BORDER + '_start_bottom', 'div');
    rangeBorder.start.left = getDomById(rangeBorder.start.dom, CONST.ID.TABLE_RANGE_BORDER + '_start_left', 'div');
    rangeBorder.start.dot = getDomById(rangeBorder.start.dom, CONST.ID.TABLE_RANGE_BORDER + '_start_dot', 'div');

    rangeBorder.range.dom = getDomById(rangeBorder.container, CONST.ID.TABLE_RANGE_BORDER + '_range', 'div');
    rangeBorder.range.top = getDomById(rangeBorder.range.dom, CONST.ID.TABLE_RANGE_BORDER + '_range_top', 'div');
    rangeBorder.range.right = getDomById(rangeBorder.range.dom, CONST.ID.TABLE_RANGE_BORDER + '_range_right', 'div');
    rangeBorder.range.bottom = getDomById(rangeBorder.range.dom, CONST.ID.TABLE_RANGE_BORDER + '_range_bottom', 'div');
    rangeBorder.range.left = getDomById(rangeBorder.range.dom, CONST.ID.TABLE_RANGE_BORDER + '_range_left', 'div');
    rangeBorder.range.dot = getDomById(rangeBorder.range.dom, CONST.ID.TABLE_RANGE_BORDER + '_range_dot', 'div');
    return rangeBorder;
  };
  // let hasMergeCell = () => {
  //   if (!zone.grid || !zone.range) {
  //     return false;
  //   }
  //   let hasMerge = false;
  //   tableUtils.eachRange(zone.grid, zone.range, (cellData) => {
  //     hasMerge = cellData.fake;
  //     return !hasMerge;
  //   });
  //   return false;
  // };
  var initTableContainer = function initTableContainer(rangeBorder) {
    tableUtils.initTableContainer(zone.table);
    var tableBody = zone.table.parentNode;
    tableBody.appendChild(rangeBorder.container);
  };
  var initZone = function initZone(table) {
    zone.table = table;
    zone.grid = tableUtils.getTableGrid(zone.table);
  };
  var isSingleCell = function isSingleCell() {
    if (!zone.grid || !zone.range) {
      return false;
    }
    var cellA = zone.grid[zone.range.minY][zone.range.minX],
        cellB = zone.grid[zone.range.maxY][zone.range.maxX],
        start = zone.start;
    return cellA.cell === cellB.cell && cellB.cell === start.cell;
  };
  var isStartFocus = function isStartFocus() {
    var range = rangeUtils.getRange();
    if (!range) {
      //手机端 失去焦点时，不能重新设置焦点，否则会导致无法关闭键盘
      return env.client.type.isPhone || env.client.type.isPad || !isSingleCell();
    }
    var start = void 0,
        end = void 0,
        endOffset = void 0;
    if (zone.grid && zone.start) {
      start = domUtils.getParentByTagName(range.startContainer, ['th', 'td'], true, null);
      end = range.collapsed ? start : domUtils.getParentByTagName(range.endContainer, ['th', 'td'], true, null);
    }

    //当前没有选中单元格  或  当前已选中该单元格时 true
    if (!zone.start || zone.start.cell === start && start === end) {
      return true;
    }
    if (!range.collapsed && zone.start.cell === start && start !== end && range.endOffset === 0 && end === tableUtils.getNextCellInTable(start)) {
      //如果单元格不是该行最后一个，全选时，endContainer 为下一个 td，且 endOffset 为 0
      //如果单元格是该行最后一个，全选时，endContainer 为下一行的第一个 td
      //这时候必须修正 range， 否则由于 amendUtils.splitAmendDomByRange 的修正，会导致输入的 第1个字符进入到下一个 td 内
      end = start.lastChild;
      endOffset = domUtils.getEndOffset(end);
      //如果不延迟，会导致 选中的区域异常
      setTimeout(function () {
        rangeUtils.setRange(range.startContainer, range.startOffset, end, endOffset);
      }, 200);

      return true;
    }
    return false;
  };
  var rangeRender = function rangeRender(isSubtreeModified) {
    if (!isSubtreeModified) {
      clearSelectedCell();
      selectCellsData(getCellsDataByRange());
    }

    var rangeBorder = getRangeBorder();
    if (!zone.start || !zone.range) {
      rangeBorder.container.style.display = 'none';
      rangeBorder.start.dom.style.display = 'none';
      rangeBorder.range.dom.style.display = 'none';
      return;
    }
    // console.log(rangeBorder);
    if (!isSubtreeModified) {
      initTableContainer(rangeBorder);
    }

    setRangeBorder();
    setStartRange();
  };

  var setRangeBorder = function setRangeBorder() {
    var rangeBorder = getRangeBorder();

    var topSrc = env.doc.body.clientTop;
    var leftSrc = env.doc.body.clientLeft;
    var sLeft = void 0,
        sTop = void 0,
        sWidth = void 0,
        sHeight = void 0;
    var rLeft = void 0,
        rTop = void 0,
        rWidth = void 0,
        rHeight = void 0;

    var rangeCellStart = zone.start ? zone.start.cell : null;
    var rangeCell_A = zone.grid[zone.range.minY][zone.range.minX];
    var rangeCell_B = zone.grid[zone.range.maxY][zone.range.maxX];
    if (!rangeCell_A || !rangeCell_B) {
      return;
    }
    rangeCell_A = rangeCell_A.cell;
    rangeCell_B = rangeCell_B.cell;

    if (rangeCellStart) {
      sTop = topSrc + rangeCellStart.offsetTop;
      sLeft = leftSrc + rangeCellStart.offsetLeft;
      sWidth = rangeCellStart.offsetWidth;
      sHeight = rangeCellStart.offsetHeight;
    }

    rTop = topSrc + rangeCell_A.offsetTop;
    rLeft = leftSrc + rangeCell_A.offsetLeft;
    if (rangeCell_A === rangeCell_B) {
      rWidth = rangeCell_A.offsetWidth;
      rHeight = rangeCell_A.offsetHeight;
    } else {
      rWidth = rangeCell_B.offsetLeft + rangeCell_B.offsetWidth - rLeft;
      rHeight = rangeCell_B.offsetTop + rangeCell_B.offsetHeight - rTop;
    }

    domUtils.css(rangeBorder.start.dom, {
      top: sTop + 'px',
      left: sLeft + 'px'
    });
    domUtils.css(rangeBorder.start.top, {
      width: sWidth + 'px'
    });
    domUtils.css(rangeBorder.start.left, {
      height: sHeight + 'px'
    });
    domUtils.css(rangeBorder.start.bottom, {
      top: sHeight - 1 + 'px',
      width: sWidth + 'px'
    });
    domUtils.css(rangeBorder.start.right, {
      left: sWidth - 1 + 'px',
      height: sHeight + 'px'
    });
    domUtils.css(rangeBorder.start.dot, {
      top: sHeight - 1 - 4 + 'px',
      left: sWidth - 1 - 4 + 'px'
    });

    domUtils.css(rangeBorder.range.dom, {
      top: rTop + 'px',
      left: rLeft + 'px'
    });
    domUtils.css(rangeBorder.range.top, {
      width: rWidth + 'px'
    });
    domUtils.css(rangeBorder.range.left, {
      height: rHeight + 'px'
    });
    domUtils.css(rangeBorder.range.bottom, {
      top: rHeight + 'px',
      width: rWidth + 'px'
    });
    domUtils.css(rangeBorder.range.right, {
      left: rWidth + 'px',
      height: rHeight + 'px'
    });
    domUtils.css(rangeBorder.range.dot, {
      top: rHeight - 4 + 'px',
      left: rWidth - 4 + 'px'
    });

    rangeBorder.start.dom.style.display = 'block';
    if (isSingleCell()) {
      rangeBorder.start.dot.style.display = 'block';
      rangeBorder.range.dom.style.display = 'none';
    } else {
      rangeBorder.start.dot.style.display = 'none';
      rangeBorder.range.dom.style.display = 'block';
    }
    rangeBorder.container.style.display = 'block';

    //TODO 目前功能未制作，暂时隐藏，以后实现了再显示
    rangeBorder.start.dot.style.display = 'none';
    rangeBorder.range.dot.style.display = 'none';
  };
  var rowLineRender = function rowLineRender(y) {
    if (!zone.table) {
      return;
    }
    var rangeBorder = getRangeBorder();
    var minY = rangeBorder.rowLine.minTop;
    if (y < minY) {
      y = minY;
    }
    domUtils.css(rangeBorder.rowLine, {
      left: zone.table.offsetLeft + 'px',
      top: y + 'px',
      width: zone.table.offsetWidth + 'px',
      display: 'block'
    });
    rangeBorder.container.style.display = 'block';
  };
  var selectCellsData = function selectCellsData(cellsData) {
    if (!cellsData) {
      return;
    }
    for (var i = 0, j = cellsData.length; i < j; i++) {
      domUtils.addClass(cellsData[i].cell, CONST.CLASS.SELECTED_CELL + (j > 1 ? ' ' + CONST.CLASS.SELECTED_CELL_MULTI : ''));
    }
  };
  var setStartRange = function setStartRange() {
    var sel = void 0;
    //选中多个单元格时，取消光标
    if (zone.grid && zone.range && !isSingleCell()) {
      sel = rangeUtils.getSelection();
      sel.removeAllRanges();
      return;
    }
    // ios 不重新设置 range，避免反复弹出 粘贴、复制的菜单
    if (env.client.type.isIOS) {
      return;
    }
    if (!isStartFocus()) {
      rangeUtils.setRange(zone.start.cell, zone.start.cell.childNodes.length);
    }
  };

  var _event = {
    bind: function bind() {
      _event.unbind();
      env.event.add(CONST.EVENT.ON_SELECTION_CHANGE, _event.handler.onSelectionChange);
      env.event.add(CONST.EVENT.UPDATE_RENDER, _event.handler.updateRender);
      if (zone.table) {
        //单元格内插入图片时， 因为加载图片时长为知，触发 modified 的时候， 图片还未加载完毕，
        //但加载完毕后，肯定会触发 body 的 resize事件
        zone.table.addEventListener('DOMSubtreeModified', _event.handler.onDomModified);
        env.win.addEventListener('resize', _event.handler.onDomModified);
      }
    },
    unbind: function unbind() {
      var zone = _this.getZone();
      env.event.remove(CONST.EVENT.ON_SELECTION_CHANGE, _event.handler.onSelectionChange);
      env.event.remove(CONST.EVENT.UPDATE_RENDER, _event.handler.updateRender);
      if (zone.table) {
        zone.table.removeEventListener('DOMSubtreeModified', _event.handler.onDomModified);
        env.win.removeEventListener('resize', _event.handler.onDomModified);
      }
    },
    bindStopSelectStart: function bindStopSelectStart() {
      _event.unbindStopSelectStart();
      env.event.add(CONST.EVENT.ON_SELECT_START, _event.handler.onStopSelectStart);
    },
    unbindStopSelectStart: function unbindStopSelectStart() {
      env.event.remove(CONST.EVENT.ON_SELECT_START, _event.handler.onStopSelectStart);
    },
    bindDragLine: function bindDragLine() {
      _event.unbindDragLine();
      _event.bindStopSelectStart();
      env.event.add(CONST.EVENT.ON_MOUSE_MOVE, _event.handler.onDragLineMove);
      env.event.add(CONST.EVENT.ON_MOUSE_UP, _event.handler.onDragLineEnd);
    },
    unbindDragLine: function unbindDragLine() {
      _event.unbindStopSelectStart();
      env.event.remove(CONST.EVENT.ON_MOUSE_MOVE, _event.handler.onDragLineMove);
      env.event.remove(CONST.EVENT.ON_MOUSE_UP, _event.handler.onDragLineEnd);
    },
    handler: {
      onDragLineMove: function onDragLineMove(e) {
        var rangeBorder = getRangeBorder();
        var pos = tableUtils.getMousePosition(e, zone.table);
        if (rangeBorder.colLine.style.display === 'block') {
          colLineRender(pos.x - rangeBorder.colLine.startMouse + rangeBorder.colLine.startLine);
        } else {
          rowLineRender(pos.y - rangeBorder.rowLine.startMouse + rangeBorder.rowLine.startLine);
        }
      },
      onDragLineEnd: function onDragLineEnd(e) {
        _event.unbindDragLine();
        var rangeBorder = getRangeBorder();
        var pos = tableUtils.getMousePosition(e, zone.table);
        var cellData = void 0;
        var isDragCol = rangeBorder.colLine.style.display === 'block';
        var isDragRow = rangeBorder.rowLine.style.display === 'block';

        rangeBorder.colLine.style.display = 'none';
        rangeBorder.rowLine.style.display = 'none';
        historyUtils.saveSnap(false);
        if (isDragCol && rangeBorder.colLine.startMouse !== pos.x) {
          cellData = rangeBorder.colLine.cellData;
          if (cellData) {
            tableUtils.initTable(zone.table);
            tableUtils.setColWidth(zone.table, zone.grid, cellData.x, pos.x - rangeBorder.colLine.startMouse);
          }
        } else if (isDragRow && rangeBorder.rowLine.startMouse !== pos.y) {
          cellData = rangeBorder.rowLine.cellData;
          if (cellData) {
            tableUtils.initTable(zone.table);
            tableUtils.setRowHeight(zone.table, zone.grid, cellData.y, pos.y - rangeBorder.rowLine.startMouse);
          }
        }

        rangeBorder.colLine.cellData = null;
        rangeBorder.colLine.minLeft = null;
        rangeBorder.colLine.startLine = null;
        rangeBorder.colLine.startMouse = null;
        rangeBorder.rowLine.cellData = null;
        rangeBorder.rowLine.minTop = null;
        rangeBorder.rowLine.startLine = null;
        rangeBorder.rowLine.startMouse = null;

        env.event.call(CONST.EVENT.UPDATE_RENDER);
      },
      onSelectionChange: function onSelectionChange(e) {
        //当选中单元格时，不允许 选中 start 单元格以外的任何内容
        var sel = rangeUtils.getSelection();
        if (!isStartFocus()) {
          sel.removeAllRanges();
          // rangeUtils.setRange(zone.start.cell, zone.start.cell.childNodes.length);
          utils.stopEvent(e);
        }
      },
      onDomModified: function onDomModified(e) {
        var isSubtreeModified = true;
        var needAutoRetry = e && e.type === 'DOMSubtreeModified' && e.target.nodeType === 1 && e.target.querySelector('img');
        if (domModifiedTimer) {
          clearTimeout(domModifiedTimer);
        }
        domModifiedTimer = setTimeout(function () {
          env.event.call(CONST.EVENT.UPDATE_RENDER, e, needAutoRetry, isSubtreeModified);
        }, 100);
      },
      onStopSelectStart: function onStopSelectStart(e) {
        utils.stopEvent(e);
        return false;
      },
      updateRender: function updateRender(e, needAutoRetry, isSubtreeModified) {
        var autoUpdate = function autoUpdate(needAutoRetry, isSubtreeModified) {
          //单元格内容变化时，必须重绘，保证 高亮边框的高度与表格一致
          rangeRender(isSubtreeModified);

          //如果 变化的内容里面有 img，则需要延迟监听，等 img 渲染完毕
          if (needAutoRetry && updateRenderTimes < 60) {
            if (updateRenderTimer) {
              clearTimeout(updateRenderTimer);
            }
            updateRenderTimer = setTimeout(function () {
              updateRenderTimes++;
              autoUpdate(needAutoRetry, isSubtreeModified);
            }, 500);
          }
        };

        updateRenderTimes = 0;
        autoUpdate(needAutoRetry, isSubtreeModified);
      }
    }
  };

  this.clear = function () {
    zone.active = false;
    zone.start = null;
    zone.end = null;
    zone.range = null;
    zone.grid = null;

    rangeRender();

    var rangeBorder = getRangeBorder();
    rangeBorder.colLine.style.display = 'none';
    rangeBorder.rowLine.style.display = 'none';

    //table 必须最后清空，因为还要清除 table 里面 cell 的选择状态
    zone.table = null;
    _event.unbind();
    return _this;
  };
  /**
   * 为 复制/剪切 操作，准备 fragment
   */
  this.getFragmentForCopy = function () {
    var fragment = null;
    //无选中单元格时，不进行任何操作
    if (!zone.range) {
      return fragment;
    }

    var table = env.doc.createElement('table'),
        tbody = env.doc.createElement('tbody');
    table.appendChild(tbody);
    for (var y = zone.range.minY; y <= zone.range.maxY; y++) {
      var tr = env.doc.createElement('tr');
      for (var x = zone.range.minX; x <= zone.range.maxX; x++) {
        var g = zone.grid[y][x];
        if (!g.fake) {
          var td = tableUtils.cloneCell(g.cell, false);
          if (tr.children.length > 0) {
            //保证 复制的纯文本 有 列间隔
            tr.appendChild(env.doc.createTextNode('\t'));
          }
          tr.appendChild(td);
        }
      }
      //保证 复制的纯文本 有 行间隔
      tr.appendChild(env.doc.createTextNode('\n'));
      tbody.appendChild(tr);
    }

    fragment = env.doc.createElement('div');
    fragment.appendChild(table);
    return fragment;
  };
  this.getSelectedCells = function () {
    return tableUtils.getCellsByRange(zone.grid, zone.range);
  };
  this.getZone = function () {
    return {
      active: zone.active,
      table: zone.table,
      start: zone.start,
      end: zone.end,
      range: zone.range,
      grid: zone.grid
    };
  };
  // this.hasMergeCell = hasMergeCell;
  this.isRangeActiving = function () {
    return zone.start && zone.active;
  };
  this.isSingleCell = isSingleCell;
  this.isZoneBorder = function (e) {
    var obj = e.target,
        x = e.offsetX,
        y = e.offsetY,
        eventClient = utils.getEventClientPos(e);
    var isScroll = void 0,
        isBodyBorder = false,
        isBorder = false,
        isRight = false,
        isBottom = false,
        isContainer = false;

    var isDot = !!domUtils.getParentByFilter(obj, function (dom) {
      return dom && dom.nodeType === 1 && (dom.id === CONST.ID.TABLE_RANGE_BORDER + '_start_dot' || dom.id === CONST.ID.TABLE_RANGE_BORDER + '_range_dot');
    }, true);

    if (!isDot) {
      isRight = !!domUtils.getParentByFilter(obj, function (dom) {
        if (dom && dom.nodeType === 1 && (dom.id === CONST.ID.TABLE_RANGE_BORDER + '_start_right' || dom.id === CONST.ID.TABLE_RANGE_BORDER + '_range_right')) {
          return true;
        }

        var minX = void 0,
            maxX = void 0;
        if (dom && dom.nodeType === 1 && domUtils.isTag(dom, ['td', 'th'])) {
          minX = dom.offsetWidth - 4;
          maxX = dom.offsetWidth + 4;
          return x >= minX && x <= maxX;
        }
        return false;
      }, true);
    }
    if (!isDot && !isRight) {
      isBottom = !!domUtils.getParentByFilter(obj, function (dom) {
        if (dom && dom.nodeType === 1 && (dom.id === CONST.ID.TABLE_RANGE_BORDER + '_start_bottom' || dom.id === CONST.ID.TABLE_RANGE_BORDER + '_range_bottom')) {
          return true;
        }

        var minY = void 0,
            maxY = void 0;
        if (dom && dom.nodeType === 1 && domUtils.isTag(dom, ['td', 'th'])) {
          minY = dom.offsetHeight - 4;
          maxY = dom.offsetHeight + 4;
          return y >= minY && y <= maxY;
        }
        return false;
      }, true);
    }
    if (!isBottom && !isDot && !isRight) {
      isBorder = !!domUtils.getParentByFilter(obj, function (dom) {
        return dom && dom.nodeType === 1 && dom.id === CONST.ID.TABLE_RANGE_BORDER;
      }, true);
    }

    var bodyStyle = void 0,
        bodyLeft = void 0,
        bodyRight = void 0;
    if (!isBottom && !isDot && !isRight && !isBorder) {
      isContainer = !!tableUtils.getContainerExcludeTable(obj);
      if (!isContainer && obj === env.body) {
        bodyStyle = env.win.getComputedStyle(obj);
        var bodyOffset = domUtils.getOffset(env.body);
        bodyLeft = parseInt(bodyStyle.paddingLeft);
        bodyRight = parseInt(bodyStyle.paddingRight);
        isBodyBorder = eventClient.x - bodyOffset.x <= bodyLeft || eventClient.x - bodyOffset.x >= env.body.offsetWidth - bodyRight;
      }
    }

    //span 等 行级元素 clientWidth / clientHeight 为 0
    isScroll = (e.target.clientWidth > 0 && e.target.clientWidth < e.offsetX || e.target.clientHeight > 0 && e.target.clientHeight < e.offsetY) && (e.target.offsetWidth >= e.offsetX || e.target.offsetHeight >= e.offsetY);

    return {
      isBodyBorder: isBodyBorder,
      isBorder: isBorder,
      isBottom: isBottom,
      isContainer: isContainer,
      isDot: isDot,
      isRight: isRight,
      isScroll: isScroll
    };
  };
  this.modify = function (endCell) {
    if (!zone.active || !endCell) {
      return _this;
    }
    // console.log('modify');
    var table = domUtils.getParentByTagName(endCell, ['table'], true, null);
    if (!table || table !== zone.table) {
      return _this;
    }
    var endCellData = tableUtils.getCellData(zone.grid, endCell);
    zone.range = tableUtils.getRangeByCellsData(zone.grid, zone.start, endCellData);
    zone.end = endCellData;

    rangeRender();

    var tableBody = domUtils.getParentByFilter(zone.table, function (dom) {
      return domUtils.hasClass(dom, CONST.CLASS.TABLE_BODY);
    }, false);
    domUtils.addClass(tableBody, CONST.CLASS.TABLE_MOVING);
    return _this;
  };
  this.remove = function () {
    _this.clear();
    var rangeBorder = getRangeBorder(),
        parent = void 0;
    if (rangeBorder) {
      parent = rangeBorder.container.parentNode;
      if (parent) {
        parent.removeChild(rangeBorder.container);
      }
    }
  };
  this.setEnd = function (endCell, isForced) {
    // console.log('setEnd');
    if (isForced) {
      zone.active = true;
    }
    _this.modify(endCell);
    zone.active = false;

    setStartRange();
    env.event.call(CONST.EVENT.ON_SELECTION_CHANGE, null);

    var tableBody = domUtils.getParentByFilter(zone.table, function (dom) {
      return domUtils.hasClass(dom, CONST.CLASS.TABLE_BODY);
    }, false);
    domUtils.removeClass(tableBody, CONST.CLASS.TABLE_MOVING);

    return _this;
    // console.log(zone);
  };
  this.setStart = function (startCell, curX, curY) {
    // console.log('setStart');
    if (!startCell) {
      _this.clear();
      return _this;
    }
    var table = domUtils.getParentByTagName(startCell, ['table'], true, null);
    if (!table || domUtils.checkInTmp(table)) {
      //防止异常的 标签
      _this.clear();
      return _this;
    }
    if (table !== zone.table) {
      _this.clear();
      initZone(table);
    }
    zone.active = true;
    zone.end = null;
    zone.start = tableUtils.getCellData(zone.grid, startCell);
    if (typeof curX !== 'undefined' && typeof curY !== 'undefined') {
      try {
        var tmp = zone.grid[curY][curX];
        if (tmp && tmp.cell === zone.start.cell) {
          zone.start = tmp;
        }
      } catch (e) {}
    }
    zone.range = tableUtils.getRangeByCellsData(zone.grid, zone.start, zone.start);

    rangeRender();
    if (zone.start.cell.scrollIntoViewIfNeeded) {
      zone.start.cell.scrollIntoViewIfNeeded();
    }

    _event.bind();
    return _this;
  };
  this.setStartRange = setStartRange;
  this.startDragColLine = function (cell, x) {
    var table = void 0,
        cellData = void 0;
    if (cell && cell.nodeType === 1 && cell.id === CONST.ID.TABLE_RANGE_BORDER + '_start_right') {
      cellData = zone.start;
      cell = zone.start.cell;
      table = zone.table;
    } else if (cell && cell.nodeType === 1 && cell.id === CONST.ID.TABLE_RANGE_BORDER + '_range_right') {
      cellData = zone.grid[zone.range.maxY][zone.range.maxX];
      cell = cellData.cell;
      table = zone.table;
    } else {
      cell = domUtils.getParentByTagName(cell, ['th', 'td'], true, null);
      if (!cell) {
        return;
      }
      table = domUtils.getParentByTagName(cell, ['table'], true, null);
      if (!table) {
        return;
      }

      if (table !== zone.table) {
        clearSelectedCell();
        _this.clear();
      }
      if (!zone.grid) {
        initZone(table);
      }
      cellData = tableUtils.getCellData(zone.grid, cell);
    }

    //如果 cell 是合并的单元格，需要找到 cell 所占的最后一列
    var col = cellData.x,
        nextCellData = void 0;
    while (col + 1 < zone.grid[cellData.y].length) {
      col++;
      nextCellData = zone.grid[cellData.y][col];
      if (nextCellData.cell !== cell) {
        break;
      }
      cellData = nextCellData;
    }

    var startLeft = cell.offsetLeft + cell.offsetWidth;
    var rangeBorder = getRangeBorder();
    initTableContainer(rangeBorder);
    rangeBorder.colLine.minLeft = table.offsetLeft;
    rangeBorder.colLine.startLine = startLeft;
    rangeBorder.colLine.startMouse = x;
    rangeBorder.colLine.cellData = cellData;
    colLineRender(startLeft);

    var sel = rangeUtils.getSelection();
    sel.removeAllRanges();
    _event.bindDragLine();
  };
  this.startDragRowLine = function (cell, y) {
    var table = void 0,
        cellData = void 0;
    if (cell && cell.nodeType === 1 && cell.id === CONST.ID.TABLE_RANGE_BORDER + '_start_bottom') {
      cellData = zone.start;
      cell = zone.start.cell;
      table = zone.table;
    } else if (cell && cell.nodeType === 1 && cell.id === CONST.ID.TABLE_RANGE_BORDER + '_range_bottom') {
      cellData = zone.grid[zone.range.maxY][zone.range.maxX];
      cell = cellData.cell;
      table = zone.table;
    } else {
      cell = domUtils.getParentByTagName(cell, ['th', 'td'], true, null);
      if (!cell) {
        return;
      }
      table = domUtils.getParentByTagName(cell, ['table'], true, null);
      if (!table) {
        return;
      }

      if (table !== zone.table) {
        clearSelectedCell();
        _this.clear();
      }
      if (!zone.grid) {
        initZone(table);
      }
      cellData = tableUtils.getCellData(zone.grid, cell);
    }

    //如果 cell 是合并的单元格，需要找到 cell 所占的最后一行
    var row = cellData.y,
        nextCellData = void 0;
    while (row + 1 < zone.grid.length) {
      row++;
      nextCellData = zone.grid[row][cellData.x];
      if (nextCellData.cell !== cell) {
        break;
      }
      cellData = nextCellData;
    }

    var startTop = cell.offsetTop + cell.offsetHeight;
    var rangeBorder = getRangeBorder();
    initTableContainer(rangeBorder);
    rangeBorder.rowLine.minTop = table.offsetTop;
    rangeBorder.rowLine.startLine = startTop;
    rangeBorder.rowLine.startMouse = y;
    rangeBorder.rowLine.cellData = cellData;
    rowLineRender(startTop);

    var sel = rangeUtils.getSelection();
    sel.removeAllRanges();
    _event.bindDragLine();
  };
  this.switchCell = function (target, direct) {
    if (!direct || !zone.start) {
      return null;
    }

    var changeRowCheck = function changeRowCheck() {
      if (direct.canChangeRow && y >= 0 && y < zone.grid.length) {
        //允许折行
        if (x < 0) {
          x = zone.grid[y].length - 1;
          y -= 1;
        } else if (x >= zone.grid[y].length) {
          x = 0;
          y += 1;
        }
      }
    };

    //目前不考虑 x、y 为任意值的情况， 只考虑移动一个单元格
    direct.x = !direct.x ? 0 : direct.x > 0 ? 1 : -1;
    direct.y = !direct.y ? 0 : direct.y > 0 ? 1 : -1;
    var x = target.x + direct.x;
    var y = target.y + direct.y;
    changeRowCheck();

    var cellData = target;
    while (y >= 0 && y < zone.grid.length && x >= 0 && x < zone.grid[y].length && cellData.cell === target.cell) {
      cellData = zone.grid[y][x];
      x += direct.x;
      y += direct.y;
      changeRowCheck();
    }
    return cellData;
  };
  this.updateGrid = function () {
    var rangeA = void 0,
        rangeB = void 0;
    if (zone.table) {
      if (zone.grid) {
        rangeA = zone.grid[zone.range.minY][zone.range.minX];
        rangeB = zone.grid[zone.range.maxY][zone.range.maxX];
      }
      initZone(zone.table);
      rangeA = tableUtils.getCellData(zone.grid, rangeA.cell);
      rangeB = tableUtils.getCellData(zone.grid, rangeB.cell);
      zone.range = tableUtils.getRangeByCellsData(zone.grid, rangeA, rangeB);
      zone.start = tableUtils.getCellData(zone.grid, zone.start.cell);
      if (zone.end) {
        zone.end = tableUtils.getCellData(zone.grid, zone.end.cell);
      }
    }
    env.event.call(CONST.EVENT.UPDATE_RENDER);

    return _this;
    // console.log(zone);
  };
};

module.exports = TableZone;

},{"../../config/const":388,"../../libs/utils":400}],384:[function(require,module,exports){
'use strict';

/**
 * todolist 操作核心包 core
 */
var CONST = require('../../config/const');
var utils = require('../../libs/utils');
var domPatch = require('../../libs/domPatch');

var TodoCore = function TodoCore() {
  var core = null;
  var env = null;
  var domUtils = null;
  var historyUtils = null;
  var rangeUtils = null;
  var todoRouteForClient = null;
  var todoStyle = null;
  var todoUtils = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
    historyUtils = core.require.historyUtils;
    rangeUtils = core.require.rangeUtils;
    todoRouteForClient = core.require.todoRouteForClient;
    todoStyle = core.require.todoStyle;
    todoUtils = core.require.todoUtils;
  };

  var todoRoute = null;
  var curTouchTarget = null;

  var checkTodo = function checkTodo(checkbox, e) {
    var result = todoUtils.checkTodo(checkbox, todoRoute);
    if (result) {
      if (env.readonly) {
        patchForReader.addModifiedId(result);
      }
      if (e) {
        utils.stopEvent(e);
      }
    }
  };
  var onClickTodoCheck = function onClickTodoCheck(e) {
    if (!todoRoute.hasPermission()) {
      return null;
    }
    var checkbox = e.target;
    if (!domUtils.hasClass(checkbox, CONST.CLASS.TODO_CHECKBOX)) {
      return null;
    }
    var layer = todoUtils.getContainerFromChild(checkbox);
    var parentLayer = todoUtils.getContainerFromChild(layer.parentNode);
    if (parentLayer) {
      todoUtils.fixNewTodo(parentLayer);
    } else {
      todoUtils.fixNewTodo(layer);
    }

    if (env.readonly && !!patchForReader.curCheckbox) {
      return null;
    }
    if (!env.readonly || patchForReader.docLockChecked) {
      checkTodo(checkbox, e);
    } else {
      patchForReader.curCheckbox = checkbox;
      todoRoute.checkDocLock("onCheckDocLock");
    }

    // 修正光标位置
    rangeUtils.setRange(layer, layer.children.length);
  };
  var patchForReader = {
    curCheckbox: null,
    docLockChecked: false,
    modifiedIdList: {},
    htmlToSave: '',
    init: function init() {
      if (env.readonly) {
        patchForReader.modifiedIdList = {};
        var checkList = env.body.querySelectorAll('.' + CONST.CLASS.TODO_CHECKBOX);
        // 1. 旧版的 todoList checkbox 无 id
        // 2. 新版的 todoList 有可能出现 id 重复
        // 所以阅读模式下判定点击的 checkbox 只能依靠序号进行
        for (var i = 0; i < checkList.length; i++) {
          var checkItem = checkList[i];
          checkItem.wizTodoIndex = i;
        }
      }
    },
    addModifiedId: function addModifiedId(checkResult) {
      if (!env.readonly) {
        return;
      }
      var checkbox = checkResult.checkbox;
      var curChecked = checkResult.checked;
      var lastChecked = patchForReader.modifiedIdList[checkbox.wizTodoIndex];
      if (typeof lastChecked === 'boolean' && lastChecked !== curChecked) {
        delete patchForReader.modifiedIdList[checkbox.wizTodoIndex];
      } else {
        patchForReader.modifiedIdList[checkbox.wizTodoIndex] = curChecked;
      }
    },
    getModifiedIdList: function getModifiedIdList() {
      var idList = [];
      for (var k in patchForReader.modifiedIdList) {
        if (patchForReader.modifiedIdList.hasOwnProperty(k)) {
          idList.push({
            id: k,
            checked: patchForReader.modifiedIdList[k]
          });
        }
      }
      return idList;
    },
    modifyDoc: function modifyDoc() {
      var html = '';
      var idList = patchForReader.getModifiedIdList();
      if (idList.length === 0) {
        return html;
      }
      html = todoRoute.getOriginalDoc();
      var iframe = env.doc.getElementById(CONST.ID.IFRAME_FOR_SAVE);
      if (!iframe) {
        iframe = env.doc.createElement('iframe');
        iframe.id = CONST.ID.IFRAME_FOR_SAVE;
        env.body.appendChild(iframe);
      }
      iframe.style.display = 'none';

      var _document = env.doc,
          _win = env.win,
          _body = env.body,
          iframeDocument = iframe.contentDocument,
          isPersonal = todoRoute.isPersonalDocument(),
          checkList = void 0;

      iframeDocument.open("text/html", "replace");
      iframeDocument.write(html);
      iframeDocument.close();

      env.doc = iframeDocument;
      env.win = iframe.contentWindow;
      env.body = iframeDocument.body;
      domPatch.run(env.win);

      //在 iframe 内处理 html
      todoUtils.oldPatch.fixOldTodo();
      todoUtils.fixNewTodo();

      checkList = env.body.querySelectorAll('.' + CONST.CLASS.TODO_CHECKBOX);
      for (var i = idList.length - 1; i >= 0; i--) {
        var id = idList[i].id;
        var checked = idList[i].checked;
        var checkbox = checkList[id];
        if (checkbox) {
          var main = todoUtils.getMainFromChild(checkbox);
          todoUtils.check(main, checked);
          if (!isPersonal) {
            todoUtils.addUserInfo(main, checked, checkbox.id, todoRoute);
          }
        }
      }
      todoUtils.checkTodoStyle(true);

      //获取处理后的 html
      html = domUtils.getContentHtml();
      env.body = _body;
      env.doc = _document;
      env.win = _win;
      env.scrollContainer = domUtils.getScrollContainer();

      env.body.removeChild(iframe);
      return html;
    }
  };

  var _event = {
    bind: function bind() {
      _event.unbind();
      env.event.add(CONST.EVENT.ON_SELECTION_CHANGE, _event.handler.onSelectionChange);
      env.event.add(CONST.EVENT.AFTER_RESTORE_HISTORY, _event.handler.afterRestoreHistory);
      env.event.add(CONST.EVENT.ON_EXEC_COMMAND, _event.handler.onExecCommand);
      env.event.add(CONST.EVENT.ON_PASTE, _event.handler.onPaste);
      env.event.add(CONST.EVENT.AFTER_INSERT_DOM, _event.handler.afterInsertDom); // ios 端 paste 时使用的是 inertHtml 方法

      if (env.client.type.isIOS || env.client.type.isAndroid) {
        env.event.add(CONST.EVENT.ON_TOUCH_END, _event.handler.onTouchEnd);
        env.event.add(CONST.EVENT.ON_TOUCH_START, _event.handler.onTouchStart);
      } else {
        env.event.add(CONST.EVENT.ON_CLICK, _event.handler.onClick);
      }
    },
    unbind: function unbind() {
      env.event.remove(CONST.EVENT.ON_CLICK, _event.handler.onClick);
      env.event.remove(CONST.EVENT.ON_SELECTION_CHANGE, _event.handler.onSelectionChange);
      env.event.remove(CONST.EVENT.ON_TOUCH_END, _event.handler.onTouchEnd);
      env.event.remove(CONST.EVENT.ON_TOUCH_START, _event.handler.onTouchStart);
      env.event.remove(CONST.EVENT.AFTER_RESTORE_HISTORY, _event.handler.afterRestoreHistory);
    },
    handler: {
      afterInsertDom: function afterInsertDom() {
        //粘贴后 需要修正 样式以及 dom 结构
        todoUtils.fixNewTodo();
        todoUtils.checkTodoStyle(false);
      },
      afterRestoreHistory: function afterRestoreHistory() {
        //恢复历史后，需要检查 todoList 的 style 样式
        todoUtils.checkTodoStyle(false);
        todoUtils.fixNewTodo();
        todoStyle.restoreUserAvatarStyle();
      },
      onCheckDocLock: function onCheckDocLock(cancel, needCallAgain) {
        patchForReader.docLockChecked = !needCallAgain;
        if (!cancel) {
          checkTodo(patchForReader.curCheckbox);
        }
        patchForReader.curCheckbox = null;
      },
      onClick: function onClick(e) {
        onClickTodoCheck(e);
      },
      onExecCommand: function onExecCommand() {
        var range = rangeUtils.getRange(),
            parent = void 0,
            checkList = void 0;
        if (!range) {
          return;
        }
        parent = range.collapsed ? range.startContainer : domUtils.getParentRoot([range.startContainer, range.endContainer]);
        parent = domUtils.getBlockParent(parent, true);
        if (!parent) {
          return;
        }
        checkList = parent.querySelectorAll('.' + CONST.CLASS.TODO_CHECKBOX);
        for (var i = 0, j = checkList.length; i < j; i++) {
          todoUtils.fixCheckbox(checkList[i], false);
        }
      },
      onKeyDown: function onKeyDown(e) {
        if (!todoRoute.hasPermission()) {
          return true;
        }
        var range = rangeUtils.getRange();
        if (!range) {
          return true;
        }

        var keyCode = e.keyCode || e.which;
        var start = void 0,
            startOffset = void 0,
            end = void 0,
            endOffset = void 0,
            isAfterCheck = void 0,
            main = void 0,
            container = void 0,
            tmpMain = void 0,
            tmpContainer = void 0,
            tmpEndContainer = void 0,
            isLineEnd = void 0,
            isEmpty = void 0,
            mainParentTag = void 0,
            mainParent = void 0,
            childNodes = void 0,
            dom = void 0;

        var rangeList = void 0;
        if (!range.collapsed) {
          if (keyCode !== 8 && keyCode !== 46 && utils.checkNonTxtKey(e)) {
            return true;
          }

          //将 选中的 checkbox cancelTodo
          rangeList = rangeUtils.getRangeDomList({
            noSplit: true
          });
          if (rangeList && rangeList.list.length > 0) {

            historyUtils.saveSnap(false);

            end = range.endContainer;
            endOffset = range.endOffset;
            if (end.nodeType !== 3) {
              if (range.endOffset === end.childNodes.length) {
                end = domUtils.getLastDeepChild(end);
                endOffset = domUtils.getEndOffset(end);
              } else {
                end = end.childNodes[range.endOffset];
                endOffset = 0;
              }
            }
            tmpEndContainer = todoUtils.getContainerFromChild(end);

            for (var i = rangeList.list.length - 1; i >= 0; i--) {
              dom = rangeList.list[i];
              if (todoUtils.isCheckbox(dom)) {
                tmpContainer = todoUtils.getContainerFromChild(dom);
                tmpMain = todoUtils.getMainFromChild(dom);
                if (tmpMain) {
                  container = tmpMain.parentNode;
                  todoUtils.cancelTodo(container, true);
                }
                //如果 todoList 是 光标范围最后一行，则需要修正 range
                if (tmpEndContainer && tmpContainer === tmpEndContainer) {
                  if (!end.parentNode) {
                    end = container;
                    endOffset = domUtils.getEndOffset(end);
                  }
                  rangeUtils.setRange(range.startContainer, range.startOffset, end, endOffset);
                }
              }
            }
            return true;
          }
          // range.collapse(true);
        }

        isAfterCheck = todoUtils.isCaretAfterCheckbox();
        main = todoUtils.getMainByCaret();
        container = main ? domUtils.getBlockParent(main, false) : todoUtils.getContainerFromChild(range.startContainer);
        isLineEnd = domUtils.getEndOffset(range.endContainer) === range.endOffset;

        // 如果只有一个空的 container，直接删除 class
        if (container && !main && !todoUtils.getCheckbox(container)) {
          domUtils.removeClass(container, CONST.CLASS.TODO_LAYER);
          container = null;
        }

        //isLineEnd 主要用于处理 在行尾 按下 delete 键
        // 回车键 必须要进入后面进行处理
        if (!container && !isLineEnd && keyCode !== 13) {
          return true;
        }

        /**
         * Backspace
         */
        if (keyCode === 8 && isAfterCheck) {
          historyUtils.saveSnap(false);
          todoUtils.cancelTodo(container);
          utils.stopEvent(e);
          return false;
        }

        /**
         * Delete
         */
        if (keyCode === 46) {
          historyUtils.saveSnap(false);
          start = range.startContainer;
          startOffset = range.startOffset;
          rangeUtils.selectCharIncludeFillChar();
          range = rangeUtils.getRange();
          end = range.endContainer;
          // 目前不会有 br 在 todoList 结尾，所以屏蔽以下代码
          // if (range.endOffset === 0) {
          // 避免 br 后直接是 todoList 时，直接把 br 后面的 todoList 删除
          // end = domUtils.getPreviousNode(end);
          // }
          tmpMain = todoUtils.getMainFromChild(end) || todoUtils.getMainInDom(end);
          //恢复 range
          rangeUtils.setRange(start, startOffset);
          if (tmpMain && tmpMain !== main) {
            todoUtils.cancelTodo(tmpMain.parentNode, true);
            return false;
          }
        }

        /**
         * left
         */
        if (keyCode === 37 && isAfterCheck) {
          dom = domUtils.getPreviousNode(container);
          if (dom) {
            rangeUtils.setRange(dom, domUtils.getEndOffset(dom));
            utils.stopEvent(e);
            return false;
          }
        }
        // /**
        //  * right
        //  */
        // if (keyCode === 39) {
        //     return;
        // }
        if (!container || keyCode !== 13 || e.shiftKey) {
          return true;
        }

        historyUtils.saveSnap(false);

        // console.log('isEmptyContainer: ' + todoUtils.isEmptyContainer(container));
        if (todoUtils.isEmptyContainer(container)) {
          //如果当前 todoList 为空，则 取消 todoList
          container.innerHTML = '<br>';
          domUtils.removeClass(container, CONST.CLASS.TODO_LAYER);
          rangeUtils.setRange(container, 1);

          if (domUtils.getParentByTagName(container, ['blockquote', 'ul', 'ol'])) {
            //如果当前 todoList 处于 blockquote、ul、ol 内时执行减少缩进操作
            env.event.call(CONST.EVENT.EXEC_COMMEND, 'outdent', false);
          }
          utils.stopEvent(e);
          return false;
        }

        range.deleteContents();
        todoUtils.fixNewTodo(container);
        //判断光标是否在 userInfo 内
        var isInUserInfo = false;
        var userInfo = todoUtils.getUserInfoInDom(container);
        var lastWithoutUser = void 0;
        // 在 todoList 内按下回车时：
        // 1、没有 userInfo 的时候， 光标后面的内容全部移动到下一行的新 todolist 内
        // 2、有 userInfo 的时候，如果光标在 userInfo 前面，则只将 光标到 userInfo 之间的内容转移
        //    如果光标在 userInfo 内，则将光标到结尾的内容转移
        if (userInfo) {
          lastWithoutUser = domUtils.getPreviousNode(userInfo, false, container);
          if (range.startContainer === userInfo && range.startOffset !== domUtils.getEndOffset(userInfo)) {
            isInUserInfo = true;
          } else if (todoUtils.getUserInfoFromChild(range.startContainer)) {
            isInUserInfo = true;
          }
        } else {
          lastWithoutUser = container;
        }

        range.setEndAfter(isInUserInfo ? container : lastWithoutUser);
        var tmpRange = range.cloneContents();
        var tmpDiv = env.doc.createElement('div');
        tmpRange.appendChild(tmpDiv);
        while (tmpRange.childNodes.length > 1) {
          tmpDiv.appendChild(tmpRange.firstChild);
        }
        isEmpty = domUtils.isEmptyDom(tmpDiv);
        var frag = void 0;
        if (!isEmpty) {
          frag = range.extractContents();
          childNodes = [];
          for (var _i = 0; _i < frag.childNodes.length; _i++) {
            childNodes.push(frag.childNodes[_i]);
          }
          mainParentTag = container === env.body || !domUtils.isBlock(container) ? 'div' : container.tagName;
          mainParent = env.doc.createElement(mainParentTag);
          domUtils.after(mainParent, container);
          main = todoUtils.setTodo(mainParent, todoRoute);
          if (main.length > 0) {
            main = main[0];
          }
          todoUtils.insertToMain(childNodes, main);

          // 如果换行操作的当前 块元素是 todoList，则 frag 内会自动生成 main
          // 必须要插入到 document 内才能正常清理 frag 内 main & block 元素
          for (var _i2 = 0; _i2 < childNodes.length; _i2++) {
            todoUtils.clearBlock(childNodes[_i2]);
          }
          rangeUtils.setRange(main, 1);
        } else {
          mainParent = todoUtils.cloneTodo(container);
          domUtils.after(mainParent, container);
          todoUtils.setTodo(mainParent, todoRoute);
          main = todoUtils.getMainInDom(mainParent);
          dom = domUtils.getLastDeepChild(mainParent);
          if (dom.nodeType === 3) {
            dom.nodeValue = CONST.FILL_CHAR + CONST.FILL_CHAR;
          } else if (domUtils.isSelfClosingTag(dom)) {
            var tmpDom = env.doc.createTextNode(CONST.FILL_CHAR + CONST.FILL_CHAR);
            domUtils.after(tmpDom, dom);
            dom = tmpDom;
          } else {
            dom.appendChild(env.doc.createTextNode(CONST.FILL_CHAR + CONST.FILL_CHAR));
            dom = dom.childNodes[0];
          }
          rangeUtils.setRange(dom, 1);
        }

        utils.stopEvent(e);

        var pageScroll = domUtils.getPageScroll();
        if (main.getBoundingClientRect().top + main.clientHeight > env.doc.documentElement.clientHeight || main.getBoundingClientRect().top + main.clientHeight < 0) {
          var mainX = main.getBoundingClientRect().left + pageScroll.left;
          var mainY = pageScroll.top + main.clientHeight;
          window.scrollTo(mainX, mainY);
        }
      },
      onPaste: function onPaste() {
        setTimeout(function () {
          _event.handler.afterInsertDom();
        }, 300);
      },
      onSelectionChange: function onSelectionChange() {
        var range = rangeUtils.getRange();
        if (!range) {
          return;
        }
        var checkbox = void 0,
            end = void 0,
            endOffset = void 0;
        if (!range.collapsed) {
          end = range.endContainer;
          endOffset = range.endOffset;
        }
        var isBefore = todoUtils.isCaretBeforeCheckbox();
        if (isBefore.enable) {
          checkbox = isBefore.checkbox;
          if (checkbox && checkbox.nextSibling) {
            end = checkbox.nextSibling;
            endOffset = 0;
          } else if (checkbox) {
            end = checkbox.parentNode;
            endOffset = domUtils.getIndex(checkbox) + 1;
          }

          if (!range.collapsed) {
            rangeUtils.setRange(range.startContainer, range.startOffset, end, endOffset);
          } else {
            rangeUtils.setRange(end, endOffset);
          }
        }
      },
      onTouchEnd: function onTouchEnd(e) {
        if (e.target !== curTouchTarget) {
          return;
        }
        curTouchTarget = null;
        onClickTodoCheck(e);
      },
      onTouchStart: function onTouchStart(e) {
        curTouchTarget = e.target;
      }
    }
  };

  this.init = function () {};
  this.on = function () {
    todoUtils.oldPatch.fixOldTodo();
    todoUtils.fixNewTodo();
    patchForReader.init();
    _event.bind();
    if (!todoRoute) {
      todoRoute = todoRouteForClient.getRoute();
    }
    todoUtils.checkTodoStyle(true);
  };
  this.off = function () {
    _event.unbind();
  };
  this.checkTodoStyle = function () {
    todoUtils.checkTodoStyle(false);
  };
  this.closeDocument = function () {
    var html = void 0;
    if (!todoRoute) {
      todoRoute = todoRouteForClient.getRoute();
    }
    /**
     * env.options.pc.pluginModified 是 PC 客户端 插件在阅读状态下修改笔记的标识
     * markdown、mathjax 笔记都不允许进行此操作（由插件自行处理）
     * 普通笔记可以直接获取当前阅读页面的 html 进行保存
     */
    if (env.client.type.isWin && env.options.pc.pluginModified) {
      html = domUtils.getContentHtml();
    } else {
      html = patchForReader.modifyDoc();
    }

    if (!!html && !env.client.type.isIOS && !env.client.type.isMac) {
      todoRoute.saveDoc(html, '');
    }

    if (todoRoute.beforeCloseDoc) {
      todoRoute.beforeCloseDoc();
    }

    patchForReader.init();
    return html;
  };
  this.onCheckDocLock = _event.handler.onCheckDocLock;
  this.onKeyDown = _event.handler.onKeyDown;
  this.setTodo = function () {
    historyUtils.saveSnap(false);
    var todoList = todoUtils.setTodo(null, todoRoute);
  };
  this.setTodoInfo = function (options) {
    if (todoRoute.setTodoInfo) {
      todoRoute.setTodoInfo(options);
    }
  };
};

module.exports = TodoCore;

},{"../../config/const":388,"../../libs/domPatch":398,"../../libs/utils":400}],385:[function(require,module,exports){
'use strict';

/**
 * todolist 客户端适配接口
 */
var base64 = require('../../libs/base64');

var TodoClientRoute = function TodoClientRoute() {
  var core = null;
  var env = null;
  var todoCore = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    todoCore = core.require.todoCore;
  };

  var winExternal = void 0,
      qtEditor = void 0,
      androidWizNote = void 0;

  var RouteForWindows = function RouteForWindows() {
    winExternal = env.win.external;
    var getUserAlias = function getUserAlias() {
      try {
        return winExternal.UserAlias;
      } catch (e) {
        console.error(e);
        return '';
      }
    };
    var getUserAvatarFileName = function getUserAvatarFileName(size) {
      try {
        return winExternal.GetUserAvatarFileName(size);
      } catch (e) {
        console.error(e);
        return '';
      }
    };
    var getUserGuid = function getUserGuid() {
      try {
        return winExternal.GetUserGUID();
      } catch (e) {
        console.error(e);
        return '';
      }
    };
    var hasPermission = function hasPermission() {
      try {
        return !env.readonly || winExternal.WizDocument.CanEdit;
      } catch (e) {
        console.error(e);
        return false;
      }
    };
    var isPersonalDocument = function isPersonalDocument() {
      try {
        return winExternal.WizDocument.IsPersonalDocument();
      } catch (e) {
        console.error(e);
        return false;
      }
    };
    //for Reader
    var checkDocLock = function checkDocLock(callback) {
      if (isPersonalDocument()) {
        todoCore[callback](false, false);
        return;
      }
      try {
        winExternal.ExecuteCommand("OnClickingChecklist", "WizReader.todo." + callback + "({cancel}, {needCallAgain});", "readingnote");
      } catch (e) {
        console.error(e);
      }
    };
    var getOriginalDoc = function getOriginalDoc() {
      try {
        return winExternal.WizDocument.GetHtml();
      } catch (e) {
        console.error(e);
        return '';
      }
    };
    var saveDoc = function saveDoc(html, resources) {
      try {
        winExternal.WizDocument.SetHtml2(html, resources);
      } catch (e) {
        console.error(e);
      }
    };

    this.getUserAlias = getUserAlias;
    this.getUserGuid = getUserGuid;
    this.getUserAvatarFileName = getUserAvatarFileName;
    this.hasPermission = hasPermission;
    this.isPersonalDocument = isPersonalDocument;

    //for Reader
    this.checkDocLock = checkDocLock;
    this.getOriginalDoc = getOriginalDoc;
    this.saveDoc = saveDoc;
  };
  var RouteForWeb = function RouteForWeb() {
    var getUserAlias = function getUserAlias() {
      if (env.options.clientRoute.getUserAlias) {
        return env.options.clientRoute.getUserAlias();
      }
      return '';
    };
    var getUserAvatarFileName = function getUserAvatarFileName() {
      if (env.options.clientRoute.getUserAvatarFileName) {
        return env.options.clientRoute.getUserAvatarFileName();
      }
      return '';
    };
    var getUserGuid = function getUserGuid() {
      if (env.options.clientRoute.getUserGuid) {
        return env.options.clientRoute.getUserGuid();
      }
      return '';
    };
    var hasPermission = function hasPermission() {
      if (env.options.clientRoute.hasPermission) {
        return env.options.clientRoute.hasPermission();
      }
      return false;
    };
    var isPersonalDocument = function isPersonalDocument() {
      if (env.options.clientRoute.isPersonalDocument) {
        return env.options.clientRoute.isPersonalDocument();
      }
      return false;
    };
    // for Reader
    var checkDocLock = function checkDocLock(callbackName) {
      if (env.options.clientRoute.checkDocLock) {
        return env.options.clientRoute.checkDocLock(function (cancel, needCallAgain) {
          todoCore[callbackName](cancel, needCallAgain);
        });
      }
    };
    var getOriginalDoc = function getOriginalDoc() {
      if (env.options.clientRoute.getOriginalDoc) {
        return env.options.clientRoute.getOriginalDoc();
      }
      return env.body.outerHTML;
    };
    var saveDoc = function saveDoc(html, resources) {
      if (env.options.clientRoute.saveDoc) {
        return env.options.clientRoute.saveDoc(html, resources);
      }
    };

    this.getUserAlias = getUserAlias;
    this.getUserAvatarFileName = getUserAvatarFileName;
    this.getUserGuid = getUserGuid;
    this.hasPermission = hasPermission;
    this.isPersonalDocument = isPersonalDocument;
    // for Reader
    this.checkDocLock = checkDocLock;
    this.getOriginalDoc = getOriginalDoc;
    this.saveDoc = saveDoc;
  };
  var RouteForMac = function RouteForMac() {
    qtEditor = env.win.WizQtEditor;

    var getUserAlias = function getUserAlias() {
      return qtEditor.userAlias;
    };
    var getUserAvatarFileName = function getUserAvatarFileName(size) {
      return qtEditor.userAvatarFilePath;
    };
    var getUserGuid = function getUserGuid() {
      return qtEditor.userGuid;
    };
    var hasPermission = function hasPermission() {
      return !env.readonly || qtEditor.hasEditPermissionOnCurrentNote;
    };
    var isPersonalDocument = function isPersonalDocument() {
      return qtEditor.isPersonalDocument;
    };
    // for Reader
    var saveDoc = function saveDoc(html, resources) {};
    var checkDocLock = function checkDocLock(callback) {
      qtEditor.clickingTodoCallBack.connect(todoCore[callback]);
      return qtEditor.checkListClickable();
    };
    var getOriginalDoc = function getOriginalDoc() {
      return qtEditor.currentNoteHtml;
    };

    this.getUserAlias = getUserAlias;
    this.getUserAvatarFileName = getUserAvatarFileName;
    this.getUserGuid = getUserGuid;
    this.hasPermission = hasPermission;
    this.isPersonalDocument = isPersonalDocument;
    // for Reader
    this.checkDocLock = checkDocLock;
    this.getOriginalDoc = getOriginalDoc;
    this.saveDoc = saveDoc;
  };
  var RouteForAndroid = function RouteForAndroid() {
    androidWizNote = env.win.WizNote;

    var getUserAlias = function getUserAlias() {
      return androidWizNote.getUserAlias();
    };
    var getUserAvatarFileName = function getUserAvatarFileName(size) {
      return androidWizNote.getUserAvatarFileName(size);
    };
    var getUserGuid = function getUserGuid() {
      return androidWizNote.getUserGuid();
    };
    var hasPermission = function hasPermission() {
      return !env.readonly || androidWizNote.hasPermission();
    };
    var isPersonalDocument = function isPersonalDocument() {
      return androidWizNote.isPersonalDocument();
    };
    // for Reader
    var beforeCloseDoc = function beforeCloseDoc() {
      androidWizNote.onWizTodoReadCheckedClose();
    };
    var checkDocLock = function checkDocLock(callback) {
      androidWizNote.checkDocLock();
    };
    var getOriginalDoc = function getOriginalDoc() {
      return androidWizNote.getDocHtml();
    };
    var saveDoc = function saveDoc(html, resources) {
      androidWizNote.setDocHtml(html, resources);
    };

    this.getUserAlias = getUserAlias;
    this.getUserAvatarFileName = getUserAvatarFileName;
    this.getUserGuid = getUserGuid;
    this.hasPermission = hasPermission;
    this.isPersonalDocument = isPersonalDocument;
    // for Reader
    this.beforeCloseDoc = beforeCloseDoc;
    this.checkDocLock = checkDocLock;
    this.getOriginalDoc = getOriginalDoc;
    this.saveDoc = saveDoc;
  };
  var RouteForIOS = function RouteForIOS() {
    var _this = this;

    var getUserAlias = function getUserAlias() {
      return _this.userAlias;
    };
    var getUserAvatarFileName = function getUserAvatarFileName(size) {
      return _this.avatarFileName;
    };
    var getUserGuid = function getUserGuid() {
      return _this.userGuid;
    };
    var hasPermission = function hasPermission() {
      return !env.readonly || _this._hasPermission;
    };
    var isPersonalDocument = function isPersonalDocument() {
      return _this.personalDocument;
    };
    var setDocHtml = function setDocHtml(html, resources) {
      env.win.location.href = "wiztodolist://setDocHtml/" + "?html=" + html + "&resource=" + resources;
    };
    var setTodoInfo = function setTodoInfo(options) {
      _this.userAlias = options.alias;
      _this.userGuid = options.userGuid;
      _this.avatarFileName = options.avatar;
      _this.personalDocument = options.isPersonal === 'true';
      _this._hasPermission = options.hasPermission === 'true';
      _this.originalHtml = base64.decode(options.docHtml);
    };
    // for Reader
    var checkDocLock = function checkDocLock(callback) {
      env.win.location.href = "wiztodolist://tryLockDocument/" + "?callback=" + callback;
    };
    var getOriginalDoc = function getOriginalDoc() {
      return _this.originalHtml;
    };

    this.getUserAlias = getUserAlias;
    this.getUserAvatarFileName = getUserAvatarFileName;
    this.getUserGuid = getUserGuid;
    this.hasPermission = hasPermission;
    this.isPersonalDocument = isPersonalDocument;
    this.setTodoInfo = setTodoInfo;
    // for Reader
    this.checkDocLock = checkDocLock;
    this.getOriginalDoc = getOriginalDoc;

    this.userAlias = '';
    this.userGuid = '';
    this.avatarFileName = '';
    this.personalDocument = false;
    this._hasPermission = false;
    this.originalHtml = "";
  };

  this.getRoute = function () {
    var route = null;
    if (env.client.type.isWin) {
      route = new RouteForWindows();
    } else if (env.client.type.isMac) {
      route = new RouteForMac();
    } else if (env.client.type.isIOS) {
      route = new RouteForIOS();
    } else if (env.client.type.isAndroid) {
      route = new RouteForAndroid();
    } else {
      route = new RouteForWeb();
    }
    return route;
  };
  this.setQtEditor = function () {
    qtEditor = env.win.WizQtEditor;
  };
};

module.exports = TodoClientRoute;

},{"../../libs/base64":396}],386:[function(require,module,exports){
'use strict';

/**
 * todoList 相关样式处理
 */
var CONST = require('../../config/const');

var ImgFile = {
  // todoChecked: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RjY1OTU4MUZCRjk3MTFFM0JENDdFMDk4NDNCMkZDMTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RjY1OTU4MjBCRjk3MTFFM0JENDdFMDk4NDNCMkZDMTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpGNjU5NTgxREJGOTcxMUUzQkQ0N0UwOTg0M0IyRkMxNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpGNjU5NTgxRUJGOTcxMUUzQkQ0N0UwOTg0M0IyRkMxNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqkphX0AAAJZSURBVHjaYvz//z/DQAImhgEGLNu2bYNzCj+7jpgQaAdiUNz/Z4EKqAJxRz/vbhcgzUeBwSBDE4AhuQiPh6cCcQY8CoBYHYhPALEAFXxWiMdyViCeD8TRSGLdIAe0QS3/BcSlQLwEaMg7Kgc5BxCvAmJfJLGlQFwOcoALVKAMaPEkGsQ3LxBvBGJHJLF9QJwESwOwOF9MA8uFgRiUzcyQxM4AcRA0xBlYkCSoHeySQLwbiLWRxO4AsRcQf0ROhLQAikC8B4iVkMReA7EnlCZYDtQDcT+Z5QTIx0fQLP8CTYB3MEpCHJY3QNlyQBwDxN+JtNwEiHdA4x4GQHHtD8QniS0JxZHYoMSyF4hFiLDcAZq6hdEKpiSoONFFcS6aBksgPgbEKngs94Gmdl408SpofiepLvgL9TlyfIGK6uNAbIFFfSQQrwNiTjTxLlDxjiwALOoZia2MPkJT7EckMRFoyAQhiYHK9CXQYpYBrZSrwGJuPym14R2oZX+RxEC+XA3E+aBiFIinYTEDXsqh+b4Vqo9gLkA3LBdqEbKjJ+BQfxq5lMOSHshqD0yHYkIAFGLeaNFGtQZJLr6shKuUo6YDsOUMGPiMq5SjdpMMW84AxXUArlKOFm1C5JxBsJQjqlVMhh5YzuAnVMrRygEMROYKogDj1q1bYQUGI42b4ij2eHl5YaQBIRpaLoQvEX6CsmNp6IAUpIYJhgP2INVeeUAsSEWLBaFmNkP5u7A5oBqIPwAxGxBPhDZO/1MJv4OayQa1oxqbA25A6/l10FKN2uAz1GwLqF0oACDAAGu/mbMal6iXAAAAAElFTkSuQmCC',
  todoChecked: 'data:text/xml;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUYxRkNCNDRFNUYzMTFFN0I3MjU4OUZFNDhFRjQzMjQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUYxRkNCNDVFNUYzMTFFN0I3MjU4OUZFNDhFRjQzMjQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5RjFGQ0I0MkU1RjMxMUU3QjcyNTg5RkU0OEVGNDMyNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5RjFGQ0I0M0U1RjMxMUU3QjcyNTg5RkU0OEVGNDMyNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PoB3J04AAAJhSURBVHja7JjLK0RRHMdnhFiM55RsFJGFrcSOGguDaHZCSRY2Q7PwiAUlj1gMCkvF2FDKZpLXSh7xB1jMf6AmY5RSGt9Tv6vjdO5j7twzzcKvPt07v+ae873n/B5nxp1KpVy5ZHmuHLOcE5QvOqLR6O99KNmZLR2rYFYqiKwBrIU9lz5cSzKYiAXoCF7swGCHdsC47grBGsEDKHPgzUMGYgrAPhjkfBsyQSsk5gtMgQgGjTu8RUXgGPRyviMwIxPko+s0hGwriBcPOAMdnO8GjLItlgnSYuZQgZhKljeghfM9gwDtiG5QM3N6m6rBJWjifDHgBwmjoFZhteAK1HG+V9BF17QL4wII2yykbEVuBTEfFNAx08KoI2aR7mvAEPi0KKYZnFPsaMZipQ882m0dVdw9C75r4LXwXDtlT6VQKEfJb7uXBYUB2sAdqDd4poeyySP456jeZNRcv2llYkJruQetku8PgFNQLPjXWTviHWhNbrvdPkEZkeB8Xlq5AOdjPSlCbcElVOFZybjhTI4fMZr8m/OxVTgBk6zsg13JmL9VWFidZXou7SwTBw/SxPxLbep8/4mvwpJ4cuSAtkdYWdFuYZuVnRiDRqmrV4VVCpJlnmZJvSqs+kwtyzwWK/16VTgbh3w+80yrsK1Dvg3TMq/UrApnS5DLYtZZMrf4yxU/gzSHW/EZ6c88fr/fNIYqFIqpSCeo3+k6rFDQGHdQMxV0xXXnCVDuoJByGnOJPl9YETQP3kAh2KLDfsoh4jRmIc0xb0XQC51zTqnqOm1JGruV5jLOsv+/Y/4FpWk/AgwACweeMaBPu0MAAAAASUVORK5CYII=',
  // todoUnChecked: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RDcyODY1Q0NCRjk2MTFFMzhGNTBEODZBNTIzNzhDQjQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RDcyODY1Q0RCRjk2MTFFMzhGNTBEODZBNTIzNzhDQjQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpENzI4NjVDQUJGOTYxMUUzOEY1MEQ4NkE1MjM3OENCNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpENzI4NjVDQkJGOTYxMUUzOEY1MEQ4NkE1MjM3OENCNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PpXYwTEAAAD5SURBVHjaYvz//z/DQAImhgEGA+4Alm3bttHdUi8vL4wQUAXitUD8EYj/Uxl/hJqtijUEgFgdiE8AsQCNPMwHxEFA7ATEFkB8Ez0NtEEt/wXE+UAsDMSMVMJCUDN/Qe1owxYCLlB2GRBPorLv30PN5ATiDiB2w5YL+KDsxTRMd7OhNA++bPiOhg54N1oQjTpg1AGjDhh1wKgDRh0w6oAh4QAhGtojhM8Bn6DsWBo6IAVKf8HmgD1QdhcQ5wGxIBUtFoSa2Qzl78LmgGog/gDEbEA8EdqApFav6B3UTDaoHdXYHHAD2mNZB8SfaRD8n6FmW0DtQgEAAQYAS2BO8CD/bL4AAAAASUVORK5CYII='
  todoUnChecked: 'data:text/xml;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QjlFNzg2NjRFNUYzMTFFN0IyNkY5NzZGNEEyNTU3NEYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QjlFNzg2NjVFNUYzMTFFN0IyNkY5NzZGNEEyNTU3NEYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpCOUU3ODY2MkU1RjMxMUU3QjI2Rjk3NkY0QTI1NTc0RiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpCOUU3ODY2M0U1RjMxMUU3QjI2Rjk3NkY0QTI1NTc0RiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PohRJcgAAAEHSURBVHja7JgxCsJAEEWNSEAQ0XgG8QrWIhYp7e2stRMhpRDETltLe8sU4gE8guIdokQrm/UHvoUWZsVdEJmBx5AUMy87m5DEUUrlfinyuR8LEcqKwuuJKIrSVAdT0AZlwz0TsAVjcPR9/70QogF2oGJpEdIL7IIWaIJD1shCytzAENSAYwiPNW/sEWaOjGNKYwQWhlfnxJpFbomOzqZ+7JmVxb27ZC59cpfFFoVieQ6JkAiJkAiJkAiJkAj9gZBnsa/3iVDC3LMo1Ge+6ghtmWdgAKoGRaqsOeHxRkcoAGfggjlfyJUhYtZ02SPQEdrzi3INLhbGdWHtJns9hSP/h0Toy7gLMABy5T6ChFra5QAAAABJRU5ErkJggg=='
};
var CSS = {
  // PC 客户端使用的 Chrome 内核 49.0.2623.110，如果 span 设置 position：relative 会导致 span 内 img 的 offsetTop 异常
  common: '.' + CONST.CLASS.TODO_MAIN + ' {padding-left: 12px;line-height:30px;}' + 'li > .' + CONST.CLASS.TODO_MAIN + ' {padding-left: 0}' + '.' + CONST.CLASS.TODO_CHECKED + ' {color: #666;}' + '.' + CONST.CLASS.TODO_UNCHECKED + ' {text-decoration: initial;}' + '.' + CONST.CLASS.TODO_CHECKED + ' .' + CONST.CLASS.TODO_CHECKBOX + ' {background-image:url(' + ImgFile.todoChecked + ')}' + '.' + CONST.CLASS.TODO_UNCHECKED + ' .' + CONST.CLASS.TODO_CHECKBOX + ' {background-image:url(' + ImgFile.todoUnChecked + ')}' + '.' + CONST.CLASS.TODO_CHECKBOX + ' {border-radius:0;position:relative;top:-1px;vertical-align:middle;border:0;background-color:transparent;outline:none;width:18px !important; height:18px !important; cursor:default; padding:0px 10px 0px 5px;-webkit-user-select: none;background-size:18px;background-repeat:no-repeat;background-position:5px;box-sizing:initial;}' + '.' + CONST.CLASS.TODO_AVATAR + ' {border:0;background-color:transparent;outline:none;width:20px !important; height: 20px !important; vertical-align: -20%; padding:0; margin:0 10px 0 0; border-radius:100%;background-size:20px;background-repeat:no-repeat;}' + '.' + CONST.CLASS.TODO_USER_INFO + ' {padding-left: 20px;}' +
  //单独出来主要为了兼容旧的 todoList
  'input.' + CONST.CLASS.TODO_AVATAR + ' {position:relative;top:-4px;}' + '.' + CONST.CLASS.TODO_ACCOUNT + ', .' + CONST.CLASS.TODO_DATE + ' { color: #666; }'
};

var TodoStyle = function TodoStyle() {
  var _this = this;

  var core = null;
  var env = null;
  var domUtils = null;
  var wizStyle = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    domUtils = core.require.domUtils;
    wizStyle = core.require.wizStyle;
  };

  var TodoStyleMap = {};

  var getGuidFromStyleId = function getGuidFromStyleId(styleId) {
    var guidReg = new RegExp('^' + CONST.ID.TODO_AVATAR_STYLE + '(.*)$', 'i');
    return styleId.replace(guidReg, '$1');
  };

  this.insertTodoStyle = function (isForced) {
    _this.removeTodoOldStyle();
    var s = env.doc.getElementById(CONST.ID.TODO_STYLE);
    if (isForced || !s) {
      wizStyle.replaceStyleById(CONST.ID.TODO_STYLE, CSS.common, false);
    }
    _this.removeUnUsedTodoStyle();

    var tmpTagId = 'wiz_todo_checkbox_img_preview';
    if (env.client.type.isIOS && !env.body.querySelector('#' + tmpTagId)) {
      // todo 等此 bug 消失后，可删除此部分代码
      // IOS 新内核 bug [5.0 (iPhone; CPU iPhone OS 11_2 like Mac OS X) AppleWebKit/604.4.7 (KHTML, like Gecko) Mobile/15C114]
      // 如果只有一种 checkbox ，会导致改变状态后，看不到图片，预先缓存两种 checkbox 图片进入 页面，可避免此问题
      var tmpTag = env.doc.createElement(CONST.TAG.TMP_TAG);
      var imgChecked = env.doc.createElement('img');
      var imgUnChecked = env.doc.createElement('img');
      imgChecked.src = ImgFile.todoChecked;
      imgUnChecked.src = ImgFile.todoUnChecked;
      domUtils.setContenteditable(tmpTag, false);
      domUtils.css(tmpTag, {
        width: 0,
        height: 0,
        opacity: 0,
        overflow: 'hidden',
        display: 'inline-block'
      });
      tmpTag.id = tmpTagId;
      tmpTag.appendChild(imgChecked);
      tmpTag.appendChild(imgUnChecked);
      env.doc.body.appendChild(tmpTag);
    }
  };
  this.removeTodoOldStyle = function () {
    wizStyle.removeStyleById(CONST.ID.TODO_STYLE_OLD);
  };
  this.removeTodoStyle = function () {
    _this.removeTodoOldStyle();
    var style = env.doc.getElementById(CONST.ID.TODO_STYLE);
    domUtils.remove(style);
    var styleList = env.doc.querySelectorAll('style');
    for (var i = styleList.length - 1; i >= 0; i--) {
      style = styleList[i];
      if (style.id && style.id.indexOf(CONST.ID.TODO_AVATAR_STYLE) === 0) {
        var guid = getGuidFromStyleId(style.id);
        TodoStyleMap[guid] = style.innerHTML;
        domUtils.remove(style);
      }
    }
  };
  this.removeUnUsedTodoStyle = function (guid) {
    var styleList = env.doc.querySelectorAll('style'),
        style = void 0,
        sId = void 0,
        sClass = void 0,
        userAvatar = void 0;

    if (guid) {
      sId = CONST.ID.TODO_AVATAR_STYLE + guid;
      sClass = CONST.CLASS.TODO_USER_AVATAR + guid;
      userAvatar = env.doc.querySelector('.' + sClass);
      style = env.doc.getElementById(sId);
      if (style && !userAvatar) {
        TodoStyleMap[guid] = style.innerHTML;
        domUtils.remove(style);
      }
      return;
    }

    for (var i = styleList.length - 1; i >= 0; i--) {
      style = styleList[i];
      sId = style.id;
      if (sId && sId.indexOf(CONST.ID.TODO_AVATAR_STYLE) === 0) {
        guid = getGuidFromStyleId(sId);
        if (!env.body.querySelector('.' + CONST.CLASS.TODO_USER_AVATAR + guid)) {
          TodoStyleMap[guid] = style.innerHTML;
          domUtils.remove(style);
        }
      }
    }
  };
  /**
   * 专门用于 redo / undo 操作时，恢复 avatar 样式处理
   */
  this.restoreUserAvatarStyle = function () {
    for (var guid in TodoStyleMap) {
      if (TodoStyleMap.hasOwnProperty(guid)) {
        var styleId = CONST.ID.TODO_AVATAR_STYLE + guid;
        if (!env.doc.querySelector('#' + styleId) && env.body.querySelector('.' + CONST.CLASS.TODO_USER_AVATAR + guid)) {
          wizStyle.replaceStyleById(styleId, TodoStyleMap[guid], false);
        }
      }
    }
  };
};

module.exports = TodoStyle;

},{"../../config/const":388}],387:[function(require,module,exports){
'use strict';

/**
 * todolist 基本工具包
 */
var CONST = require('../../config/const');
var base64 = require('../../libs/base64');
var utils = require('../../libs/utils');

// 1像素 的透明图片
var checkboxImg = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';

var TodoUtils = function TodoUtils() {
  var _this = this;

  var core = null;
  var env = null;
  var lang = null;
  var blockUtils = null;
  var codeUtils = null;
  var domUtils = null;
  var historyUtils = null;
  var rangeUtils = null;
  var todoStyle = null;
  var wizStyle = null;

  this.initCore = function (_core) {
    core = _core;
    env = core.env;
    lang = core.lang;
    blockUtils = core.require.blockUtils;
    codeUtils = core.require.codeUtils;
    domUtils = core.require.domUtils;
    historyUtils = core.require.historyUtils;
    rangeUtils = core.require.rangeUtils;
    todoStyle = core.require.todoStyle;
    wizStyle = core.require.wizStyle;
  };

  this.addUserInfo = function (main, isChecked, todoId, todoRoute) {
    if (!main) {
      return;
    }

    var userGuid = void 0,
        userName = void 0,
        avatarUrl = void 0,
        dt = void 0,
        userHtml = void 0,
        span = void 0,
        next = void 0;

    userGuid = _this.deleteUserInfo(main.parentNode);
    if (!isChecked) {
      todoStyle.removeUnUsedTodoStyle(userGuid);
      return;
    }

    userGuid = todoRoute.getUserGuid();
    userName = todoRoute.getUserAlias();
    avatarUrl = todoRoute.getUserAvatarFileName(CONST.CSS.TODO_LIST.IMG_WIDTH);
    dt = _this.getTime();
    _this.setUserAvatarStyle(userGuid, avatarUrl);
    userHtml = _this.getUserInfoHtml(userGuid, userName, dt);

    span = env.doc.createElement('span');
    domUtils.addClass(span, CONST.CLASS.TODO_USER_INFO);
    span.innerHTML = userHtml;
    var attr = {};
    attr[CONST.ATTR.TODO_ID] = todoId;
    domUtils.attr(span, attr);

    for (var i = main.childNodes.length - 1; i >= 0; i--) {
      var child = main.childNodes[i];
      if (domUtils.isTag(child, 'br')) {
        main.removeChild(child);
      }
    }
    next = main.nextElementSibling;
    while (next) {
      if (_this.isMain(next)) {
        main.parentElement.insertBefore(span, next);
        break;
      }
      if (domUtils.isTag(next, 'br')) {
        main.parentElement.insertBefore(span, next);
        break;
      }
      next = next.nextElementSibling;
    }
    if (!next) {
      main.parentElement.appendChild(span);
    }
    if (!span.hasChildNodes()) {
      span.appendChild(env.doc.createElement('br'));
    }
    rangeUtils.setRange(span, span.childNodes.length);
  };
  /**
   * 判断 dom 是否可以当作 main 容器
   */
  this.canBeContainer = function (dom) {
    return !domUtils.isTag(dom, ['body', 'blockquote', 'td', 'th']) && domUtils.isBlock(dom);
  };
  this.cancelTodo = function (container, noSetRange) {
    if (!container) {
      return;
    }
    var range = rangeUtils.getRange(),
        start = void 0,
        startOffset = void 0,
        main = void 0,
        userGuid = void 0;
    start = range ? range.startContainer : null;
    startOffset = range ? range.startOffset : 0;
    main = _this.getMainInDom(container);
    userGuid = _this.deleteUserInfo(container);
    todoStyle.removeUnUsedTodoStyle(userGuid);
    _this.deleteMain(main);
    domUtils.removeClass(container, CONST.CLASS.TODO_LAYER);
    domUtils.removeClass(container, CONST.CLASS.TODO_CHECKED);
    domUtils.removeClass(container, CONST.CLASS.TODO_UNCHECKED);
    var isEmpty = domUtils.isEmptyDom(container);
    if (isEmpty && !container.querySelector('br')) {
      container.innerHTML = '<br/>';
    }
    if (!noSetRange) {
      if (!start || !start.parentNode) {
        start = container;
        startOffset = 0;
      }
      rangeUtils.setRange(start, startOffset);
    }
    //修正 todoList style
    _this.checkTodoStyle(false);
  };
  this.check = function (main, isChecked) {
    var layer = _this.getContainerFromChild(main);
    if (isChecked) {
      domUtils.removeClass(layer, CONST.CLASS.TODO_UNCHECKED);
      domUtils.addClass(layer, CONST.CLASS.TODO_CHECKED);
    } else {
      domUtils.removeClass(layer, CONST.CLASS.TODO_CHECKED);
      domUtils.addClass(layer, CONST.CLASS.TODO_UNCHECKED);
    }
    var check = _this.getCheckbox(main);
    var state = isChecked ? 'checked' : 'unchecked';
    var attr = {};
    attr[CONST.ATTR.TODO_CHECK] = state;
    domUtils.attr(check, attr);
  };
  this.checkTodo = function (checkbox, todoRoute) {
    var result = {
      checkbox: null,
      checked: false
    };

    historyUtils.saveSnap(false);

    var main = _this.getMainFromChild(checkbox),
        isChecked = void 0;
    if (!main || main.children[0] !== checkbox) {
      _this.fixCheckbox(checkbox, false);
    }

    isChecked = checkbox.getAttribute(CONST.ATTR.TODO_CHECK) !== 'checked';
    _this.check(main, isChecked);
    result.checkbox = checkbox;
    result.checked = isChecked;

    if (!todoRoute.isPersonalDocument()) {
      _this.addUserInfo(main, isChecked, checkbox.id, todoRoute);
    }

    return result;
  };
  this.checkTodoStyle = function (isForced) {
    var todoObj = env.doc.querySelector('.' + CONST.CLASS.TODO_CHECKBOX);
    if (todoObj) {
      todoStyle.insertTodoStyle(isForced);
    } else {
      todoStyle.removeTodoStyle();
    }
  };
  this.clearBlock = function (dom) {
    if (!dom || dom.nodeType !== 1 && dom.nodeType !== 3 && dom.nodeType !== 11) {
      return false;
    }
    for (var i = 0; i < dom.childNodes.length; i++) {
      var child = dom.childNodes[i];
      if (_this.clearBlock(child) && child !== dom.childNodes[i]) {
        i--;
      }
    }

    var isFragment = dom.nodeType === 11,

    // isMain = isFragment ? false : this.isMain(dom),
    isTodoTag = isFragment ? false : _this.isTodoTag(dom),
        isBlock = isFragment ? false : domUtils.isBlock(dom);
    if (isBlock && domUtils.isEmptyDom(dom)) {
      //为保证 样式 正常传递， 不能随便 removeChild
      if (dom.children.length > 0) {
        domUtils.peelDom(dom);
      } else {
        domUtils.remove(dom);
        return true;
      }
    } else if (isBlock || isTodoTag) {
      domUtils.peelDom(dom);
    }
    return false;
  };
  /**
   * 清理 TodoList 的 class
   */
  this.clearTodoClass = function (dom) {
    if (!dom) {
      return;
    }
    domUtils.removeClass(dom, [CONST.CLASS.TODO_ACCOUNT, CONST.CLASS.TODO_AVATAR, CONST.CLASS.TODO_DATE, CONST.CLASS.TODO_LAYER, CONST.CLASS.TODO_MAIN, CONST.CLASS.TODO_CHECKED, CONST.CLASS.TODO_UNCHECKED, CONST.CLASS.TODO_USER_INFO]);
  };
  /**
   * 复制 todo
   */
  this.cloneTodo = function (container) {
    if (!container) {
      return null;
    }
    var _container = void 0,
        _last = void 0,
        main = void 0,
        last = void 0;
    _container = domUtils.clone(container, true);
    main = _this.getMainInDom(container);
    if (!main) {
      return null;
    }
    domUtils.removeClass(_container, CONST.CLASS.TODO_CHECKED);
    domUtils.addClass(_container, CONST.CLASS.TODO_UNCHECKED);

    var tmp = container,
        _tmp = _container;
    while (tmp && tmp.childNodes && tmp.childNodes.length) {
      last = tmp.childNodes[tmp.childNodes.length - 1];

      // 复制 todolist 时， 不复制 块级元素、自闭和标签
      while (!!last && (last.nodeType === 3 && last.nodeValue.replace(CONST.FILL_CHAR_REG, '').length === 0 || domUtils.isBlock(last) || domUtils.isSelfClosingTag(last))) {
        last = last.previousSibling;
      }

      if (!last || _this.isCheckbox(last)) {
        _last = env.doc.createTextNode('');
        last = null;
      } else {
        _last = domUtils.clone(last, true);
      }
      _tmp.appendChild(_last);
      _tmp = _last;
      tmp = last;
    }
    return _container;
  };
  this.deleteMain = function (main) {
    return domUtils.peelDom(main, function (dom) {
      return !_this.isMain(dom) && !_this.isCheckbox(dom);
    });
  };
  this.deleteUserInfo = function (container) {
    var userGuid = '';
    var main = _this.getMainInDom(container);
    var userAvatar = container.querySelector('.' + CONST.CLASS.TODO_AVATAR),
        userClass = userAvatar ? userAvatar.className : '',
        guidReg = new RegExp('^(.*' + CONST.CLASS.TODO_USER_AVATAR + ')([^ ]*)(.*)$', 'i');

    if (userClass.indexOf(CONST.CLASS.TODO_USER_AVATAR) > -1) {
      userGuid = userClass.replace(guidReg, '$2');
    }

    var nextSib = main ? main.nextElementSibling : container.firstChild;
    while (nextSib) {
      if (_this.isMain(nextSib)) {
        break;
      }
      if (_this.isUserInfo(nextSib)) {
        var tmpNode = nextSib;
        nextSib = nextSib.nextElementSibling;
        container.removeChild(tmpNode);
        continue;
      }
      nextSib = nextSib.nextElementSibling;
    }
    return userGuid;
  };
  /**
   * 修正 dom 异常的 checkbox & 由于 execCommand 生成列表时造成的 dom 异常
   */
  this.fixCheckbox = function (checkItem, isForOld) {
    if (!checkItem) {
      return;
    }
    // 修正缺失 的 id
    if (!checkItem.id) {
      checkItem.id = _this.getCheckId();
    }
    // 清理多余样式（主要避免 粘贴操作带来的影响）
    domUtils.attr(checkItem, {
      'style': null
    });

    //1、ios 端 对于 input type=text 操作异常，
    //2、如果换成 type=button 必须添加 contenteditable = false ；但这样又导致光标上下移动时行为异常
    //3、必须使用自闭和标签，否则会导致可以在 checkbox 内输入内容
    // 因此必须重新使用 img 作为 checkbox 的容器
    if (domUtils.isTag(checkItem, 'input')) {
      var img = env.doc.createElement('img');
      img.id = checkItem.id;
      img.className = checkItem.className;
      img.src = checkboxImg;
      var attr = {};
      attr[CONST.ATTR.TODO_CHECK] = checkItem.getAttribute(CONST.ATTR.TODO_CHECK);
      domUtils.attr(img, attr);
      domUtils.before(img, checkItem);
      domUtils.remove(checkItem);
      checkItem = img;
    }

    if (!isForOld && _this.getMainFromChild(checkItem)) {
      return;
    }

    var container = domUtils.getBlockParent(checkItem),
        canBeContainer = _this.canBeContainer(container),
        main = env.doc.createElement('span'),
        newContainer = void 0,
        next = void 0,
        tmpNext = void 0,
        stopInsert = false,
        dom = void 0;
    main.className = (isForOld ? CONST.CLASS.TODO_LABEL_OLD : CONST.CLASS.TODO_MAIN) + ' ' + CONST.CLASS.TODO_UNCHECKED;

    newContainer = env.doc.createElement(canBeContainer ? container.tagName : 'div');
    if (canBeContainer) {
      domUtils.after(newContainer, container);
    } else {
      domUtils.before(newContainer, checkItem);
    }
    newContainer.appendChild(main);

    next = checkItem;
    while (next) {
      tmpNext = next.nextSibling;
      if (domUtils.isBlock(next)) {
        if (canBeContainer) {
          stopInsert = true;
          dom = newContainer.nextSibling;
        } else {
          break;
        }
      }
      if (stopInsert) {
        domUtils.before(next, dom);
      } else if (_this.isUserInfo(next)) {
        domUtils.after(next, main);
      } else {
        main.appendChild(next);
      }
      next = tmpNext;
    }

    domUtils.addClass(newContainer, CONST.CLASS.TODO_LAYER);
    // 主要用于修正 将 todoList 设置为 ul/ol 时产生的 错误
    var layer = _this.getContainerFromChild(newContainer.parentNode);
    if (layer) {
      domUtils.removeClass(layer, CONST.CLASS.TODO_LAYER);
    }

    //避免 产生多余的 列表行
    if (canBeContainer && domUtils.isEmptyDom(container)) {
      domUtils.remove(container);
    }
  };
  /**
   * 清理 main 内多余 dom （主要针对 特殊字符 or <br> 结尾的dom）
   */
  this.fixMain = function (main) {
    if (!main) {
      return;
    }
    var last = domUtils.getLastDeepChild(main),
        check = _this.getCheckbox(main),
        parent = void 0,
        i = void 0;

    // 不存在 checkbox 的 main 删除 main class
    if (!check) {
      domUtils.removeClass(main, CONST.CLASS.TODO_MAIN);
    }

    // 清理多余样式（主要避免 粘贴操作带来的影响）
    domUtils.attr(main, { 'style': null });

    //保证 main 的 parent 就是 layer
    parent = _this.getContainerFromChild(main);
    if (parent && parent !== main && parent !== main.parentNode) {
      try {
        parent.appendChild(main);
      } catch (e) {
        console.error(e);
      }
    }
    // 2017 将 checked、unchecked class 转移到 layer ，避免 dom 结构不一致导致 checked 的文本不变灰色
    if (domUtils.hasClass(main, CONST.CLASS.TODO_CHECKED)) {
      domUtils.addClass(parent, CONST.CLASS.TODO_CHECKED);
      domUtils.removeClass(main, CONST.CLASS.TODO_CHECKED);
    } else if (domUtils.hasClass(main, CONST.CLASS.TODO_UNCHECKED)) {
      domUtils.addClass(parent, CONST.CLASS.TODO_UNCHECKED);
      domUtils.removeClass(main, CONST.CLASS.TODO_UNCHECKED);
    }

    //处理 被嵌套的 main
    var subMainList = main.querySelectorAll('.' + CONST.CLASS.TODO_MAIN);
    for (i = subMainList.length - 1; i >= 0; i--) {
      domUtils.after(subMainList[i], main);
    }
    if (domUtils.isEmptyDom(main) && main.parentNode) {
      domUtils.remove(main);
    }

    if (last === check) {
      return;
    }

    if (last.nodeType !== 1 && last.nodeType !== 3 || last.nodeType === 1 && domUtils.isTag(last, 'br')) {
      // 为保留字体样式，不能随便清除 占位符所在的 Element
      // (last.nodeType === 3 && last.nodeValue.replace(CONST.FILL_CHAR_REG, '').length === 0)) {
      parent = last.parentNode;
      while (parent !== main && parent.childNodes.length === 1) {
        last = parent;
        parent = parent.parentNode;
      }
      domUtils.remove(last);

      //避免 br & 特殊符号等元素同时存在，所以需要逐一过滤
      _this.fixMain(main);
    }
  };
  /**
   * 修正 todoList 被嵌套 & 缺失 id 等 的问题
   */
  this.fixNewTodo = function (targetTodo) {
    var container = void 0,
        todoList = void 0,
        todoItem = void 0,
        subTodoList = void 0,
        subTodoItem = void 0,
        subParent = void 0,
        checkList = void 0,
        checkItem = void 0,
        mainList = void 0,
        start = void 0,
        last = void 0,
        next = void 0;

    container = targetTodo ? targetTodo : env.doc;

    var fixEmptyLayer = function fixEmptyLayer(_container) {
      if (domUtils.isEmptyDom(_container)) {
        domUtils.remove(_container);
        return;
      }

      // 不存在 checkbox 的 Layer 删除 Layer class
      checkItem = _this.getCheckbox(_container);
      if (!checkItem) {
        domUtils.removeClass(todoItem, CONST.CLASS.TODO_LAYER);
      }
    };

    // 处理那些被嵌套的 todoList（错误的 Dom 结构）
    todoList = container.querySelectorAll('.' + CONST.CLASS.TODO_LAYER);
    for (var i = 0; i < todoList.length; i++) {
      var _todoItem = todoList[i];
      // 清理多余样式（主要避免 粘贴操作带来的影响）
      domUtils.attr(_todoItem, { 'style': null });
      //清理里面无内容的 Layer
      fixEmptyLayer(_todoItem);
      subTodoList = _todoItem.querySelectorAll('.' + CONST.CLASS.TODO_LAYER);
      if (subTodoList.length === 0) {
        continue;
      }
      subTodoItem = subTodoList[0];
      subParent = subTodoItem.parentNode;
      if (_this.isTodoTag(subParent) || _this.isLayer(subParent)) {
        start = subTodoItem;
      } else {
        start = subParent;
      }
      last = _todoItem;

      if (last === start) {
        continue;
      }
      while (next = start.nextSibling) {
        domUtils.after(next, last);
        last = next;
      }
      domUtils.after(start, _todoItem);

      // 不存在 checkbox 的 Layer 删除 Layer class
      fixEmptyLayer(_todoItem);
    }

    //修正 Main
    mainList = container.querySelectorAll('.' + CONST.CLASS.TODO_MAIN);
    for (var _i = 0; _i < mainList.length; _i++) {
      var mainItem = mainList[_i];
      _this.fixMain(mainItem);
    }

    // 修正 checkbox
    checkList = container.querySelectorAll('.' + CONST.CLASS.TODO_CHECKBOX);
    for (var _i2 = 0; _i2 < checkList.length; _i2++) {
      checkItem = checkList[_i2];
      _this.fixCheckbox(checkItem, false);
    }

    //修正结尾的 <br>
    if (targetTodo) {
      var lastDom = domUtils.getLastDeepChild(container);
      if (domUtils.isTag(lastDom, 'br')) {
        domUtils.remove(lastDom);
      }
    }
  };
  this.getCheckbox = function (main) {
    if (!main) {
      return null;
    }
    return main.querySelector('.' + CONST.CLASS.TODO_CHECKBOX);
  };
  this.getCheckId = function () {
    return 'wiz_todo_' + Date.now() + '_' + Math.floor(Math.random() * 1000000 + 1);
  };
  this.getContainerFromChild = function (child) {
    if (!child) {
      return null;
    }
    return domUtils.getParentByFilter(child, function (dom) {
      return _this.isLayer(dom);
    }, true);
  };
  this.getMainByCaret = function () {
    var range = rangeUtils.getRange();
    if (!range) {
      return null;
    }

    var start = rangeUtils.getRangeDetail(range.startContainer, range.startOffset);
    return _this.getMainFromChild(start.container);
    //
    // let p = domUtils.getParentByFilter(start, (dom) => {
    //     return domUtils.hasClass(dom, CONST.CLASS.TODO_LAYER);
    // }, true);
    // if (!p || !p.hasChildNodes()) {
    //     return null;
    // }
    // return this.getMainInDom(p);
  };
  this.getMainFromChild = function (dom) {
    if (!dom) {
      return null;
    }
    return domUtils.getParentByClass(dom, CONST.CLASS.TODO_MAIN, true);
  };
  this.getMainHtml = function () {
    return '<span class="' + CONST.CLASS.TODO_MAIN + '">' + _this.getCheckboxHtml() + '</span>';
  };
  this.getCheckboxHtml = function () {
    var str = '<img src="' + checkboxImg + '" id="%1" class="' + CONST.CLASS.TODO_CHECKBOX + ' ' + CONST.CLASS.IMG_NOT_DRAG + '" ' + CONST.ATTR.TODO_CHECK + '="unchecked" />';
    str = str.replace('%1', _this.getCheckId());
    return str;
  };
  this.getMainInDom = function (dom) {
    if (!dom || !dom.hasChildNodes()) {
      return null;
    }
    return dom.querySelector('.' + CONST.CLASS.TODO_MAIN);
  };
  this.getUserInfoFromChild = function (dom) {
    if (!dom) {
      return null;
    }
    return domUtils.getParentByClass(dom, CONST.CLASS.TODO_USER_INFO, true);
  };
  this.getUserInfoInDom = function (dom) {
    return dom.querySelector('.' + CONST.CLASS.TODO_USER_INFO);
  };
  this.getUserInfoHtml = function (userGuid, userName, dt) {
    var html = '<span class="' + CONST.CLASS.TODO_ACCOUNT + '">' + '<input disabled readonly class="%1" />' + '%2, ' + '</span>' + '<span class="' + CONST.CLASS.TODO_DATE + '">%3.</span>';
    var avatarClass = CONST.CLASS.TODO_USER_AVATAR + base64.encode(userGuid);
    return html.replace('%1', CONST.CLASS.IMG_NOT_DRAG + ' ' + CONST.CLASS.TODO_AVATAR + ' ' + avatarClass).replace('%2', userName).replace('%3', dt);
  };
  this.getTime = function () {
    var getNum = function getNum(num) {
      return (num < 10 ? '0' : '') + num;
    };

    var dt = new Date();
    var dateStr = void 0,
        timeStr = void 0;
    timeStr = getNum(dt.getHours()) + ':' + getNum(dt.getMinutes());

    if (lang.version === 'en') {
      dateStr = lang.Month[dt.getMonth()] + ' ' + dt.getDate() + ', ' + dt.getFullYear() + ' at ' + timeStr;
    } else {
      dateStr = dt.getFullYear() + lang.Date.Year + (dt.getMonth() + 1) + lang.Date.Month + dt.getDate() + lang.Date.Day + ' ' + timeStr;
    }
    return dateStr;
  };
  this.insertToMain = function (doms, main) {
    if (!doms || !main) {
      return;
    }
    var last = null;
    for (var i = doms.length - 1; i >= 0; i--) {
      var dom = doms[i];
      _this.clearTodoClass(dom);
      main.insertBefore(dom, last);
      last = dom;
    }
  };
  /**
   * 判断 光标是否处于 checkbox 后面
   */
  this.isCaretAfterCheckbox = function () {
    var range = rangeUtils.getRange();
    if (!range) {
      return false;
    }
    var start = void 0,
        prev = void 0,
        main = void 0,
        str = void 0;

    main = _this.getMainByCaret();
    if (!main) {
      return false;
    }
    if (range.collapsed) {
      start = rangeUtils.getRangeDetail(range.startContainer, range.startOffset);
      if (start.container.nodeType === 3 && start.offset > 0) {
        str = start.container.nodeValue.substr(0, start.offset);
        if (!utils.isEmpty(str)) {
          return false;
        }
      }

      if (start.isEnd) {
        prev = start.container;
      } else {
        prev = domUtils.getPreviousNode(start.container, false, main);
      }
      return _this.isCheckbox(prev);
    }
    return false;
  };
  /**
   * 判断 光标是否处于 main 最前面
   * （collapsed = false 时，以 end 为准）
   */
  this.isCaretBeforeCheckbox = function () {
    var result = {
      enable: false,
      checkbox: null
    };
    var range = rangeUtils.getRange();

    if (!range) {
      return result;
    }
    var caretDom = range.endContainer;
    if (caretDom.nodeType === 1) {
      caretDom = caretDom.childNodes[range.endOffset];
    } else if (caretDom.nodeType === 3 && domUtils.isEmptyDom(caretDom) && range.endOffset === caretDom.nodeValue.length && !_this.getContainerFromChild(caretDom)) {
      // 如果 textNode 本身已经在 todoContainer 以内 则不进行处理
      caretDom = domUtils.getNextNode(caretDom, false);
      if (caretDom) {
        caretDom = domUtils.getParentByFilter(caretDom, function (dom) {
          return _this.isLayer(dom);
        }, true);
      }
    }

    if (_this.isLayer(caretDom) || _this.isMain(caretDom)) {
      result.enable = true;
      result.checkbox = _this.getCheckbox(caretDom);
    } else if (_this.isCheckbox(caretDom)) {
      result.enable = true;
      result.checkbox = caretDom;
    }
    if (!result.checkbox) {
      // 不存在 checkbox 的 layer 不当做 todoList
      result.enable = false;
    }
    return result;
  };
  /**
   * 判断 dom 是否为 todoList 的 checkbox
   */
  this.isCheckbox = function (dom) {
    return domUtils.hasClass(dom, CONST.CLASS.TODO_CHECKBOX);
  };
  this.isEmptyContainer = function (container) {
    if (!container) {
      return true;
    }
    var childNodes = container.childNodes;
    for (var i = 0; i < childNodes.length; i++) {
      var child = childNodes[i];
      if (_this.isMain(child)) {
        if (!_this.isEmptyMain(child)) {
          return false;
        }
      } else if (!domUtils.isEmptyDom(child)) {
        return false;
      }
    }
    return true;
  };
  this.isEmptyMain = function (main) {
    if (!main) {
      return true;
    }
    var childNodes = main.childNodes;
    for (var i = 0; i < childNodes.length; i++) {
      var child = childNodes[i];
      if (!_this.isCheckbox(child) && !domUtils.isEmptyDom(child)) {
        return false;
      }
    }
    return true;
  };
  this.isLayer = function (dom) {
    return domUtils.hasClass(dom, CONST.CLASS.TODO_LAYER);
  };
  /**
   * 判断 dom 是否为 todoList 的 main
   */
  this.isMain = function (dom) {
    return domUtils.hasClass(dom, CONST.CLASS.TODO_MAIN);
  };
  /**
   * 判断 dom 是否为 todoList 内特殊 dom
   */
  this.isTodoTag = function (dom) {
    if (!dom) {
      return false;
    }
    return _this.isMain(dom) || _this.isUserInfo(dom) || domUtils.hasClass(dom, CONST.CLASS.TODO_ACCOUNT) || domUtils.hasClass(dom, CONST.CLASS.TODO_DATE);
  };
  /**
   * 判断 dom 是否为 用户信息
   */
  this.isUserInfo = function (dom) {
    return domUtils.hasClass(dom, CONST.CLASS.TODO_USER_INFO);
  };
  this.setTodo = function (container, todoRoute) {
    var blockList = void 0,
        todoList = [];
    if (container) {
      //允许指定 容器直接设置 todoList
      blockList = [container];
    } else {
      blockList = blockUtils.fixAndGetBlockListFromRange();
    }
    if (blockList.length === 0) {
      return todoList;
    }

    var checkBr = function checkBr(block) {
      var brList = block.querySelectorAll('br');
      if (!domUtils.isEmptyDom(block) && brList.length > 0) {
        for (var i = brList.length - 1; i >= 0; i--) {
          var br = brList[i];
          var prev = domUtils.splitDomBeforeSub(block, br);
          domUtils.remove(br);
          todoList.push(setTodoSingle(prev, todoRoute));
          if (i === 0 && prev !== block) {
            todoList.push(setTodoSingle(block, todoRoute));
          }
        }
      } else {
        todoList.push(setTodoSingle(block, todoRoute));
      }
    };

    var checkLi = function checkLi(block) {
      // 如果 容器整体是 li 则不处理内部 br
      var liList = block.querySelectorAll('li');
      if (domUtils.isTag(block, 'li')) {
        todoList.push(setTodoSingle(block, todoRoute));
      } else if (liList.length > 0) {
        for (var i = 0; i < liList.length; i++) {
          todoList.push(setTodoSingle(liList[i], todoRoute));
        }
      } else {
        checkBr(block);
      }
    };

    var checkEnable = function checkEnable(block) {
      // li 的情況下不检查内部情况，因为 li 是todo 的时候，在li 里面仍然可以出现 Code & Table
      if (domUtils.isTag(block, 'li')) {
        return true;
      }
      var isTable = domUtils.hasClass(block, CONST.CLASS.TABLE_CONTAINER) || block.querySelector('.' + CONST.CLASS.TABLE_CONTAINER);
      if (isTable) {
        return false;
      }
      var isCode = domUtils.hasClass(block, CONST.CLASS.CODE_CONTAINER) || block.querySelector('.' + CONST.CLASS.CODE_CONTAINER);
      if (isCode) {
        return false;
      }
      var isEnable = !domUtils.isTag(block, ['hr']);
      return isEnable;
    };

    // 根据 blockList[0] 判断 create or cancel todoList
    var createTodo = true;
    var firstBlock = blockList[0];
    var main = _this.getMainInDom(firstBlock);
    var userInfo = _this.getUserInfoInDom(firstBlock);

    // Enter 键，在下一行新建 TodoList 时，需要修复 checkbox 的 img
    var hasCheckbox = !!_this.getCheckbox(main);
    if (hasCheckbox || userInfo) {
      createTodo = false;
    }

    // 清理内部所有的 todoList
    for (var i = 0; i < blockList.length; i++) {
      var block = blockList[i];
      // let checkbox;
      // while (checkbox = this.getCheckbox(block)) {
      while (main = _this.getMainInDom(block)) {
        // let todoLayer = this.getContainerFromChild(checkbox);
        var todoLayer = _this.getContainerFromChild(main);
        _this.cancelTodo(todoLayer);
      }
    }

    if (!createTodo) {
      return todoList;
    }

    // 设置 todoList
    for (var _i3 = 0; _i3 < blockList.length; _i3++) {
      var _block = blockList[_i3];
      if (checkEnable(_block)) {
        checkLi(_block);
      }
    }
    return todoList;
  };
  var setTodoSingle = function setTodoSingle(container, todoRoute) {
    // let rangeList,
    var start = void 0,
        end = void 0,
        mainHtml = void 0,
        main = void 0,
        tmpDom = void 0;

    //允许指定 容器直接设置 todoList
    start = container;

    // 由于 dom 结构有可能是  span 内部有 div ，所以需要找到内部的 block
    if (!domUtils.isBlock(start)) {
      var child = domUtils.getFirstDeepChild(start);
      var parent = domUtils.getBlockParent(child);
      if (parent) {
        start = parent;
      }
    }

    mainHtml = _this.getMainHtml();
    tmpDom = env.doc.createElement('div');
    if (!_this.canBeContainer(start)) {
      mainHtml = '<div class="' + CONST.CLASS.TODO_LAYER + ' ' + CONST.CLASS.TODO_UNCHECKED + '">' + mainHtml + '</div>';
    } else {
      domUtils.addClass(start, CONST.CLASS.TODO_LAYER);
      domUtils.addClass(start, CONST.CLASS.TODO_UNCHECKED);
    }
    tmpDom.innerHTML = mainHtml;
    main = _this.getMainInDom(tmpDom);

    while (tmpDom.lastChild) {
      start.insertBefore(tmpDom.lastChild, start.firstChild);
    }

    // 已经不需要 将光标一味限定在 main 的 span 内了
    end = domUtils.getLastDeepChild(start);
    if (domUtils.isTag(end, 'br')) {
      domUtils.remove(end);
      end = domUtils.getLastDeepChild(start);
    }
    // 如果 end 是 Code 内，需要找到 Code 前面的内容,否则会导致光标异常
    var code = codeUtils && codeUtils.getContainerFromChild(end);
    var endOffset = void 0;
    if (code) {
      end = domUtils.getPreviousNode(code, false, start);
      if (domUtils.isBlock(end)) {
        // 如果 code 前面有内容， end 肯定不会是 block
        endOffset = 0;
      } else {
        endOffset = domUtils.getEndOffset(end);
      }
    } else {
      endOffset = domUtils.getEndOffset(end);
    }

    if (domUtils.isSelfClosingTag(end)) {
      rangeUtils.setRange(end.parentNode, domUtils.getIndex(end) + 1);
    } else {
      if (endOffset > 0) {
        rangeUtils.setRange(end, endOffset);
      } else {
        var fillChar = env.doc.createTextNode(CONST.FILL_CHAR);
        if (end.nodeType === 3 && end.nodeValue.length === 0) {
          end.nodeValue = CONST.FILL_CHAR;
        } else {
          end.appendChild(fillChar);
        }
        // domUtils.before(fillChar, end);
        // domUtils.remove(end);
        rangeUtils.setRange(fillChar, 0, fillChar, 1);
      }
    }

    //修正 todoList style
    _this.checkTodoStyle(false);

    return main;
  };
  this.setUserAvatarStyle = function (userGuid, avatarUrl) {
    var guid = base64.encode(userGuid);
    var sId = CONST.ID.TODO_AVATAR_STYLE + guid;
    var sClass = CONST.CLASS.TODO_USER_AVATAR + guid;
    var style = env.doc.getElementById(sId);
    if (style) {
      return;
    } else {
      style = env.win.parent.document.getElementById(sId);
      if (style) {
        wizStyle.insertStyle({ id: sId }, style.innerHTML);
        return;
      }
    }
    var setImageStyle = function setImageStyle(baseStr) {
      //有可能同时点击多个 todoList
      var style = env.doc.getElementById(sId);
      if (style) {
        return;
      }
      wizStyle.insertStyle({ id: sId }, '.' + sClass + '{background-image:url(' + baseStr + ');}');
    };

    if (/^data:/i.test(avatarUrl)) {
      setImageStyle(avatarUrl);
    } else {
      domUtils.convertImageToBase64(avatarUrl, 50, 50, setImageStyle);
    }
  };
  this.oldPatch = {
    fixImg: function fixImg(img) {
      if (!img) {
        return;
      }
      var iObj = env.doc.createElement('img');
      iObj.className = img.className;
      iObj.src = checkboxImg;
      domUtils.removeClass(iObj, CONST.CLASS.TODO_CHECK_IMG_OLD);
      domUtils.addClass(iObj, CONST.CLASS.TODO_CHECKBOX);
      if (img.id) {
        iObj.id = img.id;
      }
      if (img.getAttribute('state')) {
        var attr = {};
        attr[CONST.ATTR.TODO_CHECK] = img.getAttribute('state');
        domUtils.attr(iObj, attr);
      }
      var parent = img.parentNode;
      parent.insertBefore(iObj, img);
      parent.removeChild(img);
    },
    fixLabel: function fixLabel(label) {
      if (label) {
        domUtils.removeClass(label, CONST.CLASS.TODO_LABEL_OLD);
        domUtils.addClass(label, CONST.CLASS.TODO_MAIN);
        if (domUtils.hasClass(label, CONST.CLASS.TODO_CHECKED_OLD)) {
          domUtils.removeClass(label, CONST.CLASS.TODO_CHECKED_OLD);
          domUtils.addClass(label, CONST.CLASS.TODO_CHECKED);
        } else if (domUtils.hasClass(label, CONST.CLASS.TODO_UNCHECKED_OLD)) {
          domUtils.removeClass(label, CONST.CLASS.TODO_UNCHECKED_OLD);
          domUtils.addClass(label, CONST.CLASS.TODO_UNCHECKED);
        }
      }

      if (!label || domUtils.isTag(label, 'span')) {
        return;
      }
      var parent = label.parentNode;
      if (!parent) {
        return;
      }
      var span = env.doc.createElement('span');
      span.className = label.className;
      while (label.firstChild) {
        span.appendChild(label.firstChild);
      }
      parent.insertBefore(span, label);
      parent.removeChild(label);
    },
    /**
     * 初始化 todoList 主要用于修正旧版本的 todoList 样式
     * 保证每个 todoItem 占一行
     */
    fixOldTodo: function fixOldTodo() {
      var subLabelList = void 0,
          subLabel = void 0,
          subContainer = void 0,
          checkImgList = void 0,
          labelList = void 0,
          tailList = void 0;

      //修正未被 label 封装的 checkImg
      checkImgList = env.body.querySelectorAll('.' + CONST.CLASS.TODO_CHECK_IMG_OLD);
      for (var i = checkImgList.length - 1; i >= 0; i--) {
        var checkImg = checkImgList[i];
        var label = _this.oldPatch.getLabelFromChild(checkImg);
        if (!label || label.children[0] !== checkImg) {
          _this.fixCheckbox(checkImg, true);
        }
        //将 image 转换为 i
        _this.oldPatch.fixImg(checkImg);
      }

      //处理那些被嵌套的 todoList（错误的 Dom 结构）
      labelList = env.body.querySelectorAll('.' + CONST.CLASS.TODO_LABEL_OLD);
      for (var _i4 = 0; _i4 < labelList.length; _i4++) {
        var _label = labelList[_i4];
        var container = _this.oldPatch.packageTodo(_label);
        domUtils.addClass(container, CONST.CLASS.TODO_LAYER);
        subLabelList = container.querySelectorAll('.' + CONST.CLASS.TODO_LABEL_OLD);
        for (var j = subLabelList.length - 1; j > 0; j--) {
          subLabel = subLabelList[j];
          subContainer = _this.oldPatch.packageTodo(subLabel);
          domUtils.after(subContainer, container);
        }
        //修正 用户信息
        _this.oldPatch.fixUserInfo(_label);
      }

      //将 label 全部替换为 span
      labelList = env.body.querySelectorAll('.' + CONST.CLASS.TODO_LABEL_OLD);
      for (var _i5 = labelList.length - 1; _i5 >= 0; _i5--) {
        _this.oldPatch.fixLabel(labelList[_i5]);
      }

      //清理 Tail
      tailList = env.body.querySelectorAll('.' + CONST.CLASS.TODO_TAIL_OLD);
      for (var _i6 = tailList.length - 1; _i6 >= 0; _i6--) {
        var tail = tailList[_i6];
        if (domUtils.isEmptyDom(tail)) {
          domUtils.remove(tail);
        } else {
          domUtils.removeClass(CONST.CLASS.TODO_TAIL_OLD);
        }
      }
    },
    fixUserInfo: function fixUserInfo(label) {
      var parent = label.parentNode,
          check = _this.oldPatch.getCheckImg(label),
          id = check ? check.id : '',
          childNodes = parent.childNodes,
          firstUserInfo = false;
      for (var i = 0; i < childNodes.length; i++) {
        var child = childNodes[i];
        if (domUtils.hasClass(child, CONST.CLASS.TODO_USER_INFO)) {
          if (!firstUserInfo) {
            firstUserInfo = true;
            var attr = {};
            attr[CONST.ATTR.TODO_ID] = id;
            domUtils.attr(child, attr);
          } else {
            parent.removeChild(child);
            i--;
          }
        }
      }
    },
    getCheckImg: function getCheckImg(label) {
      if (!label) {
        return null;
      }
      return label.querySelector('.' + CONST.CLASS.TODO_CHECK_IMG_OLD);
    },
    getLabelFromChild: function getLabelFromChild(dom) {
      if (!dom) {
        return null;
      }
      return domUtils.getParentByFilter(dom, function (_dom) {
        return domUtils.hasClass(_dom, CONST.CLASS.TODO_LABEL_OLD);
      }, true);
    },
    isFirstLabel: function isFirstLabel(label) {
      if (!label) {
        return false;
      }
      var parent = label.parentNode,
          childNodes = parent.childNodes;
      for (var i = 0; i < childNodes.length; i++) {
        var child = childNodes[i];
        if (child === label) {
          return true;
        } else if (!domUtils.isEmptyDom(child)) {
          return false;
        }
      }
      return false;
    },
    /**
     * 给 todoItem 打包
     */
    packageTodo: function packageTodo(label) {
      if (!label) {
        return null;
      }
      var parent = label.parentNode;
      if (parent !== env.body && _this.oldPatch.isFirstLabel(label)) {
        //如果 label 是首元素，则直接返回 label 的父元素
        return parent;
      }

      // 如果 label 不是首元素，则 对齐进行打包
      var check = _this.oldPatch.getCheckImg(label),
          id = check ? check.id : '',
          userInfo = id ? parent.querySelector('span[' + CONST.ATTR.TODO_ID + '=' + id + ']') : null,
          next = label.nextSibling,
          tmpNext = void 0;
      var container = env.doc.createElement('div');
      container.appendChild(label);
      while (next) {
        tmpNext = next.nextSibling;
        container.appendChild(next);
        next = next === userInfo ? null : tmpNext;
      }
      parent.insertBefore(container, tmpNext);
      return container;
    }
  };
};

module.exports = TodoUtils;

},{"../../config/const":388,"../../libs/base64":396,"../../libs/utils":400}],388:[function(require,module,exports){
'use strict';

/**
 * 内部使用的标准常量.
 */

var version = '1.0.19';
var wizContentVersion = '0.1.3';

var FILL_CHAR = '\u200B';
var CONST = {
  version: version,
  wizContentVersion: wizContentVersion,

  //在此间隔内修订，不生成新的 span，只修改修订时间
  AMEND_TIME_SPACE: 3 * 60 * 1000, // 3分钟
  //在此间隔内修订的内容， 被当作同一批次修订，批量拒绝或接受
  AMEND_BATCH_TIME_SPACE: 30 * 1000, // 30秒
  //String.fromCharCode(8203)
  FILL_CHAR: FILL_CHAR,
  FILL_CHAR_REG: new RegExp(FILL_CHAR, 'ig'),
  WIZ_TABLE_IN_MARKDOWN_SRC_REG: '<div [^>]*wiz-table-container[^>]*>(.|\\n)*?<\/table><\/div><\/div>',
  EMPTY_NOTE_TEMPLATE: '<!DOCTYPE html><html><head></head><body>${body}</body></html>',
  AMEND: {
    INFO_SPACE: 0, //修订信息图层与目标间隔
    INFO_TIMER: 300 //修订timer 间隔
  },
  ATTR: {
    IMG: 'data-wiz-img',
    IMG_MASK: 'data-wiz-img-mask',
    IMG_RATE: 'data-wiz-img-rate',
    IMG_EDITING: 'data-wiz-img-editing',
    SPAN: 'data-wiz-span',
    SPAN_USERID: 'data-wiz-user-id',
    SPAN_INSERT: 'data-wiz-insert',
    SPAN_DELETE: 'data-wiz-delete',
    SPAN_PASTE: 'data-wiz-paste',
    SPAN_PASTE_TYPE: 'data-wiz-paste-type',
    SPAN_PASTE_ID: 'data-wiz-paste-id',
    SPAN_TIMESTAMP: 'data-wiz-amend-time',
    TODO_ID: 'wiz_todo_id',
    TODO_CHECK: 'data-wiz-check'
  },
  CLASS: {
    BLOCK_SCROLL: 'wiz-block-scroll',
    CODE_CONTAINER: 'wiz-code-container',
    CODE_CONTAINER_PASTE: 'wiz-code-container-paste',
    CODE_CONTAINER_OLD: 'prettyprint',
    CODE_MIRROR: 'CodeMirror',
    CODE_MIRROR_LINE: 'CodeMirror-line',
    CODE_MIRROR_MEASURE: 'CodeMirror-measure',
    CODE_MIRROR_GUTTER: 'CodeMirror-gutter-wrapper',
    CODE_MIRROR_HSCROLL: 'CodeMirror-scroll',
    CODE_TOOLS: 'wiz-code-tools',
    CODE_TOOLS_MODE: 'wiz-code-tools-mode',
    CODE_TOOLS_THEME: 'wiz-code-tools-theme',
    CODE_TOOLS_MORE: 'wiz-code-tools-more',
    EDITOR_CONTAINER: 'wiz-editor-container',
    EDITOR_PREVIEW_SHOW: 'wiz-editor-preview-show',
    IMG_ATTACHMENT: 'wiz-img-attachment',
    IMG_NOT_DRAG: 'wiz-img-cannot-drag',
    IMG_RESIZE_ACTIVE: 'wiz-img-resize-active',
    IMG_RESIZE_CONTAINER: 'wiz-img-resize-container',
    IMG_RESIZE_HANDLE: 'wiz-img-resize-handle',
    MARKDOWN_BODY: 'markdown-body',
    ORDER_LIST_LEVEL: ['wiz-list-level3', 'wiz-list-level1', 'wiz-list-level2'],
    READONLY: 'wiz-readonly',
    EDITING: 'wiz-editing',
    SELECTED_CELL: 'wiz-selected-cell',
    SELECTED_CELL_MULTI: 'wiz-selected-cell-multi',
    SELECT_PLUGIN_CONTAINER: 'wiz-select-plugin-container',
    SELECT_PLUGIN_HEADER: 'wiz-select-plugin-header',
    SELECT_PLUGIN_HEADER_TEXT: 'wiz-select-plugin-header-text',
    SELECT_PLUGIN_OPTIONS: 'wiz-select-plugin-options',
    SELECT_PLUGIN_OPTIONS_ITEM: 'wiz-select-plugin-options-item',
    SVG_BASE: 'wiz-svg-base',
    TEMPLATE_EDITABLE: 'wiz-template-editable',
    TABLE_CONTAINER: 'wiz-table-container',
    TABLE_TOOLS: 'wiz-table-tools',
    TABLE_BODY: 'wiz-table-body',
    TABLE_MENU_BUTTON: 'wiz-table-menu-button',
    TABLE_MENU_ITEM: 'wiz-table-menu-item',
    TABLE_MENU_SUB: 'wiz-table-menu-sub',
    TABLE_MOVING: 'wiz-table-moving',
    TODO_ACCOUNT: 'wiz-todo-account',
    TODO_AVATAR: 'wiz-todo-avatar',
    TODO_CHECKBOX: 'wiz-todo-checkbox',
    TODO_CHECK_IMG_OLD: 'wiz-todo-img',
    TODO_DATE: 'wiz-todo-dt',
    TODO_LAYER: 'wiz-todo-layer',
    TODO_MAIN: 'wiz-todo-main',
    TODO_LABEL_OLD: 'wiz-todo-label',
    TODO_CHECKED: 'wiz-todo-checked',
    TODO_UNCHECKED: 'wiz-todo-unchecked',
    TODO_CHECKED_OLD: 'wiz-todo-label-checked',
    TODO_UNCHECKED_OLD: 'wiz-todo-label-unchecked',
    TODO_TAIL_OLD: 'wiz-todo-tail', //新版本 todoList 取消此元素
    TODO_USER_AVATAR: 'wiz-todo-avatar-',
    TODO_USER_INFO: 'wiz-todo-completed-info',
    WIZ_BODY: 'wiz-editor-body',
    WIZ_CONTENT_IFRAME_ACTIVE: 'wiz-content-active',
    WIZ_EIDTOR_BODY_CONTAINER: 'wiz-editor-body-container',
    WIZ_EIDTOR_IFRAME: 'wiz-editor-iframe',
    WIZ_EIDTOR_PREVIEW_CONTAINER: 'wiz-editor-preview-container',
    WIZ_EIDTOR_TOOlBAR_CONTAINER: 'wiz-editor-toolbar-container',
    WIZ_EIDTOR_TOOlBAR_MAIN: 'wiz-editor-toolbar-main',
    WIZ_EIDTOR_TOOlBAR_SIDE: 'wiz-editor-toolbar-side'
  },
  //客户端相关的事件定义
  CLIENT_EVENT: {
    WizEditorPaste: 'wizEditorPaste',
    WizEditorClickImg: 'wizEditorClickImg',
    WizEditorClickSvg: 'WizEditorClickSvg',
    WizReaderClickImg: 'wizReaderClickImg',
    WizMarkdownRender: 'wizMarkdownRender',
    WizEditorTrackEvent: 'wizEditorTrackEvent'
  },
  CODE: {
    StorageKey: {
      Mode: 'wiz-code-mode',
      Theme: 'wiz-code-theme',
      Wrap: 'wiz-code-wrap'
    }
  },
  COLOR: ['#CB3C3C', '#0C9460', '#FF3399', '#FF6005', '#8058BD', '#009999', '#8AA725', '#339900', '#CC6600', '#3BBABA', '#D4CA1A', '#2389B0', '#006699', '#FF8300', '#2C6ED5', '#FF0000', '#B07CFF', '#CC3399', '#EB4847', '#3917E6'],
  CSS: {
    DEFAULT_FONT: 'Helvetica, "Hiragino Sans GB", "微软雅黑", "Microsoft YaHei UI", SimSun, SimHei, arial, sans-serif',
    IMG: {
      SPAN: {
        position: 'relative',
        display: 'inline-block'
      },
      MASK: {
        position: 'absolute',
        width: '100% !important',
        height: '100% !important',
        top: '0',
        left: '0',
        opacity: '.5',
        filter: 'alpha(opacity=50)',
        border: '2px solid',
        'box-sizing': 'border-box',
        '-webkit-box-sizing': 'border-box',
        '-moz-box-sizing': 'border-box'
      }
    },
    IMG_DELETED: {
      background: '#fdc6c6 url(data:image/gif;base64,R0lGODlhDwAPAIABAIcUFP///yH5BAEKAAEALAAAAAAPAA8AAAIajI8IybadHjxyhjox1I0zH1mU6JCXCSpmUAAAOw==)',
      'border-color': '#E47070'
    },
    IMG_INSERT: {
      background: '#ccffcc',
      'border-color': '#00AA00'
    },
    TODO_LIST: {
      IMG_WIDTH: 40
    },
    Z_INDEX: {
      amendInfo: 150,
      tableBorder: 105,
      tableColRowLine: 120,
      tableRangeDot: 110,
      tableTDBefore: 100,
      tableTools: 130,
      tableToolsArrow: 10
    }
  },
  //全局事件 id 集合
  EVENT: {
    BEFORE_GET_DOCHTML: 'BEFORE_GET_DOCHTML',
    BEFORE_SAVESNAP: 'BEFORE_SAVESNAP',
    AFTER_INSERT_DOM: 'AFTER_INSERT_DOM',
    AFTER_RESTORE_HISTORY: 'AFTER_RESTORE_HISTORY',
    EXEC_COMMEND: 'EXEC_COMMEND',

    ON_DBLCLICK: 'ON_DBLCLICK',
    ON_CLICK: 'ON_CLICK',
    ON_COMPOSITION_START: 'ON_COMPOSITION_START',
    ON_COMPOSITION_END: 'ON_COMPOSITION_END',
    ON_COPY: 'ON_COPY',
    ON_CUT: 'ON_CUT',
    ON_DOM_SUBTREE_MODIFIED: 'ON_DOM_SUBTREE_MODIFIED',
    ON_DRAG_START: 'ON_DRAG_START',
    ON_DRAG_ENTER: 'ON_DRAG_ENTER',
    ON_DROP: 'ON_DROP',
    ON_EXEC_COMMAND: 'ON_EXEC_COMMAND',
    ON_KEY_DOWN: 'ON_KEY_DOWN',
    ON_KEY_UP: 'ON_KEY_UP',
    ON_MOUSE_DOWN: 'ON_MOUSE_DOWN',
    ON_MOUSE_MOVE: 'ON_MOUSE_MOVE',
    ON_MOUSE_OVER: 'ON_MOUSE_OVER',
    ON_MOUSE_UP: 'ON_MOUSE_UP',
    ON_ORIENTATION_CHANGE: 'ON_ORIENTATION_CHANGE',
    ON_PASTE: 'ON_PASTE',
    ON_SCROLL: 'ON_SCROLL',
    ON_SELECT_PLUGIN_CHANGE: 'ON_SELECT_PLUGIN_CHANGE',
    ON_SELECT_PLUGIN_HIDE: 'ON_SELECT_PLUGIN_HIDE',
    ON_SELECT_PLUGIN_SHOW: 'ON_SELECT_PLUGIN_SHOW',
    ON_SELECTION_CHANGE: 'ON_SELECTION_CHANGE',
    ON_SELECT_START: 'ON_SELECT_START',
    ON_TOUCH_START: 'ON_TOUCH_START',
    ON_TOUCH_END: 'ON_TOUCH_END',
    UPDATE_RENDER: 'UPDATE_RENDER'
  },
  HISTORY: {
    TYPE: {
      CODE_MIRROR: 'CODE_MIRROR',
      COMMON: 'COMMON'
    }
  },
  ID: {
    BODY_TMP_BOTTOM_STYLE: 'wiz-tmp-bottom-style',
    AMEND_INFO: 'wiz-amend-info',
    AMEND_INFO_SINGLE: 'wiz-amend-info-single',
    AMEND_INFO_MULTI: 'wiz-amend-info-multi',
    AMEND_INFO_NAME: 'wiz-amend-info-name',
    AMEND_INFO_IMG: 'wiz-amend-info-image',
    AMEND_INFO_CONTENT: 'wiz-amend-info-content',
    AMEND_INFO_TIME: 'wiz-amend-info-time',
    AMEND_INFO_TOOLS: 'wiz-amend-info-tools',
    AMEND_INFO_ACCEPT: 'wiz-amend-info-accept',
    AMEND_INFO_REFUSE: 'wiz-amend-info-refuse',
    AMEND_USER_INFO: 'wiz-amend-user',
    CODE_STYLE: 'wiz_code_style',
    FORMAT_PAINTER_STYLE: 'wiz_format_painter_style',
    IFRAME_FOR_SAVE: 'wiz-iframe-for-save',
    PURE_READ_STYLE: 'wiz-pure-read-style',
    TABLE_RANGE_BORDER: 'wiz-table-range-border',
    TABLE_ROW_LINE: 'wiz-table-row-line',
    TABLE_COL_LINE: 'wiz-table-col-line',
    TODO_STYLE: 'wiz_todo_style',
    TODO_STYLE_OLD: 'wiz_todo_style_id',
    TODO_AVATAR_STYLE: 'wiz_todo_style_avatar_',
    TMP_STYLE_PRE: 'wiz_tmp_style_',
    WIZ_DEFAULT_STYLE: 'wiz_custom_css',
    WIZ_EIDTOR_FRAME_STYLE: 'wiz-editor-frame-style',
    WIZ_EIDTOR_PREVIEW_STYLE: 'wiz-editor-preview-style',
    WIZ_EIDTOR_TOOlBAR_STYLE: 'wiz-editor-toolbar-style'
  },
  NAME: {
    CODE_STYLE: 'wiz_code_style',
    TMP_STYLE: 'wiz_tmp_editor_style',
    UNSAVE_STYLE: 'wiz_unsave_style'
  },
  NOTE_READER_TYPE: {
    COMMON: 'common',
    MARKDOWN: 'markdown',
    MATHJAX: 'mathjax'
  },
  NOTE_EDITOR_TYPE: {
    COMMON: 'common',
    MARKDOWN: 'markdown'
  },
  SELECT_PLUGIN: {
    TYPE: {
      Common: 'common',
      More: 'more'
    }
  },
  TAG: {
    CODE_MIRROR: 'wiz_code_mirror',
    TMP_TAG: 'wiz_tmp_tag',
    TMP_PLUGIN_TAG: 'wiz_tmp_plugin_tag',
    TMP_HIGHLIGHT_TAG: 'wiz_tmp_highlight_tag'
  },
  TYPE: {
    IMG_DELETE: 'delete',
    IMG_INSERT: 'insert',
    PASTE: {
      START: 'start',
      END: 'end',
      CONTENT: 'content'
    },
    POS: {
      upLeft: 'up-left',
      downLeft: 'down-left',
      leftUp: 'left-up',
      rightUp: 'right-up',
      upRight: 'up-right',
      downRight: 'down-right',
      leftDown: 'left-down',
      rightDown: 'right-down'
    },
    TABLE: {
      COPY: 'copy',
      PASTE: 'paste',
      CLEAR_CELL: 'clearCell',
      MERGE_CELL: 'mergeCell',
      SPLIT_CELL: 'splitCell',
      INSERT_ROW_UP: 'insertRowUp',
      INSERT_ROW_DOWN: 'insertRowDown',
      INSERT_COL_LEFT: 'insertColLeft',
      INSERT_COL_RIGHT: 'insertColRight',
      DELETE_ROW: 'deleteRow',
      DELETE_COL: 'deleteCol',
      SET_CELL_BG: 'setCellBg',
      SET_CELL_ALIGN: 'setCellAlign',
      DISTRIBUTE_COLS: 'distributeCols',
      DELETE_TABLE: 'deleteTable'
    }
  }
};

module.exports = CONST;

},{}],389:[function(require,module,exports){
'use strict';

/**
 * wizEditor 环境参数，保存当前 document 等
 */
var CONST = require('./const');
var base64 = require('../libs/base64');
var domPatch = require('../libs/domPatch');

var WizNoteIosCmdProtocol = 'wiznotecmd://';

var ua = navigator.userAgent;

function setOptions(old, newOptions) {
  if (!newOptions) {
    return;
  }
  var k = void 0;
  for (k in old) {
    if (old.hasOwnProperty(k) && typeof newOptions[k] !== 'undefined') {
      if (/^(editor|reader|pureReadMode|nightMode|documentData|callback|timeout|markdownPlugIn|ios|pc|table|code)$/.test(k)) {
        setOptions(old[k], newOptions[k]);
      } else {
        old[k] = newOptions[k];
      }
    }
  }
}

function setClientType(type, env) {
  if (!type) {
    return;
  }
  type = type.toLowerCase();
  if (type.indexOf('windows') > -1) {
    env.client.type.isWin = true;
    env.client.sendCmdToWizClient = function (cmd, options) {
      if (cmd === CONST.CLIENT_EVENT.WizReaderClickImg) {
        env.win.external.OnClickedImage(options.src, JSON.stringify(options.imgList));
      } else if (cmd === CONST.CLIENT_EVENT.WizEditorClickSvg) {
        console.log(JSON.stringify(options));
        env.win.external.OnClickedSvg(JSON.stringify(options));
      }
    };
  } else if (type.indexOf('ios') > -1) {
    env.client.type.isIOS = true;
    env.client.sendCmdToWizClient = function (cmd, options) {
      var url = void 0;
      if (cmd === CONST.CLIENT_EVENT.WizReaderClickImg) {
        delete options.imgList;
      }

      url = WizNoteIosCmdProtocol + cmd;
      var k = void 0,
          params = [];
      if (!!options) {
        for (k in options) {
          if (options.hasOwnProperty(k)) {
            params.push(k + '=' + encodeURIComponent(options[k]));
          }
        }
        url += '?' + params.join('&');
      }

      var tmpTag = env.doc.createElement(CONST.TAG.TMP_TAG);
      var iframe = env.doc.createElement('iframe');
      iframe.setAttribute('src', url);
      tmpTag.style.display = 'none';
      tmpTag.appendChild(iframe);
      env.body.appendChild(tmpTag);
      tmpTag.parentNode.removeChild(tmpTag);
      iframe = null;
      tmpTag = null;
    };
  } else if (type.indexOf('android') > -1) {
    env.client.type.isAndroid = true;
    env.client.sendCmdToWizClient = function (cmd, options) {
      if (cmd === CONST.CLIENT_EVENT.WizReaderClickImg) {
        env.win.WizNote.onClickImg(options.src, options.imgList.join(','));
      } else if (cmd === CONST.CLIENT_EVENT.WizEditorClickImg) {
        env.win.WizNote.onEditorClickImage(options.src);
      } else if (cmd === CONST.CLIENT_EVENT.WizEditorClickSvg) {
        env.win.WizNote.OnClickSvg(JSON.stringify(options));
      }
    };
  } else if (type.indexOf('mac') > -1) {
    var _ua = env.win.navigator.userAgent;
    if (!/Mac/i.test(_ua)) {
      env.client.type.isLinux = true;
    }
    env.client.type.isMac = true;
    env.client.sendCmdToWizClient = function (cmd, options) {
      if (cmd === CONST.CLIENT_EVENT.WizReaderClickImg) {
        env.win.WizExplorerApp.onClickedImage(options.src, JSON.stringify(options.imgList));
      } else if (cmd === CONST.CLIENT_EVENT.WizEditorClickSvg) {
        console.log(JSON.stringify(options));
        env.win.WizQtEditor.OnClickedSvg(JSON.stringify(options));
      }
    };
  }

  if (env.client.type.isIOS || env.client.type.isAndroid) {
    if (type.indexOf('pad') > -1) {
      env.client.type.isPad = true;
    } else {
      env.client.type.isPhone = true;
    }
  }
}

function getDefaultEnv(dependencyUrl) {
  var GlobalEvent = {};
  var codeWrap = true;
  if (window.localStorage) {
    codeWrap = window.localStorage.getItem(CONST.CODE.StorageKey.Wrap) === '1';
  }
  return {
    options: {
      document: null,
      container: null,
      useFrame: false,
      htmlBaseUrl: '',
      lang: 'en',
      clientType: '',
      userInfo: null,
      usersData: [],
      userNameEncoder: '',
      dependencyUrl: '',
      wizTemplate: {
        url: ''
      },
      pureReadMode: {
        enable: false,
        needContentExtraction: false,
        borderColor: '',
        htmlBgColor: '',
        bodyBgColor: ''
      },
      nightMode: {
        enable: false,
        color: '',
        bgColor: '',
        brightness: ''
      },
      editor: {
        type: CONST.NOTE_EDITOR_TYPE.COMMON,
        autoFocus: true,
        autoCheckLink: true,
        minHeight: 300,
        maxRedo: 100,
        callback: {
          redo: null,
          onKeyDown: null,
          onClick: null,
          onPasteFile: null,
          onDropFile: null,
          onClickToolbarInsertImg: null,
          onClickToolbarHelp: null
        }
      },
      reader: {
        type: CONST.NOTE_READER_TYPE.COMMON,
        minHeight: 300,
        codeNoIDE: false,
        noAmend: false,
        markdownPlugIn: {
          imgSrcFilter: null,
          customBlockGamut: null
        },
        callback: {
          markdown: null,
          mathJax: null,
          onClick: null
        },
        timeout: {
          markdown: 30 * 1000,
          mathJax: 30 * 1000
        }
      },
      callback: {
        onClickLink: null
      },
      clientRoute: {
        getUserAlias: null,
        getUserAvatarFileName: null,
        getUserGuid: null,
        hasPermission: null,
        isPersonalDocument: null,
        checkDocLock: null,
        getOriginalDoc: null,
        saveDoc: null
      },
      // ios: {
      //   webViewHeight: 0, // ios 编辑时 webView 的高度
      //   toolbarHeight: 0  // ios 编辑时 webView 最上面工具栏的高度
      // },
      pc: {
        pluginModified: false
      },
      table: {
        colWidth: 120, //默认列宽
        colWidthMin: 30, //最小列宽
        rowHeightMin: 33 //最小行高
      },
      code: {
        lineWrapping: codeWrap
      }
    },

    locale: {},
    win: null,
    doc: null,
    body: null,
    scrollContainer: null,
    readonly: null,
    isShowPreview: false,
    isSetBodyFontSize: false,
    isWizTemplate: null,
    //判断是否正在进行中文输入法的标识（true 为正在进行中...）
    compositionStart: false,
    indexFilesPath: '',
    indexFilesFullPath: '',
    supportTouchEvent: false,
    frame: {
      toolbarDoc: null,
      toolbarContainer: null,
      bodyContainer: null
    },
    dependency: {
      files: {
        css: {
          fonts: dependencyUrl + '/fonts.css?v=' + CONST.version,
          github2: dependencyUrl + '/github2.css?v=' + CONST.version,
          wizToc: dependencyUrl + '/wizToc.css?v=' + CONST.version
        },
        cursor: {
          formatPainter: dependencyUrl + '/format-painter-wiz.cur?v=' + CONST.version
        },
        js: {
          codemirror: dependencyUrl + '/codemirror/codemirror.js?v=' + CONST.version,
          cmSimple: dependencyUrl + '/codemirror/addon/mode/simple.js?v=' + CONST.version,
          cmActiveLine: dependencyUrl + '/codemirror/addon/selection/active-line.js?v=' + CONST.version,
          cmMatchBrackets: dependencyUrl + '/codemirror/addon/edit/matchbrackets.js?v=' + CONST.version,
          cmMode: dependencyUrl + '/codemirror/mode/mode.js?v=' + CONST.version,
          flowchart: dependencyUrl + '/flowchart.js?v=' + CONST.version,
          jquery: dependencyUrl + '/jquery-3.3.1.js?v=' + CONST.version,
          mathJax: dependencyUrl + '/mathjax/MathJax.js?config=TeX-AMS-MML_SVG&v=' + CONST.version,
          prettify: dependencyUrl + '/prettify.js?v=' + CONST.version,
          raphael: dependencyUrl + '/raphael.js?v=' + CONST.version,
          sequence: dependencyUrl + '/sequence-diagram.js?v=' + CONST.version,
          underscore: dependencyUrl + '/underscore.js?v=' + CONST.version,
          wizContent: dependencyUrl + '/WizContent.js?v=' + CONST.wizContentVersion,
          wizTemplate: ''
        }
      },
      css: {
        fonts: ['fonts'],
        markdown: ['github2', 'wizToc']
      },
      js: {
        codeMirror: [['codemirror'], ['cmSimple', 'cmActiveLine', 'cmMatchBrackets', 'cmMode']],
        markdown: [['jquery'], ['prettify', 'raphael', 'underscore'], ['flowchart', 'sequence']],
        mathJax: [['jquery'], ['mathJax']],
        wizContent: [['wizContent']],
        wizTemplate: [['wizTemplate']]
      }
    },
    /**
     * 客户端类型 & 功能设置
     */
    client: {
      type: {
        isWeb: function () {
          return location && location.protocol.indexOf('http') === 0;
        }(),
        isWin: false,
        isMac: false,
        isLinux: false,
        isIOS: false,
        isAndroid: false,
        isPad: false,
        isPhone: false
      },
      sendCmdToWizClient: function sendCmdToWizClient() {}
    },
    browser: { //移动终端浏览器版本信息
      isAndroid: !!ua.match(/Android/i), //android终端
      isIOS: !!ua.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/i), //mac or ios终端
      isIPad: !!ua.match(/iPad/i), //iPad
      isIPhone: !!ua.match(/iPhone/i), //iPhone
      isLinux: !!ua.match(/Linux/i), //linux 系统
      isMac: !!ua.match(/Macintosh/i), //mac 系统
      isMobile: !!ua.match(/AppleWebKit.*Mobile.*/i), //移动终端
      isWeChat: !!ua.match(/MicroMessenger/i), //微信浏览器,
      isWindows: !!ua.match(/Window/i), //windows 系统
      isIe: !!ua.match(/msie|trident/i) //IE 浏览器
    },
    event: {
      add: function add(eventId, fun) {
        if (!eventId || !fun || checkFun(eventId, fun)) {
          return;
        }
        var eList = GlobalEvent[eventId];
        if (!eList) {
          eList = [];
        }
        eList.push(fun);
        GlobalEvent[eventId] = eList;

        function checkFun(eventId, fun) {
          if (!eventId || !fun) {
            return false;
          }
          var i = void 0,
              j = void 0,
              eList = GlobalEvent[eventId];

          if (!eList || eList.length === 0) {
            return false;
          }
          for (i = 0, j = eList.length; i < j; i++) {
            if (eList[i] === fun) {
              return true;
            }
          }
          return false;
        }
      },
      call: function call(eventId) {
        var i = void 0,
            j = void 0,
            args = [],
            eList = GlobalEvent[eventId];

        if (!eList || eList.length === 0) {
          return;
        }
        for (i = 1, j = arguments.length; i < j; i++) {
          args.push(arguments[i]);
        }
        // 避免某一个 eventId 执行过程中，导致其他 组件中删除该 eventId 的时间
        var eListTmp = [];
        for (i = 0, j = eList.length; i < j; i++) {
          eListTmp.push(eList[i]);
        }
        for (i = 0, j = eListTmp.length; i < j; i++) {
          eListTmp[i].apply(this, args);
        }
      },
      remove: function remove(eventId, fun) {
        if (!eventId || !fun) {
          return;
        }
        var i = void 0,
            j = void 0,
            eList = GlobalEvent[eventId];

        if (!eList || eList.length === 0) {
          return;
        }
        for (i = 0, j = eList.length; i < j; i++) {
          if (eList[i] === fun) {
            eList.splice(i, 1);
          }
        }
      }
    }
  };
}

var ENV = function ENV(_options) {
  var dependencyUrl = _options.dependencyUrl.replace(/\\/g, '/');
  var env = getDefaultEnv(dependencyUrl);

  setOptions(env.options, _options);
  env.readonly = null;

  var doc = env.options.document || window.document;
  var user = void 0;

  env.doc = doc;
  env.win = env.doc.defaultView;
  env.body = doc.body;
  env.frame.toolbarDoc = env.doc;
  domPatch.run(env.win);

  if (env.options.container === env.doc || env.options.container === env.body) {
    env.options.container = null;
    env.options.useFrame = false;
  } else if (!env.options.container) {
    env.frame.toolbarContainer = null;
    env.frame.bodyContainer = null;
  }

  // Web 端笔记必须要在笔记加载后处理，所以设置 isWizTemplate 转移到 initWizDocument 内进行
  // env.isWizTemplate = !!env.doc.querySelector('#wiz-template-info');
  if (env.options.wizTemplate.url) {
    env.dependency.files.js.wizTemplate = env.options.wizTemplate.url;
  }
  setClientType(env.options.clientType, env);

  // 以下规则由客户端控制
  // 根据 documentData 判断笔记是否允许 纯净阅读
  // let isOfficeDocument = /^\.(docx?|xlsx?|pptx?|pdf)$/i.test(env.options.documentData.fileType);
  // let isWizTemplate = env.doc.querySelector('#wiz-template-info');
  // let isWizDocument = env.doc.querySelector('#' + CONST.ID.WIZ_DEFAULT_STYLE);
  // if (isOfficeDocument || isWizTemplate) {
  //   env.options.pureReadMode.enable = false;
  // }
  // if (isWizDocument) {
  //   env.options.pureReadMode.needContentExtraction = false;
  // }

  // 笔记内 index_files 路径处理
  var filePath = decodeURIComponent(location.pathname),
      filePathStart = filePath.lastIndexOf('/') + 1,
      filePathEnd = filePath.lastIndexOf('.');
  // web 时， 此参数为错误值，所以无法处理，这是允许的。
  var filePreName = '';
  if (filePathEnd > 0) {
    filePreName = filePath.substring(filePathStart, filePathEnd);
  }
  env.indexFilesPath = filePreName + '_files';
  env.indexFilesFullPath = location.protocol + '//' + location.host + filePath.substr(0, filePathStart) + env.indexFilesPath + '/';

  // todoList 需要用到用户信息
  if (env.options.userNameEncoder === 'base64') {
    user = env.options.userInfo;
    if (user && user.user_name) {
      user.user_name = base64.decode(user.user_name);
    }
    if (env.options.userData) {
      for (var i = 0; i < env.options.usersData.length; i++) {
        user = env.options.usersData[i];
        user.user_name = base64.decode(user.user_name);
      }
    }
  }

  env.setOptions = function (_options) {
    setOptions(env.options, _options);
  };

  env.supportTouchEvent = env.client.type.isPhone || env.client.type.isPad || env.browser.isMobile || env.browser.isAndroid || env.browser.isIPad || env.browser.isIPhone || env.browser.isWeChat;

  return env;
};

module.exports = ENV;

},{"../libs/base64":396,"../libs/domPatch":398,"./const":388}],390:[function(require,module,exports){
'use strict';

require("babel-polyfill");

var CONST = require('../config/const');
var utils = require('../libs/utils');
var base64 = require('../libs/base64');
var xssUtils = require('../libs/xssUtils');
var domPatch = require('../libs/domPatch');
var LoadController = require('../libs/LoadController');
var dependLoader = require('../libs/dependLoader');
require('../tester/TesterForRunTime');

var loadController = new LoadController();

var ENV = require('../config/env');
var Lang = require('../locale/lang');
var Amend = require('../common/amendUtils/Amend');
var AmendInfo = require('../common/amendUtils/AmendInfo');
var AmendUser = require('../common/amendUtils/AmendUser');
var AmendUserAction = require('../common/amendUtils/AmendUserAction');
var AmendUtils = require('../common/amendUtils/AmendUtils');
var BlockCore = require('../common/blockUtils/BlockCore');
var BlockUtils = require('../common/blockUtils/BlockUtils');

var CodeCore = void 0,
    CodeStyle = void 0,
    CodeUtils = void 0;
CodeCore = require('../common/codeUtils/CodeCore');
CodeStyle = require('../common/codeUtils/CodeStyle');
CodeUtils = require('../common/codeUtils/CodeUtils');

var CommandExtend = require('../common/CommandExtend');

var ContentCore = void 0;
ContentCore = require('../common/contentUtils/ContentCore');

var ClipboardUtils = require('../common/ClipboardUtils');
var DomUtils = require('../common/DomUtils');
var Editor = require('../common/editorCore/Editor');
var EditorEvent = require('../common/editorCore/EditorEvent');
var EditorUtils = require('../common/editorCore/EditorUtils');
var FormatPainter = require('../common/FormatPainter');
var FrameViewCore = require('../common/frameViewUtils/FrameViewCore');
var FrameViewStyle = require('../common/frameViewUtils/FrameViewStyle');
var FrameViewUtils = require('../common/frameViewUtils/FrameViewUtils');
var HighlightUtils = require('../common/HighlightUtils');
var HistoryUtils = require('../common/HistoryUtils');
var ImgClick = require('../common/imgUtils/ImgClick');
var ImgCore = require('../common/imgUtils/ImgCore');
var ImgResize = require('../common/imgUtils/ImgResize');
var ImgUtils = require('../common/imgUtils/ImgUtils');
var SvgClick = require('../common/imgUtils/SvgClick');
var LinkUtils = require('../common/LinkUtils');

var MarkdownRender = void 0;
MarkdownRender = require('../common/MarkdownRender');

var MathJaxRender = void 0;
MathJaxRender = require('../common/MathJaxRender');

var NightModeUtils = void 0;
NightModeUtils = require('../common/NightModeUtils');

var PasteUtils = require('../common/PasteUtils');
var RangeUtils = require('../common/RangeUtils');
var Reader = require('../common/readerCore/Reader');
var ReaderEvent = require('../common/readerCore/ReaderEvent');
var SelectPlugin = require('../common/SelectPlugin');
var TabKey = require('../common/TabKey');
var TableCore = require('../common/tableUtils/TableCore');
var TableMenu = require('../common/tableUtils/TableMenu');
var TableUtils = require('../common/tableUtils/TableUtils');
var TableZone = require('../common/tableUtils/TableZone');

var TodoCore = void 0,
    TodoRouteForClient = void 0,
    TodoStyle = void 0,
    TodoUtils = void 0;
TodoCore = require('../common/todoUtils/TodoCore');
TodoRouteForClient = require('../common/todoUtils/TodoRouteForClient');
TodoStyle = require('../common/todoUtils/TodoStyle');
TodoUtils = require('../common/todoUtils/TodoUtils');

var ToolbarMarkdown = void 0;
ToolbarMarkdown = require('../common/frameViewUtils/ToolbarMarkdown');

var WizStyle = require('../common/WizStyle');

var WizDocument = function WizDocument(documentOptions, coreCallback) {
  // let debugTimerId = 'WizDocument Init';
  // window.wizDebugTimer.start(debugTimerId);

  var env = new ENV(documentOptions);
  // window.wizDebugTimer.add(debugTimerId, 'new ENV(documentOptions);');

  var core = {
    env: env,
    lang: new Lang(env.options.lang, env),
    require: {
      amend: new Amend(),
      amendInfo: new AmendInfo(),
      amendUser: new AmendUser(),
      amendUserAction: new AmendUserAction(),
      amendUtils: new AmendUtils(),
      blockCore: new BlockCore(),
      blockUtils: new BlockUtils(),
      codeCore: CodeCore ? new CodeCore() : null,
      codeStyle: CodeStyle ? new CodeStyle() : null,
      codeUtils: CodeUtils ? new CodeUtils() : null,
      commandExtend: new CommandExtend(),
      contentCore: ContentCore ? new ContentCore() : null,
      clipboardUtils: new ClipboardUtils(),
      domUtils: new DomUtils(),
      editor: new Editor(),
      editorEvent: new EditorEvent(),
      editorUtils: new EditorUtils(),
      formatPainter: new FormatPainter(),
      frameViewCore: new FrameViewCore(),
      frameViewStyle: new FrameViewStyle(),
      frameViewUtils: new FrameViewUtils(),
      highlightUtils: new HighlightUtils(),
      historyUtils: new HistoryUtils(),
      imgClick: new ImgClick(),
      imgCore: new ImgCore(),
      imgResize: new ImgResize(),
      imgUtils: new ImgUtils(),
      linkUtils: new LinkUtils(),
      markdownRender: MarkdownRender ? new MarkdownRender() : null,
      MathJaxRender: MathJaxRender || null,
      mathJaxRender: MathJaxRender ? new MathJaxRender() : null,
      nightModeUtils: NightModeUtils ? new NightModeUtils() : null,
      pasteUtils: new PasteUtils(),
      rangeUtils: new RangeUtils(),
      reader: new Reader(),
      readerEvent: new ReaderEvent(),
      selectPlugin: new SelectPlugin(),
      svgClick: new SvgClick(),
      tabKey: new TabKey(),
      tableCore: new TableCore(),
      tableMenu: new TableMenu(),
      tableUtils: new TableUtils(),
      tableZone: new TableZone(),
      todoCore: TodoCore ? new TodoCore() : null,
      todoRouteForClient: TodoRouteForClient ? new TodoRouteForClient() : null,
      todoStyle: TodoStyle ? new TodoStyle() : null,
      todoUtils: TodoUtils ? new TodoUtils() : null,
      toolbarMarkdown: ToolbarMarkdown ? new ToolbarMarkdown() : null,
      wizStyle: new WizStyle()
    }
  };

  for (var _iterator = Object.keys(core.require), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var key = _ref;

    var lib = core.require[key];
    if (lib && lib.initCore) {
      lib.initCore(core);
      delete lib.initCore;
    }
  }
  // window.wizDebugTimer.add(debugTimerId, 'init core');

  var reader = core.require.reader;
  var editor = core.require.editor;
  var editorEvent = core.require.editorEvent;
  var amend = core.require.amend;
  var amendInfo = core.require.amendInfo;
  var amendUser = core.require.amendUser;
  var commandExtend = core.require.commandExtend;
  var contentCore = core.require.contentCore;
  var codeCore = core.require.codeCore;
  var codeUtils = core.require.codeUtils;
  var domUtils = core.require.domUtils;
  var editorUtils = core.require.editorUtils;
  var formatPainter = core.require.formatPainter;
  var frameViewUtils = core.require.frameViewUtils;
  var highlightUtils = core.require.highlightUtils;
  var historyUtils = core.require.historyUtils;
  var imgUtils = core.require.imgUtils;
  var linkUtils = core.require.linkUtils;
  var markdownRender = core.require.markdownRender;
  var mathJaxRender = core.require.mathJaxRender;
  var nightModeUtils = core.require.nightModeUtils;
  var pasteUtils = core.require.pasteUtils;
  var rangeUtils = core.require.rangeUtils;
  var tableCore = core.require.tableCore;
  var todoCore = core.require.todoCore;
  var toolbarMarkdown = core.require.toolbarMarkdown;
  var wizStyle = core.require.wizStyle;

  var noteSrcIsText = false;
  var noteSrc = '';

  initFrame();

  var loadWizTemplate = function loadWizTemplate(callback) {
    loadController.addCallback(env.doc, callback);
    if (loadController.getLoading(env.doc)) {
      return;
    }
    if (typeof env.win.WizTemplate === 'undefined') {
      loadController.setLoading(env.doc, true);
      dependLoader.loadJs(env.doc, dependLoader.getDependencyFiles(env.dependency, 'js', 'wizTemplate'), function () {
        loadController.setLoading(env.doc, false);
        loadController.callback(env.doc);
      });
    } else {
      loadController.callback(env.doc);
    }
  };

  var initWizDocument = function initWizDocument(callback) {
    env.scrollContainer = domUtils.getScrollContainer();
    env.isWizTemplate = !!env.doc.querySelector('#wiz-template-info');
    // window.wizDebugTimer.add(debugTimerId, 'initFrame');

    if (markdownRender) {
      markdownRender.init();
    }
    // window.wizDebugTimer.add(debugTimerId, 'markdownRender.init();');

    if (mathJaxRender) {
      mathJaxRender.init();
    }
    // window.wizDebugTimer.add(debugTimerId, 'mathJaxRender.init();');

    // 修正 旧bug 造成的 body 错误 class：
    var bodyClassList = env.body.className.split(' ');
    var bodyClass = void 0;
    for (var i = bodyClassList.length - 1; i >= 0; i--) {
      bodyClass = bodyClassList[i];
      if (!bodyClass || /^wiz-/ig.test(bodyClass)) {
        //删除所有 wiz- 开头的 class
        bodyClassList.splice(i, 1);
      }
    }
    env.body.className = bodyClassList.join(' ');
    domUtils.addClass(env.body, CONST.CLASS.WIZ_BODY);
    // window.wizDebugTimer.add(debugTimerId, '修正 旧bug 造成的 body 错误 class');

    if (!env.options.noAmend) {
      amendUser.initUser();
      amendUser.setUsersData();
    }
    // window.wizDebugTimer.add(debugTimerId, 'init amendUser');

    var onLoadWizTemplate = function onLoadWizTemplate() {
      if (env.win.WizTemplate) {
        env.win.WizTemplate.init({
          document: env.doc,
          lang: env.options.lang,
          clientType: env.options.clientType
        });
      }
      callback();
    };

    if (env.isWizTemplate && env.options.wizTemplate.url) {
      loadWizTemplate(onLoadWizTemplate);
    } else {
      onLoadWizTemplate();
    }
  };

  var insertDocHtml = function insertDocHtml(docHtml) {
    if (env.options.useFrame) {
      env.doc.open("text/html", "replace");
      env.doc.write(docHtml);
      env.doc.close();
      env.body = env.doc.body;
    } else {
      env.body.innerHTML = docHtml;
    }
    domUtils.attr(env.body, { spellcheck: 'false' });
    domPatch.run(env.win);

    if (env.client.type.isWeb) {
      // web 端自动加入 默认样式
      var onlyReplace = false;
      var customCss = '';
      wizStyle.insertDefaultStyle(onlyReplace, customCss);
    }
  };

  // window.wizDebugTimer.add(debugTimerId, 'WizTemplate.init');

  var documentInstance = {
    version: CONST.version,
    destroy: function destroy() {
      if (env.win.WizTemplate) {
        env.win.WizTemplate.off();
      }
      env.isWizTemplate = false;
      editor.offEvent();
      reader.offEvent({});
      env.body.innerHTML = '';
      env.readonly = null;
    },
    setOptions: env.setOptions,
    editor: {
      on: function on(options, callback) {
        // let debugTimerId = 'WizDocument.editor.on()';
        // window.wizDebugTimer.start(debugTimerId);

        if (env.readonly === false) {
          return;
        }
        var scrollTopLast = domUtils.getPageScroll().top;

        var _callback = function _callback() {
          // window.wizDebugTimer.add(debugTimerId, 'editor.on _callback');
          if (env.readonly === true) {
            // 避免频繁切换 阅读、编辑模式
            return;
          }
          // console.log('wizEditor on callback');
          // console.log('isWin: ' + env.client.type.isWin + ', isWeb: ' + env.client.type.isWeb);
          if (env.win.WizTemplate) {
            env.win.WizTemplate.on(false);
            // window.wizDebugTimer.add(debugTimerId, 'WizTemplate.on()');
          }

          if (env.options.editor.autoFocus) {
            if (env.win.WizTemplate && env.win.WizTemplate.getTemplate()) {
              env.win.WizTemplate.focus();
            } else {
              documentInstance.editor.focus();
            }
          }

          setTimeout(function () {
            if (!env.client.type.isPhone && !env.client.type.isPad) {
              if (env.client.type.isMac && env.options.reader.type !== CONST.NOTE_READER_TYPE.COMMON) {
                setTimeout(function () {
                  domUtils.setPageScrollTop(scrollTopLast);
                }, 100);
              } else {
                domUtils.setPageScrollTop(scrollTopLast);
              }
              // window.wizDebugTimer.add(debugTimerId, 'setPageScrollTop');
            }

            if (nightModeUtils) {
              nightModeUtils.on();
            }
            // window.wizDebugTimer.add(debugTimerId, 'nightModeUtils.on');

            if (typeof callback === 'function') {
              callback();
            }
            // window.wizDebugTimer.end(debugTimerId);
          }, 0);
        };

        // 最大限度适配客户端代码
        if (typeof options === 'function') {
          callback = options;
          options = {};
        }
        options = options || {};
        var docBody = options.documentBody;
        var docBodyType = options.documentBodyType;
        if (typeof options.htmlBaseUrl !== 'undefined') {
          env.options.htmlBaseUrl = options.htmlBaseUrl;
        }
        if (typeof options.minHeight !== 'undefined') {
          env.options.editor.minHeight = options.minHeight;
        }

        var readerOptions = {
          noteSrc: null,
          useContentExtractionHtml: options.useContentExtractionHtml
        };
        if (typeof docBody !== 'string' && noteSrcIsText) {
          readerOptions.noteSrc = xssUtils.xssFilter(utils.txt2HTML(noteSrc, { wizTableSaveDom: true }));
        }

        // window.wizDebugTimer.add(debugTimerId, 'before reader.off()');
        var onInitWizDocument = function onInitWizDocument() {
          documentInstance.reader.amendInfo.off();
          if (env.win.WizTemplate) {
            env.win.WizTemplate.off();
          }
          env.readonly = false;
          if (contentCore) {
            contentCore.on({});
          }
          // window.wizDebugTimer.add(debugTimerId, 'contentCore.on 最可疑！！');
          editor.on(_callback);
        };

        var onReaderOff = function onReaderOff() {
          // window.wizDebugTimer.add(debugTimerId, 'after reader.off()');

          if (typeof docBody === 'string') {
            if (docBodyType === 'text') {
              // 专门支持 Markdown 源码
              env.body.innerHTML = xssUtils.xssFilter(utils.txt2HTML(docBody, { wizTableSaveDom: true }));
            } else {
              docBody = xssUtils.xssFilter(docBody);
              docBody = domUtils.initDocHtml(docBody);

              insertDocHtml(docBody);
            }
            // window.wizDebugTimer.add(debugTimerId, 'innerHTML  documentBody');
          }

          initWizDocument(onInitWizDocument);
        };

        reader.off(readerOptions, onReaderOff);
      },
      /**
       * 备份光标位置
       */
      caretBackup: function caretBackup() {
        return rangeUtils.caretBackup();
      },
      execCommand: function execCommand() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        historyUtils.saveSnap(false);
        return commandExtend.execCommand.apply(documentInstance, args);
      },
      /**
       * 在编辑时，查找指定文本
       */
      find: function find(str, matchcase, searchBackward, loop) {
        return editorUtils.find(str, matchcase, searchBackward, loop);
      },
      /**
       * 让 body 获取焦点
       */
      focus: function focus() {
        domUtils.focus();
      },
      /**
       * 获取 body 内正文，用于生成摘要
       */
      getBodyText: function getBodyText() {
        return domUtils.getBodyText();
      },
      /**
       * 获取当前页面源码
       */
      getContentHtml: function getContentHtml(options) {
        // 只有当客户端获取笔记内容进行保存时，才做这些清理操作

        // 清理子节点时，必须放弃光标所在位置，否则会导致光标跳动
        var excludeList = [];
        var range = rangeUtils.getRange();
        var parent = void 0,
            start = void 0,
            startOffset = void 0,
            end = void 0,
            endOffset = void 0;
        if (range) {
          parent = domUtils.getParentRoot([range.startContainer, range.endContainer]);
          if (parent) {
            excludeList = [parent];
          }
          start = range.startContainer;
          startOffset = range.startOffset;
          end = range.endContainer;
          endOffset = range.endOffset;
        }
        domUtils.clearChild(env.body, null, 0);
        if (range && codeUtils && !codeUtils.getContainerFromChild(start)) {
          // clearChild 后，应该修正 range
          rangeUtils.setRange(start, startOffset, end, endOffset);
        }

        domUtils.clearChildSpan(env.body, excludeList);

        amend.hideAmendInfo();
        if (todoCore) {
          todoCore.checkTodoStyle();
        }

        return domUtils.getContentHtml(options);
      },
      getMarkdownSrc: function getMarkdownSrc(options) {
        if (markdownRender) {
          return markdownRender.getMarkdownSrcForEditor(options);
        }
        return '';
      },
      /**
       * 在光标位置插入 base64 格式的html
       */
      insertB64Html: function insertB64Html(b64Html, notInsertEmptyDiv) {
        editorUtils.insertHtml(base64.decode(b64Html), notInsertEmptyDiv);
      },
      /**
       * 在光标位置插入 html
       */
      insertHtml: function insertHtml(html, notInsertEmptyDiv) {
        if (env.readonly === false) {
          historyUtils.saveSnap(false);
          editorUtils.insertHtml(html, notInsertEmptyDiv);
        }
      },
      /**
       * 判断编辑内容是否被修改
       */
      isModified: function isModified() {
        // var result = (!env.readonly && domUtils.getContentHtml() != editor.getOriginalHtml());
        // console.log('\n\n\n-------------------------------' + result + '--------------------------------------------------------------------------------------------\n\n\n');
        // if (result) {
        //     console.log(domUtils.getContentHtml());
        //     console.log('\n\n\n---------------------------------------------------------------------------------------------------------------------------\n\n\n');
        //     console.log(editor.getOriginalHtml());
        //     console.log('\n\n\n---------------------------------------------------------------------------------------------------------------------------\n\n\n');
        // }
        var result = env.readonly === false;
        if (!result) {
          return result;
        }
        var curHtml = domUtils.getContentHtml();
        var originalHtml = editor.getOriginalHtml();
        curHtml = domUtils.removeByTagFromHtml(curHtml, CONST.TAG.CODE_MIRROR);
        originalHtml = domUtils.removeByTagFromHtml(originalHtml, CONST.TAG.CODE_MIRROR);
        return env.readonly === false && curHtml !== originalHtml;
      },
      /**
       * 修改光标选中文本的样式 和 属性
       */
      modifySelectionDom: function modifySelectionDom(style, attr) {
        historyUtils.saveSnap(false);
        editorUtils.modifySelectionDom(style, attr);
      },
      paste: function paste(html, txt) {
        if (env.readonly === false) {
          pasteUtils.pasteFromClient(html, txt);
        }
      },
      pasteB64: function pasteB64(b64Html, b64Txt) {
        var html = base64.decode(b64Html);
        var txt = base64.decode(b64Txt);
        documentInstance.editor.paste(html, txt);
      },
      /**
       * 编辑器 redo
       */
      redo: function redo() {
        historyUtils.redo();
      },
      removeFormat: function removeFormat(removeAll, isRemoveColor, isRemoveAllStyles) {
        historyUtils.saveSnap(false);
        wizStyle.removeFormat(removeAll, isRemoveColor, isRemoveAllStyles);
      },
      replace: function replace(from, to, matchcase) {
        return editorUtils.replace(from, to, matchcase);
      },
      replaceAll: function replaceAll(from, to, matchcase) {
        historyUtils.saveSnap(false);
        editorUtils.replaceAll(from, to, matchcase);
      },
      replaceSvg: function replaceSvg(dataList) {
        if (typeof dataList === 'string') {
          dataList = JSON.parse(dataList);
        }
        historyUtils.saveSnap(false);
        editorUtils.replaceSvg(dataList);
      },
      /**
       * 恢复已备份光标位置
       */
      caretRestore: function caretRestore() {
        return rangeUtils.caretRestore();
      },
      /**
       * 编辑器 保存快照
       */
      saveSnap: function saveSnap() {
        historyUtils.saveSnap(false);
      },
      // /**
      //  * 专门针对 IOS 修正光标位置
      //  */
      // setWebViewSizeForFixScroll: (data) => {
      //   data = JSON.parse(base64.decode(data));
      //   env.options.ios.webViewHeight = data.height;
      //   env.options.ios.toolbarHeight = data.toolbarHeight;
      // },
      /**
       * 设置当前文档为 未修改状态
       */
      setUnModified: function setUnModified() {
        editor.setOriginalHtml();
      },
      /**
       * 编辑器 undo
       */
      undo: function undo() {
        historyUtils.undo();
      },
      ListenerType: editorEvent.TYPE,
      addListener: function addListener(eName, fun) {
        editorEvent.addListener(eName, fun);
      },
      removeListener: function removeListener(eName, fun) {
        editorEvent.removeListener(eName, fun);
      },
      triggerListener: function triggerListener(eName, params) {
        editorEvent.triggerListener(eName, params);
      },
      startTrackEvent: function startTrackEvent(eventName, id) {
        editorEvent.startTrackEvent(eventName, id);
      },
      stopTrackEvent: function stopTrackEvent(eventName, id) {
        editorEvent.stopTrackEvent(eventName, id);
      },
      amend: {
        /**
         * 开启 修订功能
         */
        on: function on() {
          amend.start();
        },
        /**
         * 关闭 修订功能
         */
        off: function off() {
          //关闭 修订功能 需要同时开启 逆修订功能
          amend.startReverse();
        },
        changeCurUser: function changeCurUser(user) {
          amend.changeCurUser(user);
        },
        /**
         * 获取 笔记是否被进行过 修订编辑
         */
        isEdited: function isEdited() {
          return amend.isAmendEdited();
        },
        /**
         * 获取 笔记当前 修订状态
         */
        isEditing: function isEditing() {
          return amend.isAmendEditing();
        },
        /**
         * 判断当前光标位置是否处于修订标签内
         */
        hasAmendSpanByCursor: function hasAmendSpanByCursor() {
          return amend.hasAmendSpanByCursor();
        },
        /**
         * 接受 修订内容， 清理所有修订的标签
         */
        accept: function accept(options) {
          amend.accept(initAmendAcceptOptions(options));
        },
        /**
         * 拒绝 修订内容， 恢复原内容
         */
        refuse: function refuse(options) {
          amend.refuse(initAmendAcceptOptions(options));
        }
      },
      code: {
        insertCode: function insertCode() {
          if (codeCore) {
            codeCore.insertCode();
          }
        }
      },
      formatPainter: {
        on: function on(keep) {
          return formatPainter.on(keep);
        },
        off: function off() {
          formatPainter.off();
        }
      },
      img: {
        getAll: function getAll(onlyLocal) {
          //为了保证客户端使用方便，转换为字符串
          return imgUtils.getAll(onlyLocal).join(',');
        },
        insertAsAttachment: function insertAsAttachment(guid, imgPath) {
          historyUtils.saveSnap(false);
          editorUtils.insertDom(imgUtils.makeAttachmentDom(guid, imgPath), true);
        },
        insertByPath: function insertByPath(imgPath) {
          historyUtils.saveSnap(false);
          editorUtils.insertDom(imgUtils.makeDomByPath(imgPath), true);
        },
        removeCur: function removeCur() {
          historyUtils.saveSnap(false);
          var selector = 'img[' + CONST.ATTR.IMG_EDITING + ']';
          imgUtils.remove(selector);
        },
        replaceCur: function replaceCur(targetSrc) {
          historyUtils.saveSnap(false);
          var selector = 'img[' + CONST.ATTR.IMG_EDITING + ']';
          imgUtils.replaceSrc(selector, targetSrc);
        }
      },
      link: {
        /**
         * 开启 自动设置 超链接功能
         */
        on: function on() {
          linkUtils.on();
        },
        /**
         * 关闭 自动设置 超链接功能
         */
        off: function off() {
          linkUtils.off();
        },
        /**
         * 获取光标位置的超链接 URL
         */
        getCurrentLink: function getCurrentLink() {
          return linkUtils.getCurrentLink();
        },
        /**
         * 移除选中的 <a> 标签的超链接
         */
        removeSelectedLink: function removeSelectedLink() {
          linkUtils.removeSelectedLink();
        },
        /**
         * 设置当前选中区域超链接，或在光标处添加超链接
         */
        setCurrentLink: function setCurrentLink(url) {
          linkUtils.setCurrentLink(url);
        }
      },
      range: {
        moveToPoint: function moveToPoint(x, y) {
          rangeUtils.moveToPoint(x, y);
        }
      },
      table: {
        canCreateTable: tableCore.canCreateTable,
        clearCellValue: tableCore.clearCellValue,
        deleteCols: tableCore.deleteCols,
        deleteRows: tableCore.deleteRows,
        deleteTable: tableCore.deleteTable,
        distributeCols: tableCore.distributeCols,
        insertCol: tableCore.insertCol,
        insertRow: tableCore.insertRow,
        insertTable: tableCore.insertTable,
        merge: tableCore.merge,
        setCellAlign: tableCore.setCellAlign,
        setCellBg: tableCore.setCellBg,
        split: tableCore.split
      },
      todo: {
        setTodo: function setTodo() {
          if (todoCore) {
            todoCore.setTodo();
          }
        },
        setTodoInfo: function setTodoInfo(options) {
          if (todoCore) {
            todoCore.setTodoInfo(options);
          }
        }
      },
      utils: {
        clearStyleFromHtml: function clearStyleFromHtml(html, whiteList) {
          historyUtils.saveSnap(false);
          return domUtils.clearStyleFromHtml(html, whiteList);
        }
      },
      toolbar: {
        setImgUploaderId: function setImgUploaderId(uploaderId) {
          if (toolbarMarkdown) {
            toolbarMarkdown.setImgUploaderId(uploaderId);
          }
        },
        onImgUploadBegin: function onImgUploadBegin(imgId, imgName) {
          if (toolbarMarkdown) {
            toolbarMarkdown.onImgUploadBegin(imgId, imgName);
          }
        },
        onImgUploadProgress: function onImgUploadProgress(imgId, progress) {
          if (toolbarMarkdown) {
            toolbarMarkdown.onImgUploadProgress(imgId, progress);
          }
        },
        onImgUploadComplete: function onImgUploadComplete(imgId, url) {
          if (toolbarMarkdown) {
            toolbarMarkdown.onImgUploadComplete(imgId, url);
          }
        },
        onImgUploadError: function onImgUploadError(imgId) {
          if (toolbarMarkdown) {
            toolbarMarkdown.onImgUploadError(imgId);
          }
        }
      }
    },
    reader: {
      on: function on(options, callback) {
        // let debugTimerId = 'WizDocument.reader.on()';
        // window.wizDebugTimer.start(debugTimerId);

        if (env.readonly === true) {
          return;
        }
        options = options || {};
        if (options.noteType) {
          // 兼容旧代码
          options.reader = { type: options.noteType };
          delete options.noteType;
        }
        if (typeof options.minHeight !== 'undefined') {
          env.options.reader.minHeight = options.minHeight;
        }

        var scrollTopLast = domUtils.getPageScroll().top;

        // 最大限度适配客户端代码
        if (typeof options === 'function') {
          callback = options;
          options = {};
        }
        if (typeof options.htmlBaseUrl !== 'undefined') {
          env.options.htmlBaseUrl = options.htmlBaseUrl;
        }

        if (options.reader && options.reader.type) {
          env.options.reader.type = options.reader.type;
        }
        env.options.pc.pluginModified = false;
        var docBody = options.documentBody;
        var docBodyType = options.documentBodyType;

        noteSrcIsText = false;
        noteSrc = '';
        if (typeof docBody === 'string') {
          if (env.options.reader.type === CONST.NOTE_READER_TYPE.MARKDOWN) {
            env.body.style.opacity = '0';
          }
          if (docBodyType === 'text') {
            noteSrcIsText = true;
            noteSrc = docBody;
          } else {
            docBody = xssUtils.xssFilter(docBody);
            docBody = domUtils.initDocHtml(docBody);

            insertDocHtml(docBody);
          }
        }

        var onInitWizDocument = function onInitWizDocument() {
          if (env.win.WizTemplate) {
            env.win.WizTemplate.off();
            // window.wizDebugTimer.add(debugTimerId, 'WizTemplate.off()');
          }
          editor.off();
          // window.wizDebugTimer.add(debugTimerId, 'editor.off()');

          reader.on();
          // window.wizDebugTimer.add(debugTimerId, 'reader.on()');

          documentInstance.reader.amendInfo.on();
          // window.wizDebugTimer.add(debugTimerId, 'reader.amendInfo.on()');

          if (env.win.WizTemplate) {
            env.win.WizTemplate.on(true);
            // window.wizDebugTimer.add(debugTimerId, 'WizTemplate.on()');
          }

          if (markdownRender && env.options.reader.type === CONST.NOTE_READER_TYPE.MARKDOWN) {
            // window.wizDebugTimer.add(debugTimerId, 'markdown start!');
            if (docBodyType === 'text') {
              markdownRender.do({ container: env.body, markdownSrc: docBody }, _callback);
            } else {
              markdownRender.do({ container: env.body }, _callback);
            }
          } else if (mathJaxRender && env.options.reader.type === CONST.NOTE_READER_TYPE.MATHJAX) {
            // window.wizDebugTimer.add(debugTimerId, 'mathJax start!');
            mathJaxRender.do({ container: env.body }, _callback);
          } else {
            // setTimeout(() => {
            _callback();
            // }, 0);
          }
        };

        initWizDocument(onInitWizDocument);

        // window.wizDebugTimer.add(debugTimerId, 'ready for reader.on');

        function _callback() {
          // window.wizDebugTimer.add(debugTimerId, 'reader.on _callback()');

          if (env.readonly === false) {
            // 避免频繁切换 阅读、编辑模式
            return;
          }

          reader.afterRender(function () {
            // window.wizDebugTimer.add(debugTimerId, 'reader.afterRender callback()');

            if (!env.client.type.isPhone && !env.client.type.isPad) {
              domUtils.setPageScrollTop(scrollTopLast);
              // window.wizDebugTimer.add(debugTimerId, 'setPageScrollTop()');
            }

            env.body.style.opacity = '1';

            if (nightModeUtils) {
              nightModeUtils.on();
            }

            if (typeof callback === 'function') {
              callback();
              // window.wizDebugTimer.add(debugTimerId, 'outer callback()');
            }

            // 判断是否需要进行内容提取
            if (env.options.pureReadMode.enable) {
              documentInstance.reader.pureRead.on();
            }

            // window.wizDebugTimer.end(debugTimerId);
          });
        }
      },
      closeDocument: function closeDocument() {
        return todoCore ? todoCore.closeDocument() : null;
      },
      getRenderDocument: function getRenderDocument() {
        amend.hideAmendInfo();
        return domUtils.getRenderDocument();
      },
      getWordCount: function getWordCount() {
        var text = env.body.innerText ? env.body.innerText : '';
        var count = utils.getWordCount(text);
        return JSON.stringify(count);
      },
      setPluginModify: function setPluginModify(flag) {
        if (env.options.pc.pluginModified) {
          return env.options.pc.pluginModified;
        }

        // markdown/mathjax 笔记不允许 plugin 修改状态
        if (env.options.reader.type === CONST.NOTE_READER_TYPE.COMMON) {
          env.options.pc.pluginModified = !!flag;
        }

        return env.options.pc.pluginModified;
      },
      amendInfo: {
        on: function on() {
          if (env.options.noAmend) {
            return;
          }
          amendInfo.init({
            readonly: true
          }, {
            onAccept: null,
            onRefuse: null
          });
        },
        off: function off() {
          amendInfo.remove();
        }
      },
      highlight: {
        next: function next() {
          highlightUtils.next();
        },
        off: function off() {
          highlightUtils.off();
        },
        on: function on(keyList, focusFirst) {
          return highlightUtils.on(keyList, focusFirst);
        },
        previous: function previous() {
          highlightUtils.previous();
        }
      },
      pureRead: {
        on: function on(options) {
          env.options.pureReadMode.enable = true;
          options = options || {};

          // 开启内容提取
          // window.wizDebugTimer.add(debugTimerId, '内容提取 start!');
          // setTimeout(() => {
          if (contentCore) {
            contentCore.on({
              needContentExtraction: options.needContentExtraction
            }, function () {});
          }
          // }, 200);
        },
        off: function off() {
          env.options.pureReadMode.enable = false;
          if (contentCore) {
            contentCore.off();
          }
        }
      },
      todo: {
        setTodoInfo: function setTodoInfo(options) {
          if (todoCore) {
            todoCore.setTodoInfo(options);
          }
        },
        onCheckDocLock: function onCheckDocLock(cancel, needCallAgain) {
          if (todoCore) {
            todoCore.onCheckDocLock(cancel, needCallAgain);
          }
        }
      }
    },
    frame: {
      adjustContainerSize: frameViewUtils.onAdjustContainerSize
    },
    nightMode: {
      on: function on(color, bgColor, brightness) {
        env.options.nightMode.enable = true;
        if (nightModeUtils) {
          nightModeUtils.on(color, bgColor, brightness);
        }
      },
      off: function off() {
        env.options.nightMode.enable = true;
        if (nightModeUtils) {
          nightModeUtils.off();
        }
      }
    },
    insertCustomStyle: function insertCustomStyle(id, customCss, isTemp) {
      wizStyle.insertCustomStyle(id, customCss, isTemp);
    },
    insertDefaultStyle: function insertDefaultStyle(onlyReplace, customCss) {
      wizStyle.insertDefaultStyle(onlyReplace, customCss);
    },
    removeStyleById: function removeStyleById(id) {
      wizStyle.removeStyleById(id);
    }
  };
  // window.wizDebugTimer.add(debugTimerId, 'init documentInstance');

  // 专门用于继承使用
  if (coreCallback) {
    coreCallback(core);
    // window.wizDebugTimer.add(debugTimerId, 'coreCallback(core);');
  }
  // window.wizDebugTimer.end(debugTimerId);
  return documentInstance;

  function initFrame() {
    var toolbarDoc = void 0,
        toolbarContainer = void 0,
        bodyContainer = void 0,
        iframe = void 0,
        body = void 0;
    var editorContainer = env.options.container;

    if (!editorContainer) {
      env.frame.toolbarContainer = null;
      env.frame.bodyContainer = null;
      return;
    }

    // 检查 Toolbar
    toolbarContainer = editorContainer.querySelector('.' + CONST.CLASS.WIZ_EIDTOR_TOOlBAR_CONTAINER);
    if (!toolbarContainer) {
      editorContainer.innerHTML = '';
      domUtils.addClass(editorContainer, CONST.CLASS.EDITOR_CONTAINER);
      toolbarContainer = env.doc.createElement('div');
      toolbarDoc = env.doc;
      domUtils.addClass(toolbarContainer, CONST.CLASS.WIZ_EIDTOR_TOOlBAR_CONTAINER);
      editorContainer.appendChild(toolbarContainer);
    }

    // 检查 body 容器
    bodyContainer = editorContainer.querySelector('.' + CONST.CLASS.WIZ_EIDTOR_BODY_CONTAINER);
    if (!bodyContainer) {
      bodyContainer = env.doc.createElement('div');
      domUtils.addClass(bodyContainer, CONST.CLASS.WIZ_EIDTOR_BODY_CONTAINER);
      editorContainer.appendChild(bodyContainer);
    }
    if (env.options.useFrame) {
      // 需要 iframe 隔离展示文档
      iframe = editorContainer.querySelector('.' + CONST.CLASS.WIZ_EIDTOR_IFRAME);
      if (!iframe) {
        iframe = env.doc.createElement('iframe');
        domUtils.addClass(iframe, CONST.CLASS.WIZ_EIDTOR_IFRAME);
        domUtils.attr(iframe, {
          frameborder: '0',
          width: '100%',
          height: '100%'
        });
        bodyContainer.appendChild(iframe);
        // 兼容 Edge，
        var iframeDoc = iframe.contentDocument;
        iframeDoc.open();
        // iframeDoc.write("<!DOCTYPE html><html><head></head><body><div><br/></div></body></html>");
        iframeDoc.write(CONST.EMPTY_NOTE_TEMPLATE.replace('${body}', '<div><br/></div>'));
        iframeDoc.close();
      }
      env.doc = iframe.contentDocument;
      env.win = iframe.contentWindow;
      env.body = env.doc.body;
      domPatch.run(env.win);
    } else {
      // 直接使用 div 展示文档
      body = bodyContainer.querySelector('.' + CONST.CLASS.WIZ_BODY);
      if (!body) {
        body = env.doc.createElement('div');
        body.innerHTML = '<div><br/></div>';
        bodyContainer.appendChild(body);
      }
      env.body = body;
    }
    domUtils.attr(env.body, { spellcheck: 'false' });
    env.frame.toolbarDoc = toolbarDoc;
    env.frame.toolbarContainer = toolbarContainer;
    env.frame.bodyContainer = bodyContainer;
  }

  function initAmendAcceptOptions(options) {
    if (!options) {
      options = {
        dom: null,
        cursor: false,
        total: true
      };
    } else {
      options.total = !!options.total;
      // options.dom = options.dom;
      options.cursor = !!options.cursor;
    }
    return options;
  }
};

window.WizDocument = WizDocument;
WizDocument.version = CONST.version;

module.exports = WizDocument;

},{"../common/ClipboardUtils":340,"../common/CommandExtend":341,"../common/DomUtils":342,"../common/FormatPainter":343,"../common/HighlightUtils":344,"../common/HistoryUtils":345,"../common/LinkUtils":346,"../common/MarkdownRender":347,"../common/MathJaxRender":348,"../common/NightModeUtils":349,"../common/PasteUtils":350,"../common/RangeUtils":351,"../common/SelectPlugin":352,"../common/TabKey":353,"../common/WizStyle":354,"../common/amendUtils/Amend":355,"../common/amendUtils/AmendInfo":356,"../common/amendUtils/AmendUser":357,"../common/amendUtils/AmendUserAction":358,"../common/amendUtils/AmendUtils":359,"../common/blockUtils/BlockCore":360,"../common/blockUtils/BlockUtils":361,"../common/codeUtils/CodeCore":362,"../common/codeUtils/CodeStyle":363,"../common/codeUtils/CodeUtils":364,"../common/contentUtils/ContentCore":365,"../common/editorCore/Editor":366,"../common/editorCore/EditorEvent":367,"../common/editorCore/EditorUtils":368,"../common/frameViewUtils/FrameViewCore":369,"../common/frameViewUtils/FrameViewStyle":370,"../common/frameViewUtils/FrameViewUtils":371,"../common/frameViewUtils/ToolbarMarkdown":372,"../common/imgUtils/ImgClick":373,"../common/imgUtils/ImgCore":374,"../common/imgUtils/ImgResize":375,"../common/imgUtils/ImgUtils":376,"../common/imgUtils/SvgClick":377,"../common/readerCore/Reader":378,"../common/readerCore/ReaderEvent":379,"../common/tableUtils/TableCore":380,"../common/tableUtils/TableMenu":381,"../common/tableUtils/TableUtils":382,"../common/tableUtils/TableZone":383,"../common/todoUtils/TodoCore":384,"../common/todoUtils/TodoRouteForClient":385,"../common/todoUtils/TodoStyle":386,"../common/todoUtils/TodoUtils":387,"../config/const":388,"../config/env":389,"../libs/LoadController":393,"../libs/base64":396,"../libs/dependLoader":397,"../libs/domPatch":398,"../libs/utils":400,"../libs/xssUtils":401,"../locale/lang":402,"../tester/TesterForRunTime":403,"babel-polyfill":1}],391:[function(require,module,exports){
'use strict';

var WizDocument = require('./WizDocument');

var wizDocument = void 0,
    core = void 0,
    coreCallback = void 0;
var wizEditor = {
  init: function init(options) {
    options = options || {};
    if (!options.editor) {
      options.editor = {};
    }
    if (!options.reader) {
      options.reader = {};
    }
    if (options.autoFocus !== undefined) {
      options.editor.autoFocus = options.autoFocus;
      delete options.autoFocus;
    }
    if (options.maxRedo !== undefined) {
      options.editor.maxRedo = options.maxRedo;
      delete options.maxRedo;
    }

    if (options.noteType !== undefined) {
      options.reader.type = options.noteType;
      delete options.noteType;
    }
    if (options.noAmend !== undefined) {
      options.reader.noAmend = options.noAmend;
      delete options.noAmend;
    }
    if (options.codeNoIDE !== undefined) {
      options.reader.codeNoIDE = options.codeNoIDE;
      delete options.codeNoIDE;
    }
    if (options.markdownPlugIn !== undefined) {
      options.reader.markdownPlugIn = options.markdownPlugIn;
      delete options.markdownPlugIn;
    }
    if (options.timeout !== undefined) {
      options.reader.timeout = options.timeout;
      delete options.timeout;
    }
    if (options.callback !== undefined) {
      options.editor.callback = {
        redo: options.callback.redo
      };
      options.reader.callback = {
        markdown: options.callback.markdown,
        mathJax: options.callback.mathJax
      };
      if (options.callback.onClickLink) {
        delete options.callback.redo;
        delete options.callback.markdown;
        delete options.callback.mathJax;
      } else {
        delete options.callback;
      }
    }

    wizDocument = new WizDocument(options, function (documentCore) {
      core = documentCore;
      if (coreCallback) {
        coreCallback(documentCore);
      }
    });

    wizEditor.version = wizDocument.version;
    wizEditor.on = function (options, callback) {
      wizDocument.editor.on(options, callback);
      return wizEditor;
    };
    wizEditor.off = function (options, callback) {
      wizDocument.reader.on(options, callback);
      return wizEditor;
    };
    wizEditor.backupCaret = wizDocument.editor.caretBackup;
    wizEditor.execCommand = wizDocument.editor.execCommand;
    wizEditor.find = wizDocument.editor.find;
    wizEditor.focus = function () {
      wizDocument.editor.focus();
      return wizEditor;
    };
    wizEditor.getBodyText = wizDocument.editor.getBodyText;
    wizEditor.getContentHtml = wizDocument.editor.getContentHtml;
    wizEditor.getMarkdownSrc = wizDocument.editor.getMarkdownSrc;

    wizEditor.insertCustomStyle = function (id, customCss, isTemp) {
      wizDocument.insertCustomStyle(id, customCss, isTemp);
      return wizEditor;
    };
    wizEditor.insertDefaultStyle = function (onlyReplace, customCss) {
      wizDocument.insertDefaultStyle(onlyReplace, customCss);
      return wizEditor;
    };

    wizEditor.insertB64Html = wizDocument.editor.insertB64Html;
    wizEditor.insertHtml = wizDocument.editor.insertHtml;
    wizEditor.isModified = wizDocument.editor.isModified;
    wizEditor.modifySelectionDom = wizDocument.editor.modifySelectionDom;
    wizEditor.paste = wizDocument.editor.paste;
    wizEditor.pasteB64 = wizDocument.editor.pasteB64;
    wizEditor.redo = function () {
      wizDocument.editor.redo();
      return wizEditor;
    };
    wizEditor.removeFormat = function (removeAll, isRemoveColor, isRemoveAllStyles) {
      wizDocument.editor.removeFormat(removeAll, isRemoveColor, isRemoveAllStyles);
      return wizEditor;
    };
    wizEditor.removeStyleById = function (id) {
      wizDocument.removeStyleById(id);
      return wizEditor;
    };
    wizEditor.replace = wizDocument.editor.replace;
    wizEditor.replaceAll = wizDocument.editor.replaceAll;
    wizEditor.replaceSvg = wizDocument.editor.replaceSvg;
    wizEditor.restoreCaret = wizDocument.editor.caretRestore;
    wizEditor.saveSnap = wizDocument.editor.saveSnap;
    // wizEditor.setWebViewSizeForFixScroll = wizDocument.editor.setWebViewSizeForFixScroll;
    wizEditor.setUnModified = wizDocument.editor.setUnModified;
    wizEditor.undo = function () {
      wizDocument.editor.undo();
      return wizEditor;
    };
    wizEditor.ListenerType = wizDocument.editor.ListenerType;
    wizEditor.addListener = function (eName, fun) {
      wizDocument.editor.addListener(eName, fun);
      return wizEditor;
    };
    wizEditor.removeListener = function (eName, fun) {
      wizDocument.editor.removeListener(eName, fun);
      return wizEditor;
    };
    wizEditor.triggerListener = function (eName, params) {
      wizDocument.editor.triggerListener(eName, params);
      return wizEditor;
    };
    wizEditor.startTrackEvent = wizDocument.editor.startTrackEvent;
    wizEditor.stopTrackEvent = wizDocument.editor.stopTrackEvent;

    wizEditor.amend.on = function () {
      wizDocument.editor.amend.on();
      return wizEditor;
    };
    wizEditor.amend.off = function () {
      wizDocument.editor.amend.off();
      return wizEditor;
    };
    wizEditor.amend.changeCurUser = wizDocument.editor.amend.changeCurUser;
    wizEditor.amend.isEdited = wizDocument.editor.amend.isEdited;
    wizEditor.amend.isEditing = wizDocument.editor.amend.isEditing;
    wizEditor.amend.hasAmendSpanByCursor = wizDocument.editor.amend.hasAmendSpanByCursor;
    wizEditor.amend.accept = wizDocument.editor.amend.accept;
    wizEditor.amend.refuse = wizDocument.editor.amend.refuse;

    wizEditor.code.insertCode = wizDocument.editor.code.insertCode;

    wizEditor.formatPainter.on = wizDocument.editor.formatPainter.on;
    wizEditor.formatPainter.off = wizDocument.editor.formatPainter.off;

    wizEditor.img.getAll = wizDocument.editor.img.getAll;
    wizEditor.img.insertAsAttachment = wizDocument.editor.img.insertAsAttachment;
    wizEditor.img.insertByPath = wizDocument.editor.img.insertByPath;
    wizEditor.img.removeCur = wizDocument.editor.img.removeCur;
    wizEditor.img.replaceCur = wizDocument.editor.img.replaceCur;

    wizEditor.link.on = wizDocument.editor.link.on;
    wizEditor.link.off = wizDocument.editor.link.off;
    wizEditor.link.getCurrentLink = wizDocument.editor.link.getCurrentLink;
    wizEditor.link.removeSelectedLink = wizDocument.editor.link.removeSelectedLink;
    wizEditor.link.setCurrentLink = wizDocument.editor.link.setCurrentLink;

    wizEditor.range.moveToPoint = wizDocument.editor.range.moveToPoint;

    wizEditor.table.canCreateTable = wizDocument.editor.table.canCreateTable;
    wizEditor.table.clearCellValue = wizDocument.editor.table.clearCellValue;
    wizEditor.table.deleteCols = wizDocument.editor.table.deleteCols;
    wizEditor.table.deleteRows = wizDocument.editor.table.deleteRows;
    wizEditor.table.deleteTable = wizDocument.editor.table.deleteTable;
    wizEditor.table.distributeCols = wizDocument.editor.table.distributeCols;
    wizEditor.table.insertCol = wizDocument.editor.table.insertCol;
    wizEditor.table.insertRow = wizDocument.editor.table.insertRow;
    wizEditor.table.insertTable = wizDocument.editor.table.insertTable;
    wizEditor.table.merge = wizDocument.editor.table.merge;
    wizEditor.table.setCellAlign = wizDocument.editor.table.setCellAlign;
    wizEditor.table.setCellBg = wizDocument.editor.table.setCellBg;
    wizEditor.table.split = wizDocument.editor.table.split;

    wizEditor.todo.setTodo = wizDocument.editor.todo.setTodo;
    wizEditor.todo.setTodoInfo = wizDocument.editor.todo.setTodoInfo;

    wizEditor.nightMode.on = wizDocument.nightMode.on;
    wizEditor.nightMode.off = wizDocument.nightMode.off;

    wizEditor.toolbar.setImgUploaderId = wizDocument.editor.toolbar.setImgUploaderId;
    wizEditor.toolbar.onImgUploadBegin = wizDocument.editor.toolbar.onImgUploadBegin;
    wizEditor.toolbar.onImgUploadProgress = wizDocument.editor.toolbar.onImgUploadProgress;
    wizEditor.toolbar.onImgUploadComplete = wizDocument.editor.toolbar.onImgUploadComplete;
    wizEditor.toolbar.onImgUploadError = wizDocument.editor.toolbar.onImgUploadError;

    wizEditor.utils.clearStyleFromHtml = wizDocument.editor.utils.clearStyleFromHtml;

    wizReader.on = function (options, callback) {
      wizDocument.reader.on(options, callback);
      return wizReader;
    };
    wizReader.off = function (options, callback) {
      wizDocument.editor.on(options, callback);
      return wizReader;
    };
    wizReader.closeDocument = wizDocument.reader.closeDocument;
    wizReader.getRenderDocument = wizDocument.reader.getRenderDocument;
    wizReader.getWordCount = wizDocument.reader.getWordCount;
    wizReader.insertCustomStyle = function (id, customCss, isTemp) {
      wizDocument.insertCustomStyle(id, customCss, isTemp);
      return wizReader;
    };
    wizReader.insertDefaultStyle = function (onlyReplace, customCss) {
      wizDocument.insertDefaultStyle(onlyReplace, customCss);
      return wizReader;
    };
    wizReader.removeStyleById = function (id) {
      wizDocument.removeStyleById(id);
      return wizReader;
    };
    wizReader.setPluginModify = wizDocument.reader.setPluginModify;

    wizReader.amendInfo.on = function () {
      wizDocument.reader.amend.on();
      return wizReader;
    };
    wizReader.amendInfo.off = function () {
      wizDocument.reader.amend.off();
      return wizReader;
    };
    wizReader.highlight.next = wizDocument.reader.highlight.next;
    wizReader.highlight.on = wizDocument.reader.highlight.on;
    wizReader.highlight.off = wizDocument.reader.highlight.off;
    wizReader.highlight.previous = wizDocument.reader.highlight.previous;

    wizReader.img.getAll = wizDocument.editor.img.getAll;

    wizReader.pureRead.on = wizDocument.reader.pureRead.on;
    wizReader.pureRead.off = wizDocument.reader.pureRead.off;

    wizReader.todo.setTodoInfo = wizDocument.reader.todo.setTodoInfo;
    wizReader.todo.onCheckDocLock = wizDocument.reader.todo.onCheckDocLock;

    wizReader.nightMode.on = wizDocument.nightMode.on;
    wizReader.nightMode.off = wizDocument.nightMode.off;

    return wizEditor;
  },
  amend: {},
  code: {},
  formatPainter: {},
  img: {},
  link: {},
  range: {},
  table: {},
  todo: {},
  nightMode: {},
  utils: {},
  toolbar: {}
};
var wizReader = {
  init: wizEditor.init,
  amendInfo: {},
  highlight: {},
  img: {},
  nightMode: {},
  pureRead: {},
  todo: {}
};

var setCoreCallback = function setCoreCallback(_coreCallback) {
  coreCallback = _coreCallback;
};

window.WizEditor = wizEditor;
window.WizReader = wizReader;

module.exports = {
  wizEditor: wizEditor,
  wizReader: wizReader,
  setCoreCallback: setCoreCallback
};

},{"./WizDocument":390}],392:[function(require,module,exports){
'use strict';

var WizEditor = require('./wizEditor');

// let wizEditor = WizEditor.wizEditor;
// let wizReader = WizEditor.wizReader;
var setCoreCallback = WizEditor.setCoreCallback;

var coreCallback = function coreCallback(core) {
  var env = core.env;
  var todoRouteForClient = core.require.todoRouteForClient;

  //捕获 Mac 端初始化结束
  env.win.initForWebEngine = function () {
    if (todoRouteForClient) {
      todoRouteForClient.setQtEditor();
    }
  };
};

setCoreCallback(coreCallback);

// module.exports = WizEditorForMac;

},{"./wizEditor":391}],393:[function(require,module,exports){
'use strict';

// 专门用于等待加载控制 callback
var LoadController = function LoadController() {
  var _this = this;

  var count = 0;
  var callbackMap = {};
  var loadingMap = {};

  this.getLoading = function (doc) {
    return !!loadingMap[doc.loadId];
  };
  this.setLoading = function (doc, loading) {
    loadingMap[doc.loadId] = !!loading;
  };
  this.addCallback = function (doc, _callback) {
    if (!doc.loadId) {
      doc.loadId = 'wizLoadController_' + count++;
    }
    if (!callbackMap[doc.loadId]) {
      callbackMap[doc.loadId] = [];
    }
    callbackMap[doc.loadId].push(_callback);
  };
  this.callback = function (doc) {
    var callbackList = callbackMap[doc.loadId];
    if (!callbackList || _this.getLoading(doc)) {
      return;
    }
    for (var i = callbackList.length - 1; i >= 0; i--) {
      var cb = callbackList.splice(i, 1)[0];
      cb();
    }
    callbackMap[doc.loadId] = [];
  };
};

module.exports = LoadController;

},{}],394:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Markdown;

if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && typeof require === "function") // we're in a CommonJS (e.g. Node.js) module
      Markdown = exports;else Markdown = {};

// The following text is included for historical reasons, but should
// be taken with a pinch of salt; it's not all true anymore.

//
// Wherever possible, Showdown is a straight, line-by-line port
// of the Perl version of Markdown.
//
// This is not a normal parser design; it's basically just a
// series of string substitutions.  It's hard to read and
// maintain this way,  but keeping Showdown close to the original
// design makes it easier to port new features.
//
// More importantly, Showdown behaves like markdown.pl in most
// edge cases.  So web applications can do client-side preview
// in Javascript, and then build identical HTML on the server.
//
// This port needs the new RegExp functionality of ECMA 262,
// 3rd Edition (i.e. Javascript 1.5).  Most modern web browsers
// should do fine.  Even with the new regular expression features,
// We do a lot of work to emulate Perl's regex functionality.
// The tricky changes in this file mostly have the "attacklab:"
// label.  Major or self-explanatory changes don't.
//
// Smart diff tools like Araxis Merge will be able to match up
// this file with markdown.pl in a useful way.  A little tweaking
// helps: in a copy of markdown.pl, replace "#" with "//" and
// replace "$text" with "text".  Be sure to ignore whitespace
// and line endings.
//


//
// Usage:
//
//   var text = "Markdown *rocks*.";
//
//   var converter = new Markdown.Converter();
//   var html = converter.makeHtml(text);
//
//   alert(html);
//
// Note: move the sample code to the bottom of this
// file before uncommenting it.
//

(function () {

      function identity(x) {
            return x;
      }

      function returnFalse(x) {
            return false;
      }

      function HookCollection() {}

      HookCollection.prototype = {

            chain: function chain(hookname, func) {
                  var original = this[hookname];
                  if (!original) throw new Error("unknown hook " + hookname);

                  if (original === identity) this[hookname] = func;else this[hookname] = function (text) {
                        var args = Array.prototype.slice.call(arguments, 0);
                        args[0] = original.apply(null, args);
                        return func.apply(null, args);
                  };
            },
            set: function set(hookname, func) {
                  if (!this[hookname]) throw new Error("unknown hook " + hookname);
                  this[hookname] = func;
            },
            addNoop: function addNoop(hookname) {
                  this[hookname] = identity;
            },
            addFalse: function addFalse(hookname) {
                  this[hookname] = returnFalse;
            }
      };

      Markdown.HookCollection = HookCollection;

      // g_urls and g_titles allow arbitrary user-entered strings as keys. This
      // caused an exception (and hence stopped the rendering) when the user entered
      // e.g. [push] or [__proto__]. Adding a prefix to the actual key prevents this
      // (since no builtin property starts with "s_"). See
      // http://meta.stackexchange.com/questions/64655/strange-wmd-bug
      // (granted, switching from Array() to Object() alone would have left only __proto__
      // to be a problem)
      function SaveHash() {}

      SaveHash.prototype = {
            set: function set(key, value) {
                  this["s_" + key] = value;
            },
            get: function get(key) {
                  return this["s_" + key];
            }
      };

      Markdown.Converter = function (OPTIONS) {
            var pluginHooks = this.hooks = new HookCollection();

            // given a URL that was encountered by itself (without markup), should return the link text that's to be given to this link
            pluginHooks.addNoop("plainLinkText");

            // called with the orignal text as given to makeHtml. The result of this plugin hook is the actual markdown source that will be cooked
            pluginHooks.addNoop("preConversion");

            // called with the text once all normalizations have been completed (tabs to spaces, line endings, etc.), but before any conversions have
            pluginHooks.addNoop("postNormalization");

            // Called with the text before / after creating block elements like code blocks and lists. Note that this is called recursively
            // with inner content, e.g. it's called with the full text, and then only with the content of a blockquote. The inner
            // call will receive outdented text.
            pluginHooks.addNoop("preBlockGamut");
            pluginHooks.addNoop("postBlockGamut");

            // called with the text of a single block element before / after the span-level conversions (bold, code spans, etc.) have been made
            pluginHooks.addNoop("preSpanGamut");
            pluginHooks.addNoop("postSpanGamut");

            // called with the final cooked HTML code. The result of this plugin hook is the actual output of makeHtml
            pluginHooks.addNoop("postConversion");

            //
            // Private state of the converter instance:
            //

            // Global hashes, used by various utility routines
            var g_urls;
            var g_titles;
            var g_html_blocks;

            // Used to track when we're inside an ordered or unordered list
            // (see _ProcessListItems() for details):
            var g_list_level;

            OPTIONS = OPTIONS || {};
            var asciify = identity,
                deasciify = identity;
            if (OPTIONS.nonAsciiLetters) {

                  /* In JavaScript regular expressions, \w only denotes [a-zA-Z0-9_].
                   * That's why there's inconsistent handling e.g. with intra-word bolding
                   * of Japanese words. That's why we do the following if OPTIONS.nonAsciiLetters
                   * is true:
                   *
                   * Before doing bold and italics, we find every instance
                   * of a unicode word character in the Markdown source that is not
                   * matched by \w, and the letter "Q". We take the character's code point
                   * and encode it in base 51, using the "digits"
                   *
                   *     A, B, ..., P, R, ..., Y, Z, a, b, ..., y, z
                   *
                   * delimiting it with "Q" on both sides. For example, the source
                   *
                   * > In Chinese, the smurfs are called 藍精靈, meaning "blue spirits".
                   *
                   * turns into
                   *
                   * > In Chinese, the smurfs are called QNIhQQMOIQQOuUQ, meaning "blue spirits".
                   *
                   * Since everything that is a letter in Unicode is now a letter (or
                   * several letters) in ASCII, \w and \b should always do the right thing.
                   *
                   * After the bold/italic conversion, we decode again; since "Q" was encoded
                   * alongside all non-ascii characters (as "QBfQ"), and the conversion
                   * will not generate "Q", the only instances of that letter should be our
                   * encoded characters. And since the conversion will not break words, the
                   * "Q...Q" should all still be in one piece.
                   *
                   * We're using "Q" as the delimiter because it's probably one of the
                   * rarest characters, and also because I can't think of any special behavior
                   * that would ever be triggered by this letter (to use a silly example, if we
                   * delimited with "H" on the left and "P" on the right, then "Ψ" would be
                   * encoded as "HTTP", which may cause special behavior). The latter would not
                   * actually be a huge issue for bold/italic, but may be if we later use it
                   * in other places as well.
                   * */
                  (function () {
                        var lettersThatJavaScriptDoesNotKnowAndQ = /[Q\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376-\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0523\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0621-\u064a\u0660-\u0669\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07c0-\u07ea\u07f4-\u07f5\u07fa\u0904-\u0939\u093d\u0950\u0958-\u0961\u0966-\u096f\u0971-\u0972\u097b-\u097f\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09e6-\u09f1\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a66-\u0a6f\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0ae6-\u0aef\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b66-\u0b6f\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0be6-\u0bef\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58-\u0c59\u0c60-\u0c61\u0c66-\u0c6f\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0ce6-\u0cef\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d28\u0d2a-\u0d39\u0d3d\u0d60-\u0d61\u0d66-\u0d6f\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e87-\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa-\u0eab\u0ead-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0ed0-\u0ed9\u0edc-\u0edd\u0f00\u0f20-\u0f29\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8b\u1000-\u102a\u103f-\u1049\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u1090-\u1099\u10a0-\u10c5\u10d0-\u10fa\u10fc\u1100-\u1159\u115f-\u11a2\u11a8-\u11f9\u1200-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u1676\u1681-\u169a\u16a0-\u16ea\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u17e0-\u17e9\u1810-\u1819\u1820-\u1877\u1880-\u18a8\u18aa\u1900-\u191c\u1946-\u196d\u1970-\u1974\u1980-\u19a9\u19c1-\u19c7\u19d0-\u19d9\u1a00-\u1a16\u1b05-\u1b33\u1b45-\u1b4b\u1b50-\u1b59\u1b83-\u1ba0\u1bae-\u1bb9\u1c00-\u1c23\u1c40-\u1c49\u1c4d-\u1c7d\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u203f-\u2040\u2054\u2071\u207f\u2090-\u2094\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2183-\u2184\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2c6f\u2c71-\u2c7d\u2c80-\u2ce4\u2d00-\u2d25\u2d30-\u2d65\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3006\u3031-\u3035\u303b-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31b7\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fc3\ua000-\ua48c\ua500-\ua60c\ua610-\ua62b\ua640-\ua65f\ua662-\ua66e\ua67f-\ua697\ua717-\ua71f\ua722-\ua788\ua78b-\ua78c\ua7fb-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8d0-\ua8d9\ua900-\ua925\ua930-\ua946\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa50-\uaa59\uac00-\ud7a3\uf900-\ufa2d\ufa30-\ufa6a\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe33-\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]/g;
                        var cp_Q = "Q".charCodeAt(0);
                        var cp_A = "A".charCodeAt(0);
                        var cp_Z = "Z".charCodeAt(0);
                        var dist_Za = "a".charCodeAt(0) - cp_Z - 1;

                        asciify = function asciify(text) {
                              return text.replace(lettersThatJavaScriptDoesNotKnowAndQ, function (m) {
                                    var c = m.charCodeAt(0);
                                    var s = "";
                                    var v;
                                    while (c > 0) {
                                          v = c % 51 + cp_A;
                                          if (v >= cp_Q) v++;
                                          if (v > cp_Z) v += dist_Za;
                                          s = String.fromCharCode(v) + s;
                                          c = c / 51 | 0;
                                    }
                                    return "Q" + s + "Q";
                              });
                        };

                        deasciify = function deasciify(text) {
                              return text.replace(/Q([A-PR-Za-z]{1,3})Q/g, function (m, s) {
                                    var c = 0;
                                    var v;
                                    for (var i = 0; i < s.length; i++) {
                                          v = s.charCodeAt(i);
                                          if (v > cp_Z) v -= dist_Za;
                                          if (v > cp_Q) v--;
                                          v -= cp_A;
                                          c = c * 51 + v;
                                    }
                                    return String.fromCharCode(c);
                              });
                        };
                  })();
            }

            var _DoItalicsAndBold = OPTIONS.asteriskIntraWordEmphasis ? _DoItalicsAndBold_AllowIntrawordWithAsterisk : _DoItalicsAndBoldStrict;

            this.makeHtml = function (text) {

                  //
                  // Main function. The order in which other subs are called here is
                  // essential. Link and image substitutions need to happen before
                  // _EscapeSpecialCharsWithinTagAttributes(), so that any *'s or _'s in the <a>
                  // and <img> tags get encoded.
                  //

                  // This will only happen if makeHtml on the same converter instance is called from a plugin hook.
                  // Don't do that.
                  if (g_urls) throw new Error("Recursive call to converter.makeHtml");

                  // Create the private state objects.
                  g_urls = new SaveHash();
                  g_titles = new SaveHash();
                  g_html_blocks = [];
                  g_list_level = 0;

                  text = pluginHooks.preConversion(text);

                  // attacklab: Replace ~ with ~T
                  // This lets us use tilde as an escape char to avoid md5 hashes
                  // The choice of character is arbitray; anything that isn't
                  // magic in Markdown will work.
                  text = text.replace(/~/g, "~T");

                  // attacklab: Replace $ with ~D
                  // RegExp interprets $ as a special character
                  // when it's in a replacement string
                  text = text.replace(/\$/g, "~D");

                  // Standardize line endings
                  text = text.replace(/\r\n/g, "\n"); // DOS to Unix
                  text = text.replace(/\r/g, "\n"); // Mac to Unix

                  // Make sure text begins and ends with a couple of newlines:
                  text = "\n\n" + text + "\n\n";

                  // Convert all tabs to spaces.
                  text = _Detab(text);

                  // Strip any lines consisting only of spaces and tabs.
                  // This makes subsequent regexen easier to write, because we can
                  // match consecutive blank lines with /\n+/ instead of something
                  // contorted like /[ \t]*\n+/ .
                  text = text.replace(/^[ \t]+$/mg, "");

                  text = pluginHooks.postNormalization(text);

                  // Turn block-level HTML blocks into hash entries
                  text = _HashHTMLBlocks(text);

                  // Strip link definitions, store in hashes.
                  text = _StripLinkDefinitions(text);

                  text = _RunBlockGamut(text);

                  text = _UnescapeSpecialChars(text);

                  // attacklab: Restore dollar signs
                  text = text.replace(/~D/g, "$$");

                  // attacklab: Restore tildes
                  text = text.replace(/~T/g, "~");

                  text = pluginHooks.postConversion(text);

                  g_html_blocks = g_titles = g_urls = null;

                  return text;
            };

            function _StripLinkDefinitions(text) {
                  //
                  // Strips link definitions from text, stores the URLs and titles in
                  // hash references.
                  //

                  // Link defs are in the form: ^[id]: url "optional title"

                  /*
                   text = text.replace(/
                   ^[ ]{0,3}\[([^\[\]]+)\]:  // id = $1  attacklab: g_tab_width - 1
                   [ \t]*
                   \n?                 // maybe *one* newline
                   [ \t]*
                   <?(\S+?)>?          // url = $2
                   (?=\s|$)            // lookahead for whitespace instead of the lookbehind removed below
                   [ \t]*
                   \n?                 // maybe one newline
                   [ \t]*
                   (                   // (potential) title = $3
                   (\n*)           // any lines skipped = $4 attacklab: lookbehind removed
                   [ \t]+
                   ["(]
                   (.+?)           // title = $5
                   [")]
                   [ \t]*
                   )?                  // title is optional
                   (\n+)             // subsequent newlines = $6, capturing because they must be put back if the potential title isn't an actual title
                   /gm, function(){...});
                   */

                  text = text.replace(/^[ ]{0,3}\[([^\[\]]+)\]:[ \t]*\n?[ \t]*<?(\S+?)>?(?=\s|$)[ \t]*\n?[ \t]*((\n*)["(](.+?)[")][ \t]*)?(\n+)/gm, function (wholeMatch, m1, m2, m3, m4, m5, m6) {
                        m1 = m1.toLowerCase();
                        g_urls.set(m1, _EncodeAmpsAndAngles(m2)); // Link IDs are case-insensitive
                        if (m4) {
                              // Oops, found blank lines, so it's not a title.
                              // Put back the parenthetical statement we stole.
                              return m3 + m6;
                        } else if (m5) {
                              g_titles.set(m1, m5.replace(/"/g, "&quot;"));
                        }

                        // Completely remove the definition from the text
                        return "";
                  });

                  return text;
            }

            function _HashHTMLBlocks(text) {

                  // Hashify HTML blocks:
                  // We only want to do this for block-level HTML tags, such as headers,
                  // lists, and tables. That's because we still want to wrap <p>s around
                  // "paragraphs" that are wrapped in non-block-level tags, such as anchors,
                  // phrase emphasis, and spans. The list of tags we're looking for is
                  // hard-coded:
                  var block_tags_a = "p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del";
                  var block_tags_b = "p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math";

                  // First, look for nested blocks, e.g.:
                  //   <div>
                  //     <div>
                  //     tags for inner block must be indented.
                  //     </div>
                  //   </div>
                  //
                  // The outermost tags must start at the left margin for this to match, and
                  // the inner nested divs must be indented.
                  // We need to do this before the next, more liberal match, because the next
                  // match will start at the first `<div>` and stop at the first `</div>`.

                  // attacklab: This regex can be expensive when it fails.

                  /*
                   text = text.replace(/
                   (                       // save in $1
                   ^                   // start of line  (with /m)
                   <($block_tags_a)    // start tag = $2
                   \b                  // word break
                   // attacklab: hack around khtml/pcre bug...
                   [^\r]*?\n           // any number of lines, minimally matching
                   </\2>               // the matching end tag
                   [ \t]*              // trailing spaces/tabs
                   (?=\n+)             // followed by a newline
                   )                       // attacklab: there are sentinel newlines at end of document
                   /gm,function(){...}};
                   */
                  // 2017-12-28 wiz：修正bug —— 在 ``` 代码区域， 和 <p>...中间有换行...</p> 区间 会导致无法解析其余的 markdown 语法
                  // text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\b[^\r]*?\n<\/\2>[ \t]*(?=\n+))/gm, hashMatch);
                  text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\b[^\r]*?\n*<\/\2>[ \t]*(?=\n+))/gm, hashMatch);

                  //
                  // Now match more liberally, simply from `\n<tag>` to `</tag>\n`
                  //

                  /*
                   text = text.replace(/
                   (                       // save in $1
                   ^                   // start of line  (with /m)
                   <($block_tags_b)    // start tag = $2
                   \b                  // word break
                   // attacklab: hack around khtml/pcre bug...
                   [^\r]*?             // any number of lines, minimally matching
                   .*</\2>             // the matching end tag
                   [ \t]*              // trailing spaces/tabs
                   (?=\n+)             // followed by a newline
                   )                       // attacklab: there are sentinel newlines at end of document
                   /gm,function(){...}};
                   */
                  text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math)\b[^\r]*?.*<\/\2>[ \t]*(?=\n+)\n)/gm, hashMatch);

                  // Special case just for <hr />. It was easier to make a special case than
                  // to make the other regex more complicated.

                  /*
                   text = text.replace(/
                   \n                  // Starting after a blank line
                   [ ]{0,3}
                   (                   // save in $1
                   (<(hr)          // start tag = $2
                   \b          // word break
                   ([^<>])*?
                   \/?>)           // the matching end tag
                   [ \t]*
                   (?=\n{2,})      // followed by a blank line
                   )
                   /g,hashMatch);
                   */
                  text = text.replace(/\n[ ]{0,3}((<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g, hashMatch);

                  // Special case for standalone HTML comments:

                  /*
                   text = text.replace(/
                   \n\n                                            // Starting after a blank line
                   [ ]{0,3}                                        // attacklab: g_tab_width - 1
                   (                                               // save in $1
                   <!
                   (--(?:|(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)   // see http://www.w3.org/TR/html-markup/syntax.html#comments and http://meta.stackexchange.com/q/95256
                   >
                   [ \t]*
                   (?=\n{2,})                                  // followed by a blank line
                   )
                   /g,hashMatch);
                   */
                  text = text.replace(/\n\n[ ]{0,3}(<!(--(?:|(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>[ \t]*(?=\n{2,}))/g, hashMatch);

                  // PHP and ASP-style processor instructions (<?...?> and <%...%>)

                  /*
                   text = text.replace(/
                   (?:
                   \n\n            // Starting after a blank line
                   )
                   (                   // save in $1
                   [ ]{0,3}        // attacklab: g_tab_width - 1
                   (?:
                   <([?%])     // $2
                   [^\r]*?
                   \2>
                   )
                   [ \t]*
                   (?=\n{2,})      // followed by a blank line
                   )
                   /g,hashMatch);
                   */
                  text = text.replace(/(?:\n\n)([ ]{0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g, hashMatch);

                  return text;
            }

            function hashBlock(text) {
                  text = text.replace(/(^\n+|\n+$)/g, "");
                  // Replace the element text with a marker ("~KxK" where x is its key)
                  return "\n\n~K" + (g_html_blocks.push(text) - 1) + "K\n\n";
            }

            function hashMatch(wholeMatch, m1) {
                  return hashBlock(m1);
            }

            var blockGamutHookCallback = function blockGamutHookCallback(t) {
                  return _RunBlockGamut(t);
            };

            function _RunBlockGamut(text, doNotUnhash, doNotCreateParagraphs) {
                  //
                  // These are all the transformations that form block-level
                  // tags like paragraphs, headers, and list items.
                  //

                  text = pluginHooks.preBlockGamut(text, blockGamutHookCallback);

                  text = _DoHeaders(text);

                  // Do Horizontal Rules:
                  var replacement = "<hr />\n";
                  text = text.replace(/^[ ]{0,2}([ ]?\*[ ]?){3,}[ \t]*$/gm, replacement);
                  text = text.replace(/^[ ]{0,2}([ ]?-[ ]?){3,}[ \t]*$/gm, replacement);
                  text = text.replace(/^[ ]{0,2}([ ]?_[ ]?){3,}[ \t]*$/gm, replacement);

                  text = _DoLists(text);
                  text = _DoCodeBlocks(text);
                  text = _DoBlockQuotes(text);

                  text = pluginHooks.postBlockGamut(text, blockGamutHookCallback);

                  // 2018-01-03 wiz：增加自定义规则入口
                  if (OPTIONS.customBlockGamut) {
                        text = OPTIONS.customBlockGamut(text);
                  }
                  // We already ran _HashHTMLBlocks() before, in Markdown(), but that
                  // was to escape raw HTML in the original Markdown source. This time,
                  // we're escaping the markup we've just created, so that we don't wrap
                  // <p> tags around block-level tags.
                  text = _HashHTMLBlocks(text);

                  text = _FormParagraphs(text, doNotUnhash, doNotCreateParagraphs);

                  return text;
            }

            function _RunSpanGamut(text) {
                  //
                  // These are all the transformations that occur *within* block-level
                  // tags like paragraphs, headers, and list items.
                  //

                  text = pluginHooks.preSpanGamut(text);

                  text = _DoCodeSpans(text);
                  text = _EscapeSpecialCharsWithinTagAttributes(text);
                  text = _EncodeBackslashEscapes(text);

                  // Process anchor and image tags. Images must come first,
                  // because ![foo][f] looks like an anchor.
                  text = _DoImages(text);
                  text = _DoAnchors(text);

                  // Make links out of things like `<http://example.com/>`
                  // Must come after _DoAnchors(), because you can use < and >
                  // delimiters in inline links like [this](<url>).
                  text = _DoAutoLinks(text);

                  text = text.replace(/~P/g, "://"); // put in place to prevent autolinking; reset now

                  text = _EncodeAmpsAndAngles(text);
                  text = _DoItalicsAndBold(text);

                  // Do hard breaks:
                  text = text.replace(/  +\n/g, " <br>\n");

                  text = pluginHooks.postSpanGamut(text);

                  return text;
            }

            function _EscapeSpecialCharsWithinTagAttributes(text) {
                  //
                  // Within tags -- meaning between < and > -- encode [\ ` * _] so they
                  // don't conflict with their use in Markdown for code, italics and strong.
                  //

                  // Build a regex to find HTML tags and comments.  See Friedl's
                  // "Mastering Regular Expressions", 2nd Ed., pp. 200-201.

                  // SE: changed the comment part of the regex

                  var regex = /(<[a-z\/!$]("[^"]*"|'[^']*'|[^'">])*>|<!(--(?:|(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>)/gi;

                  text = text.replace(regex, function (wholeMatch) {
                        var tag = wholeMatch.replace(/(.)<\/?code>(?=.)/g, "$1`");
                        tag = escapeCharacters(tag, wholeMatch.charAt(1) == "!" ? "\\`*_/" : "\\`*_"); // also escape slashes in comments to prevent autolinking there -- http://meta.stackexchange.com/questions/95987
                        return tag;
                  });

                  return text;
            }

            function _DoAnchors(text) {

                  if (text.indexOf("[") === -1) return text;

                  //
                  // Turn Markdown link shortcuts into XHTML <a> tags.
                  //
                  //
                  // First, handle reference-style links: [link text] [id]
                  //

                  /*
                   text = text.replace(/
                   (                           // wrap whole match in $1
                   \[
                   (
                   (?:
                   \[[^\]]*\]      // allow brackets nested one level
                   |
                   [^\[]           // or anything else
                   )*
                   )
                   \]
                   [ ]?                    // one optional space
                   (?:\n[ ]*)?             // one optional newline followed by spaces
                   \[
                   (.*?)                   // id = $3
                   \]
                   )
                   ()()()()                    // pad remaining backreferences
                   /g, writeAnchorTag);
                   */
                  text = text.replace(/(\[((?:\[[^\]]*\]|[^\[\]])*)\][ ]?(?:\n[ ]*)?\[(.*?)\])()()()()/g, writeAnchorTag);

                  //
                  // Next, inline-style links: [link text](url "optional title")
                  //

                  /*
                   text = text.replace(/
                   (                           // wrap whole match in $1
                   \[
                   (
                   (?:
                   \[[^\]]*\]      // allow brackets nested one level
                   |
                   [^\[\]]         // or anything else
                   )*
                   )
                   \]
                   \(                      // literal paren
                   [ \t]*
                   ()                      // no id, so leave $3 empty
                   <?(                     // href = $4
                   (?:
                   \([^)]*\)       // allow one level of (correctly nested) parens (think MSDN)
                   |
                   [^()\s]
                   )*?
                   )>?
                   [ \t]*
                   (                       // $5
                   (['"])              // quote char = $6
                   (.*?)               // Title = $7
                   \6                  // matching quote
                   [ \t]*              // ignore any spaces/tabs between closing quote and )
                   )?                      // title is optional
                   \)
                   )
                   /g, writeAnchorTag);
                   */

                  text = text.replace(/(\[((?:\[[^\]]*\]|[^\[\]])*)\]\([ \t]*()<?((?:\([^)]*\)|[^()\s])*?)>?[ \t]*((['"])(.*?)\6[ \t]*)?\))/g, writeAnchorTag);

                  //
                  // Last, handle reference-style shortcuts: [link text]
                  // These must come last in case you've also got [link test][1]
                  // or [link test](/foo)
                  //

                  /*
                   text = text.replace(/
                   (                   // wrap whole match in $1
                   \[
                   ([^\[\]]+)      // link text = $2; can't contain '[' or ']'
                   \]
                   )
                   ()()()()()          // pad rest of backreferences
                   /g, writeAnchorTag);
                   */
                  text = text.replace(/(\[([^\[\]]+)\])()()()()()/g, writeAnchorTag);

                  return text;
            }

            function writeAnchorTag(wholeMatch, m1, m2, m3, m4, m5, m6, m7) {
                  if (m7 == undefined) m7 = "";
                  var whole_match = m1;
                  var link_text = m2.replace(/:\/\//g, "~P"); // to prevent auto-linking withing the link. will be converted back after the auto-linker runs
                  var link_id = m3.toLowerCase();
                  var url = m4;
                  var title = m7;

                  if (url == "") {
                        if (link_id == "") {
                              // lower-case and turn embedded newlines into spaces
                              link_id = link_text.toLowerCase().replace(/ ?\n/g, " ");
                        }
                        url = "#" + link_id;

                        if (g_urls.get(link_id) != undefined) {
                              url = g_urls.get(link_id);
                              if (g_titles.get(link_id) != undefined) {
                                    title = g_titles.get(link_id);
                              }
                        } else {
                              if (whole_match.search(/\(\s*\)$/m) > -1) {
                                    // Special case for explicit empty url
                                    url = "";
                              } else {
                                    return whole_match;
                              }
                        }
                  }
                  url = attributeSafeUrl(url);

                  var result = "<a href=\"" + url + "\"";

                  if (title != "") {
                        title = attributeEncode(title);
                        title = escapeCharacters(title, "*_");
                        result += " title=\"" + title + "\"";
                  }

                  result += ">" + link_text + "</a>";

                  return result;
            }

            function _DoImages(text) {

                  if (text.indexOf("![") === -1) return text;

                  //
                  // Turn Markdown image shortcuts into <img> tags.
                  //

                  //
                  // First, handle reference-style labeled images: ![alt text][id]
                  //

                  /*
                   text = text.replace(/
                   (                   // wrap whole match in $1
                   !\[
                   (.*?)           // alt text = $2
                   \]
                   [ ]?            // one optional space
                   (?:\n[ ]*)?     // one optional newline followed by spaces
                   \[
                   (.*?)           // id = $3
                   \]
                   )
                   ()()()()            // pad rest of backreferences
                   /g, writeImageTag);
                   */
                  text = text.replace(/(!\[(.*?)\][ ]?(?:\n[ ]*)?\[(.*?)\])()()()()/g, writeImageTag);

                  //
                  // Next, handle inline images:  ![alt text](url "optional title")
                  // Don't forget: encode * and _

                  /*
                   text = text.replace(/
                   (                   // wrap whole match in $1
                   !\[
                   (.*?)           // alt text = $2
                   \]
                   \s?             // One optional whitespace character
                   \(              // literal paren
                   [ \t]*
                   ()              // no id, so leave $3 empty
                   <?(\S+?)>?      // src url = $4
                   [ \t]*
                   (               // $5
                   (['"])      // quote char = $6
                   (.*?)       // title = $7
                   \6          // matching quote
                   [ \t]*
                   )?              // title is optional
                   \)
                   )
                   /g, writeImageTag);
                   */
                  text = text.replace(/(!\[(.*?)\]\s?\([ \t]*()<?(\S+?)>?[ \t]*((['"])(.*?)\6[ \t]*)?\))/g, writeImageTag);

                  return text;
            }

            function attributeEncode(text) {
                  // unconditionally replace angle brackets here -- what ends up in an attribute (e.g. alt or title)
                  // never makes sense to have verbatim HTML in it (and the sanitizer would totally break it)
                  return text.replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
            }

            function writeImageTag(wholeMatch, m1, m2, m3, m4, m5, m6, m7) {
                  var whole_match = m1;
                  var alt_text = m2;
                  var link_id = m3.toLowerCase();
                  var url = m4;
                  var title = m7;

                  if (!title) title = "";

                  if (url == "") {
                        if (link_id == "") {
                              // lower-case and turn embedded newlines into spaces
                              link_id = alt_text.toLowerCase().replace(/ ?\n/g, " ");
                        }
                        url = "#" + link_id;

                        if (g_urls.get(link_id) != undefined) {
                              url = g_urls.get(link_id);
                              if (g_titles.get(link_id) != undefined) {
                                    title = g_titles.get(link_id);
                              }
                        } else {
                              return whole_match;
                        }
                  } else if (OPTIONS.imgSrcFilter) {
                        url = OPTIONS.imgSrcFilter(url);
                  }

                  alt_text = escapeCharacters(attributeEncode(alt_text), "*_[]()");
                  url = escapeCharacters(url, "*_");
                  var result = "<img src=\"" + url + "\" alt=\"" + alt_text + "\"";

                  // attacklab: Markdown.pl adds empty title attributes to images.
                  // Replicate this bug.

                  //if (title != "") {
                  title = attributeEncode(title);
                  title = escapeCharacters(title, "*_");
                  result += " title=\"" + title + "\"";
                  //}

                  result += " />";

                  return result;
            }

            function _DoHeaders(text) {

                  // Setext-style headers:
                  //  Header 1
                  //  ========
                  //
                  //  Header 2
                  //  --------
                  //
                  text = text.replace(/^(.+)[ \t]*\n=+[ \t]*\n+/gm, function (wholeMatch, m1) {
                        return "<h1>" + _RunSpanGamut(m1) + "</h1>\n\n";
                  });

                  text = text.replace(/^(.+)[ \t]*\n-+[ \t]*\n+/gm, function (matchFound, m1) {
                        return "<h2>" + _RunSpanGamut(m1) + "</h2>\n\n";
                  });

                  // atx-style headers:
                  //  # Header 1
                  //  ## Header 2
                  //  ## Header 2 with closing hashes ##
                  //  ...
                  //  ###### Header 6
                  //

                  /*
                   text = text.replace(/
                   ^(\#{1,6})      // $1 = string of #'s
                   [ \t]*
                   (.+?)           // $2 = Header text
                   [ \t]*
                   \#*             // optional closing #'s (not counted)
                   \n+
                   /gm, function() {...});
                   */

                  text = text.replace(/^(\#{1,6})[ \t]*(.+?)[ \t]*\#*\n+/gm, function (wholeMatch, m1, m2) {
                        var h_level = m1.length;
                        return "<h" + h_level + ">" + _RunSpanGamut(m2) + "</h" + h_level + ">\n\n";
                  });

                  return text;
            }

            function _DoLists(text, isInsideParagraphlessListItem) {
                  // 2017-12-27 wiz：支持 Table 内使用 有序/无序列表
                  // text = text.replace(/<br\/?>/g, " \n");
                  // 2018-04-03 wiz：需要支持普通文本使用 <br/> 作为空行，所以每行以 <br/> 开头的不进行替换
                  text = text.replace(/(?!^)<br\/?>/gm, "\n");
                  //
                  // Form HTML ordered (numbered) and unordered (bulleted) lists.
                  //

                  // attacklab: add sentinel to hack around khtml/safari bug:
                  // http://bugs.webkit.org/show_bug.cgi?id=11231
                  text += "~0";

                  // Re-usable pattern to match any entirel ul or ol list:

                  /*
                   var whole_list = /
                   (                                   // $1 = whole list
                   (                               // $2
                   [ ]{0,3}                    // attacklab: g_tab_width - 1
                   ([*+-]|\d+[.])              // $3 = first list item marker
                   [ \t]+
                   )
                   [^\r]+?
                   (                               // $4
                   ~0                          // sentinel for workaround; should be $
                   |
                   \n{2,}
                   (?=\S)
                   (?!                         // Negative lookahead for another list item marker
                   [ \t]*
                   (?:[*+-]|\d+[.])[ \t]+
                   )
                   )
                   )
                   /g
                   */
                  var whole_list = /^(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]*?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm;
                  var list_type;
                  if (g_list_level) {
                        text = text.replace(whole_list, function (wholeMatch, m1, m2) {
                              var list = m1;
                              list_type = getListType(m2);
                              //2015-10-22 wiz：删除起始序列号 支持
                              //var first_number;
                              //if (list_type === "ol")
                              //    first_number = parseInt(m2, 10)

                              var result = _ProcessListItems(list, list_type, isInsideParagraphlessListItem);

                              // Trim any trailing whitespace, to put the closing `</$list_type>`
                              // up on the preceding line, to get it past the current stupid
                              // HTML block parser. This is a hack to work around the terrible
                              // hack that is the HTML block parser.
                              var resultStr = result.list_str.replace(/\s+$/, "");
                              var opening = "<" + list_type;
                              //if (first_number && first_number !== 1)
                              //    opening += " start=\"" + first_number + "\"";
                              resultStr = opening + ">" + resultStr + "</" + result.list_type + ">\n\n";
                              list_type = result.list_type;
                              return resultStr;
                        });
                  } else {
                        whole_list = /(\n\n|^\n?)(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm;
                        text = text.replace(whole_list, function (wholeMatch, m1, m2, m3) {
                              var runup = m1;
                              var list = m2;
                              list_type = getListType(m3);
                              //2015-10-22 wiz：删除起始序列号 支持
                              //var first_number;
                              //if (list_type === "ol")
                              //    first_number = parseInt(m3, 10)

                              var result = _ProcessListItems(list, list_type);

                              var opening = "<" + list_type;
                              //if (first_number && first_number !== 1)
                              //    opening += " start=\"" + first_number + "\"";

                              var resultStr = runup + opening + ">\n" + result.list_str + "</" + result.list_type + ">\n\n";
                              list_type = result.list_type;
                              return resultStr;
                        });
                  }

                  // attacklab: strip sentinel
                  text = text.replace(/~0/, "");

                  return text;
            }

            var _listItemMarkers = { ol: "\\d+[.]", ul: "[*+-]" };

            function getListType(str) {
                  return str.search(/[*+-]/g) > -1 ? "ul" : "ol";
            }

            function _ProcessListItems(list_str, list_type, isInsideParagraphlessListItem) {
                  //
                  //  Process the contents of a single ordered or unordered list, splitting it
                  //  into individual list items.
                  //
                  //  list_type is either "ul" or "ol".

                  // The $g_list_level global keeps track of when we're inside a list.
                  // Each time we enter a list, we increment it; when we leave a list,
                  // we decrement. If it's zero, we're not in a list anymore.
                  //
                  // We do this because when we're not inside a list, we want to treat
                  // something like this:
                  //
                  //    I recommend upgrading to version
                  //    8. Oops, now this line is treated
                  //    as a sub-list.
                  //
                  // As a single paragraph, despite the fact that the second line starts
                  // with a digit-period-space sequence.
                  //
                  // Whereas when we're inside a list (or sub-list), that line will be
                  // treated as the start of a sub-list. What a kludge, huh? This is
                  // an aspect of Markdown's syntax that's hard to parse perfectly
                  // without resorting to mind-reading. Perhaps the solution is to
                  // change the syntax rules such that sub-lists must start with a
                  // starting cardinal number; e.g. "1." or "a.".

                  g_list_level++;

                  // trim trailing blank lines:
                  list_str = list_str.replace(/\n{2,}$/, "\n");

                  // attacklab: add sentinel to emulate \z
                  list_str += "~0";

                  // In the original attacklab showdown, list_type was not given to this function, and anything
                  // that matched /[*+-]|\d+[.]/ would just create the next <li>, causing this mismatch:
                  //
                  //  Markdown          rendered by WMD        rendered by MarkdownSharp
                  //  ------------------------------------------------------------------
                  //  1. first          1. first               1. first
                  //  2. second         2. second              2. second
                  //  - third           3. third                   * third
                  //
                  // We changed this to behave identical to MarkdownSharp. This is the constructed RegEx,
                  // with {MARKER} being one of \d+[.] or [*+-], depending on list_type:

                  /*
                   list_str = list_str.replace(/
                   (^[ \t]*)                       // leading whitespace = $1
                   ({MARKER}) [ \t]+               // list marker = $2
                   ([^\r]+?                        // list item text   = $3
                   (\n+)
                   )
                   (?=
                   (~0 | \2 ({MARKER}) [ \t]+)
                   )
                   /gm, function(){...});
                   */

                  //2015-10-22 wiz: 修改 list 的支持规则， 同级的 无序列表 和 有序列表 不会自动处理为 父子关系， 而是生成平级的两个列表；
                  //var marker = _listItemMarkers[list_type];
                  //var re = new RegExp("(^[ \\t]*)(" + marker + ")[ \\t]+([^\\r]+?(\\n+))(?=(~0|\\1(" + marker + ")[ \\t]+))", "gm");
                  var re = new RegExp("(^[ \\t]*)([*+-]|\\d+[.])[ \\t]+([^\\r]*?(\\n+))(?=(~0|\\1([*+-]|\\d+[.])[ \\t]+))", "gm");
                  var last_item_had_a_double_newline = false;
                  list_str = list_str.replace(re, function (wholeMatch, m1, m2, m3) {
                        var item = m3;
                        var leading_space = m1;
                        var cur_list_type = getListType(m2);
                        var ends_with_double_newline = /\n\n$/.test(item);
                        var contains_double_newline = ends_with_double_newline || item.search(/\n{2,}/) > -1;
                        var isTodo = /^\[( |x)\]/.test(item);

                        var loose = contains_double_newline || last_item_had_a_double_newline;
                        item = _RunBlockGamut(_Outdent(item), /* doNotUnhash = */true, /* doNotCreateParagraphs = */!loose);

                        var itemHtml = '';
                        if (cur_list_type != list_type) {
                              itemHtml = '</' + list_type + '>\n<' + cur_list_type + '>\n';
                              list_type = cur_list_type;
                        }
                        // 判断是否为 todo_list
                        if (isTodo) {
                              itemHtml += "<li class='wiz-md-todo-list-item'>";
                        } else {
                              itemHtml += "<li>";
                        }
                        itemHtml += item + "</li>\n";

                        last_item_had_a_double_newline = ends_with_double_newline;
                        return itemHtml;
                  });

                  // attacklab: strip sentinel
                  list_str = list_str.replace(/~0/g, "");

                  g_list_level--;
                  return { list_str: list_str, list_type: list_type };
            }

            function _DoCodeBlocks(text) {
                  //
                  //  Process Markdown `<pre><code>` blocks.
                  //

                  /*
                   text = text.replace(/
                   (?:\n\n|^)
                   (                               // $1 = the code block -- one or more lines, starting with a space/tab
                   (?:
                   (?:[ ]{4}|\t)           // Lines must start with a tab or a tab-width of spaces - attacklab: g_tab_width
                   .*\n+
                   )+
                   )
                   (\n*[ ]{0,3}[^ \t\n]|(?=~0))    // attacklab: g_tab_width
                   /g ,function(){...});
                   */

                  // attacklab: sentinel workarounds for lack of \A and \Z, safari\khtml bug
                  text += "~0";

                  text = text.replace(/(?:\n\n|^\n?)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=~0))/g, function (wholeMatch, m1, m2) {
                        var codeblock = m1;
                        var nextChar = m2;

                        codeblock = _EncodeCode(_Outdent(codeblock));
                        codeblock = _Detab(codeblock);
                        codeblock = codeblock.replace(/^\n+/g, ""); // trim leading newlines
                        codeblock = codeblock.replace(/\n+$/g, ""); // trim trailing whitespace

                        codeblock = "<pre><code>" + codeblock + "\n</code></pre>";

                        return "\n\n" + codeblock + "\n\n" + nextChar;
                  });

                  // attacklab: strip sentinel
                  text = text.replace(/~0/, "");

                  return text;
            }

            function _DoCodeSpans(text) {
                  //
                  // * Backtick quotes are used for <code></code> spans.
                  //
                  // * You can use multiple backticks as the delimiters if you want to
                  //   include literal backticks in the code span. So, this input:
                  //
                  //      Just type ``foo `bar` baz`` at the prompt.
                  //
                  //   Will translate to:
                  //
                  //      <p>Just type <code>foo `bar` baz</code> at the prompt.</p>
                  //
                  //   There's no arbitrary limit to the number of backticks you
                  //   can use as delimters. If you need three consecutive backticks
                  //   in your code, use four for delimiters, etc.
                  //
                  // * You can use spaces to get literal backticks at the edges:
                  //
                  //      ... type `` `bar` `` ...
                  //
                  //   Turns to:
                  //
                  //      ... type <code>`bar`</code> ...
                  //

                  /*
                   text = text.replace(/
                   (^|[^\\`])      // Character before opening ` can't be a backslash or backtick
                   (`+)            // $2 = Opening run of `
                   (?!`)           // and no more backticks -- match the full run
                   (               // $3 = The code block
                   [^\r]*?
                   [^`]        // attacklab: work around lack of lookbehind
                   )
                   \2              // Matching closer
                   (?!`)
                   /gm, function(){...});
                   */

                  text = text.replace(/(^|[^\\`])(`+)(?!`)([^\r]*?[^`])\2(?!`)/gm, function (wholeMatch, m1, m2, m3, m4) {
                        var c = m3;
                        c = c.replace(/^([ \t]*)/g, ""); // leading whitespace
                        c = c.replace(/[ \t]*$/g, ""); // trailing whitespace
                        c = _EncodeCode(c);
                        c = c.replace(/:\/\//g, "~P"); // to prevent auto-linking. Not necessary in code *blocks*, but in code spans. Will be converted back after the auto-linker runs.
                        return m1 + "<code>" + c + "</code>";
                  });

                  return text;
            }

            function _EncodeCode(text) {
                  //
                  // Encode/escape certain characters inside Markdown code runs.
                  // The point is that in code, these characters are literals,
                  // and lose their special Markdown meanings.
                  //
                  // Encode all ampersands; HTML entities are not
                  // entities within a Markdown code span.
                  text = text.replace(/&/g, "&amp;");

                  // Do the angle bracket song and dance:
                  text = text.replace(/</g, "&lt;");
                  text = text.replace(/>/g, "&gt;");

                  // Now, escape characters that are magic in Markdown:
                  text = escapeCharacters(text, "\*_{}[]\\", false);

                  // jj the line above breaks this:
                  //---

                  //* Item

                  //   1. Subitem

                  //            special char: *
                  //---

                  return text;
            }

            function _DoItalicsAndBoldStrict(text) {

                  if (text.indexOf("*") === -1 && text.indexOf("_") === -1) return text;

                  text = asciify(text);

                  // <strong> must go first:

                  // (^|[\W_])           Start with a non-letter or beginning of string. Store in \1.
                  // (?:(?!\1)|(?=^))    Either the next character is *not* the same as the previous,
                  //                     or we started at the end of the string (in which case the previous
                  //                     group had zero width, so we're still there). Because the next
                  //                     character is the marker, this means that if there are e.g. multiple
                  //                     underscores in a row, we can only match the left-most ones (which
                  //                     prevents foo___bar__ from getting bolded)
                  // (\*|_)              The marker character itself, asterisk or underscore. Store in \2.
                  // \2                  The marker again, since bold needs two.
                  // (?=\S)              The first bolded character cannot be a space.
                  // ([^\r]*?\S)         The actual bolded string. At least one character, and it cannot *end*
                  //                     with a space either. Note that like in many other places, [^\r] is
                  //                     just a workaround for JS' lack of single-line regexes; it's equivalent
                  //                     to a . in an /s regex, because the string cannot contain any \r (they
                  //                     are removed in the normalizing step).
                  // \2\2                The marker character, twice -- end of bold.
                  // (?!\2)              Not followed by another marker character (ensuring that we match the
                  //                     rightmost two in a longer row)...
                  // (?=[\W_]|$)         ...but by any other non-word character or the end of string.
                  text = text.replace(/(^|[\W_])(?:(?!\1)|(?=^))(\*|_)\2(?=\S)([^\r]*?\S)\2\2(?!\2)(?=[\W_]|$)/g, "$1<strong>$3</strong>");

                  // This is almost identical to the <strong> regex, except 1) there's obviously just one marker
                  // character, and 2) the italicized string cannot contain the marker character.
                  text = text.replace(/(^|[\W_])(?:(?!\1)|(?=^))(\*|_)(?=\S)((?:(?!\2)[^\r])*?\S)\2(?!\2)(?=[\W_]|$)/g, "$1<em>$3</em>");

                  return deasciify(text);
            }

            function _DoItalicsAndBold_AllowIntrawordWithAsterisk(text) {

                  if (text.indexOf("*") === -1 && text.indexOf("_") === -1) return text;

                  text = asciify(text);

                  // <strong> must go first:
                  // (?=[^\r][*_]|[*_])               Optimization only, to find potentially relevant text portions faster. Minimally slower in Chrome, but much faster in IE.
                  // (                                Store in \1. This is the last character before the delimiter
                  //     ^                            Either we're at the start of the string (i.e. there is no last character)...
                  //     |                            ... or we allow one of the following:
                  //     (?=                          (lookahead; we're not capturing this, just listing legal possibilities)
                  //         \W__                     If the delimiter is __, then this last character must be non-word non-underscore (extra-word emphasis only)
                  //         |
                  //         (?!\*)[\W_]\*\*          If the delimiter is **, then this last character can be non-word non-asterisk (extra-word emphasis)...
                  //         |
                  //         \w\*\*\w                 ...or it can be word/underscore, but only if the first bolded character is such a character as well (intra-word emphasis)
                  //     )
                  //     [^\r]                        actually capture the character (can't use `.` since it could be \n)
                  // )
                  // (\*\*|__)                        Store in \2: the actual delimiter
                  // (?!\2)                           not followed by the delimiter again (at most one more asterisk/underscore is allowed)
                  // (?=\S)                           the first bolded character can't be a space
                  // (                                Store in \3: the bolded string
                  //
                  //     (?:|                         Look at all bolded characters except for the last one. Either that's empty, meaning only a single character was bolded...
                  //       [^\r]*?                    ... otherwise take arbitrary characters, minimally matching; that's all bolded characters except for the last *two*
                  //       (?!\2)                       the last two characters cannot be the delimiter itself (because that would mean four underscores/asterisks in a row)
                  //       [^\r]                        capture the next-to-last bolded character
                  //     )
                  //     (?=                          lookahead at the very last bolded char and what comes after
                  //         \S_                      for underscore-bolding, it can be any non-space
                  //         |
                  //         \w                       for asterisk-bolding (otherwise the previous alternative would've matched, since \w implies \S), either the last char is word/underscore...
                  //         |
                  //         \S\*\*(?:[\W_]|$)        ... or it's any other non-space, but in that case the character *after* the delimiter may not be a word character
                  //     )
                  //     .                            actually capture the last character (can use `.` this time because the lookahead ensures \S in all cases)
                  // )
                  // (?=                              lookahead; list the legal possibilities for the closing delimiter and its following character
                  //     __(?:\W|$)                   for underscore-bolding, the following character (if any) must be non-word non-underscore
                  //     |
                  //     \*\*(?:[^*]|$)               for asterisk-bolding, any non-asterisk is allowed (note we already ensured above that it's not a word character if the last bolded character wasn't one)
                  // )
                  // \2                               actually capture the closing delimiter (and make sure that it matches the opening one)


                  //2015-10-26 改善对 xxx**(1)**xxx 的支持
                  //text = text.replace(/(?=[^\r][*_]|[*_])(^|(?=\W__|(?!\*)[\W_]\*\*|\w\*\*\w)[^\r])(\*\*|__)(?!\2)(?=\S)((?:|[^\r]*?(?!\2)[^\r])(?=\S_|\w|\S\*\*(?:[\W_]|$)).)(?=__(?:\W|$)|\*\*(?:[^*]|$))\2/g,
                  //    "$1<strong>$3</strong>");
                  text = text.replace(/(?=[^\r][*_]|[*_])(^|(?=\W__|(?!\*)[\w\W_]\*\*|\w\*\*\w)[^\r])(\*\*|__)(?!\2)(?=\S)((?:|[^\r]*?(?!\2)[^\r])(?=\S_|\w|.\*\*(?:[\w\W_]|$)).)(?=__(?:\W|$)|\*\*(?:[^*]|$))\2/g, "$1<strong>$3</strong>");

                  // now <em>:
                  // (?=[^\r][*_]|[*_])               Optimization, see above.
                  // (                                Store in \1. This is the last character before the delimiter
                  //     ^                            Either we're at the start of the string (i.e. there is no last character)...
                  //     |                            ... or we allow one of the following:
                  //     (?=                          (lookahead; we're not capturing this, just listing legal possibilities)
                  //         \W_                      If the delimiter is _, then this last character must be non-word non-underscore (extra-word emphasis only)
                  //         |
                  //         (?!\*)                   otherwise, we list two possiblities for * as the delimiter; in either case, the last characters cannot be an asterisk itself
                  //         (?:
                  //             [\W_]\*              this last character can be non-word (extra-word emphasis)...
                  //             |
                  //             \D\*(?=\w)\D         ...or it can be word (otherwise the first alternative would've matched), but only if
                  //                                      a) the first italicized character is such a character as well (intra-word emphasis), and
                  //                                      b) neither character on either side of the asterisk is a digit
                  //         )
                  //     )
                  //     [^\r]                        actually capture the character (can't use `.` since it could be \n)
                  // )
                  // (\*|_)                           Store in \2: the actual delimiter
                  // (?!\2\2\2)                       not followed by more than two more instances of the delimiter
                  // (?=\S)                           the first italicized character can't be a space
                  // (                                Store in \3: the italicized string
                  //     (?:(?!\2)[^\r])*?            arbitrary characters except for the delimiter itself, minimally matching
                  //     (?=                          lookahead at the very last italicized char and what comes after
                  //         [^\s_]_                  for underscore-italicizing, it can be any non-space non-underscore
                  //         |
                  //         (?=\w)\D\*\D             for asterisk-italicizing, either the last char is word/underscore *and* neither character on either side of the asterisk is a digit...
                  //         |
                  //         [^\s*]\*(?:[\W_]|$)      ... or that last char is any other non-space non-asterisk, but then the character after the delimiter (if any) must be non-word
                  //     )
                  //     .                            actually capture the last character (can use `.` this time because the lookahead ensures \S in all cases)
                  // )
                  // (?=                              lookahead; list the legal possibilities for the closing delimiter and its following character
                  //     _(?:\W|$)                    for underscore-italicizing, the following character (if any) must be non-word non-underscore
                  //     |
                  //     \*(?:[^*]|$)                 for asterisk-italicizing, any non-asterisk is allowed; all other restrictions have already been ensured in the previous lookahead
                  // )
                  // \2                               actually capture the closing delimiter (and make sure that it matches the opening one)

                  //2015-10-26 改善对 xxx*(1)*xxx 的支持
                  //text = text.replace(/(?=[^\r][*_]|[*_])(^|(?=\W_|(?!\*)(?:[\W_]\*|\D\*(?=\w)\D))[^\r])(\*|_)(?!\2\2\2)(?=\S)((?:(?!\2)[^\r])*?(?=[^\s_]_|(?=\w)\D\*\D|[^\s*]\*(?:[\W_]|$)).)(?=_(?:\W|$)|\*(?:[^*]|$))\2/g,
                  //    "$1<em>$3</em>");
                  text = text.replace(/(?=[^\r][*_]|[*_])(^|(?=\W_|(?!\*)(?:[\w\W_]\*|\D\*(?=\w)\D))[^\r])(\*|_)(?!\2\2\2)(?=\S)((?:(?!\2)[^\r])*?(?=[^\s_]_|(?=[\w\W])\D\*\D|[^\s*]\*(?:[\w\W_]|$)).)(?=_(?:\W|$)|\*(?:[^*]|$))\2/g, "$1<em>$3</em>");

                  return deasciify(text);
            }

            function _DoBlockQuotes(text) {

                  /*
                   text = text.replace(/
                   (                           // Wrap whole match in $1
                   (
                   ^[ \t]*>[ \t]?      // '>' at the start of a line
                   .+\n                // rest of the first line
                   (.+\n)*             // subsequent consecutive lines
                   \n*                 // blanks
                   )+
                   )
                   /gm, function(){...});
                   */

                  text = text.replace(/((^[ \t]*>[ \t]?.+\n(.+\n)*\n*)+)/gm, function (wholeMatch, m1) {
                        var bq = m1;

                        // attacklab: hack around Konqueror 3.5.4 bug:
                        // "----------bug".replace(/^-/g,"") == "bug"

                        bq = bq.replace(/^[ \t]*>[ \t]?/gm, "~0"); // trim one level of quoting

                        // attacklab: clean up hack
                        bq = bq.replace(/~0/g, "");

                        bq = bq.replace(/^[ \t]+$/gm, ""); // trim whitespace-only lines
                        bq = _RunBlockGamut(bq); // recurse

                        bq = bq.replace(/(^|\n)/g, "$1  ");
                        // These leading spaces screw with <pre> content, so we need to fix that:
                        bq = bq.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function (wholeMatch, m1) {
                              var pre = m1;
                              // attacklab: hack around Konqueror 3.5.4 bug:
                              pre = pre.replace(/^  /mg, "~0");
                              pre = pre.replace(/~0/g, "");
                              return pre;
                        });

                        return hashBlock("<blockquote>\n" + bq + "\n</blockquote>");
                  });
                  return text;
            }

            function _FormParagraphs(text, doNotUnhash, doNotCreateParagraphs) {
                  //
                  //  Params:
                  //    $text - string to process with html <p> tags
                  //

                  // Strip leading and trailing lines:
                  text = text.replace(/^\n+/g, "");
                  text = text.replace(/\n+$/g, "");

                  var grafs = text.split(/\n{2,}/g);
                  var grafsOut = [];

                  var markerRe = /~K(\d+)K/;

                  //
                  // Wrap <p> tags.
                  //
                  var end = grafs.length;
                  for (var i = 0; i < end; i++) {
                        var str = grafs[i];

                        // if this is an HTML marker, copy it
                        if (markerRe.test(str)) {
                              grafsOut.push(str);
                        } else if (/\S/.test(str)) {
                              str = _RunSpanGamut(str);
                              str = str.replace(/^([ \t]*)/g, doNotCreateParagraphs ? "" : "<p>");
                              if (!doNotCreateParagraphs) str += "</p>";
                              grafsOut.push(str);
                        }
                  }
                  //
                  // Unhashify HTML blocks
                  //
                  if (!doNotUnhash) {
                        end = grafsOut.length;
                        for (var i = 0; i < end; i++) {
                              var foundAny = true;
                              while (foundAny) {
                                    // we may need several runs, since the data may be nested
                                    foundAny = false;
                                    grafsOut[i] = grafsOut[i].replace(/~K(\d+)K/g, function (wholeMatch, id) {
                                          foundAny = true;
                                          return g_html_blocks[id];
                                    });
                              }
                        }
                  }
                  return grafsOut.join("\n\n");
            }

            function _EncodeAmpsAndAngles(text) {
                  // Smart processing for ampersands and angle brackets that need to be encoded.

                  // Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:
                  //   http://bumppo.net/projects/amputator/
                  text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, "&amp;");

                  // Encode naked <'s
                  // support x<<y
                  text = text.replace(/<(?!([a-z\/?!][^<>]*>)|~D)/gi, "&lt;");

                  return text;
            }

            function _EncodeBackslashEscapes(text) {
                  //
                  //   Parameter:  String.
                  //   Returns:    The string, with after processing the following backslash
                  //               escape sequences.
                  //

                  // attacklab: The polite way to do this is with the new
                  // escapeCharacters() function:
                  //
                  //     text = escapeCharacters(text,"\\",true);
                  //     text = escapeCharacters(text,"`*_{}[]()>#+-.!",true);
                  //
                  // ...but we're sidestepping its use of the (slow) RegExp constructor
                  // as an optimization for Firefox.  This function gets called a LOT.

                  text = text.replace(/\\(\\)/g, escapeCharacters_callback);
                  text = text.replace(/\\([`*_{}\[\]()>#+-.!])/g, escapeCharacters_callback);
                  return text;
            }

            var charInsideUrl = "[-A-Z0-9+&@#/%?=~_|[\\]()!:,.;]",
                charEndingUrl = "[-A-Z0-9+&@#/%=~_|[\\])]",
                autoLinkRegex = new RegExp("(=\"|<)?\\b(https?|ftp)(://" + charInsideUrl + "*" + charEndingUrl + ")(?=$|\\W)", "gi"),
                endCharRegex = new RegExp(charEndingUrl, "i");

            function handleTrailingParens(wholeMatch, lookbehind, protocol, link, index, str) {

                  if (/^<[^<>]*(https?|ftp)/.test(str)) {
                        //避免 html 标签内 属性值的 超链接被替换为 a 标签（例如 img 的src 属性）
                        return wholeMatch;
                  }
                  if (lookbehind) return wholeMatch;
                  if (link.charAt(link.length - 1) !== ")") return "<" + protocol + link + ">";
                  var parens = link.match(/[()]/g);
                  var level = 0;
                  for (var i = 0; i < parens.length; i++) {
                        if (parens[i] === "(") {
                              if (level <= 0) level = 1;else level++;
                        } else {
                              level--;
                        }
                  }
                  var tail = "";
                  if (level < 0) {
                        var re = new RegExp("\\){1," + -level + "}$");
                        link = link.replace(re, function (trailingParens) {
                              tail = trailingParens;
                              return "";
                        });
                  }
                  if (tail) {
                        var lastChar = link.charAt(link.length - 1);
                        if (!endCharRegex.test(lastChar)) {
                              tail = lastChar + tail;
                              link = link.substr(0, link.length - 1);
                        }
                  }
                  return "<" + protocol + link + ">" + tail;
            }

            function _DoAutoLinks(text) {

                  // note that at this point, all other URL in the text are already hyperlinked as <a href=""></a>
                  // *except* for the <http://www.foo.com> case

                  // automatically add < and > around unadorned raw hyperlinks
                  // must be preceded by a non-word character (and not by =" or <) and followed by non-word/EOF character
                  // simulating the lookbehind in a consuming way is okay here, since a URL can neither and with a " nor
                  // with a <, so there is no risk of overlapping matches.
                  text = text.replace(autoLinkRegex, handleTrailingParens);

                  //  autolink anything like <http://example.com>


                  var replacer = function replacer(wholematch, m1) {
                        var url = attributeSafeUrl(m1);

                        return "<a href=\"" + url + "\">" + pluginHooks.plainLinkText(m1) + "</a>";
                  };
                  text = text.replace(/<((https?|ftp):[^'">\s]+)>/gi, replacer);

                  // Email addresses: <address@domain.foo>
                  /*
                   text = text.replace(/
                   <
                   (?:mailto:)?
                   (
                   [-.\w]+
                   \@
                   [-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+
                   )
                   >
                   /gi, _DoAutoLinks_callback());
                   */

                  /* disabling email autolinking, since we don't do that on the server, either
                   text = text.replace(/<(?:mailto:)?([-.\w]+\@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi,
                   function(wholeMatch,m1) {
                   return _EncodeEmailAddress( _UnescapeSpecialChars(m1) );
                   }
                   );
                   */
                  return text;
            }

            function _UnescapeSpecialChars(text) {
                  //
                  // Swap back in all the special characters we've hidden.
                  //
                  text = text.replace(/~E(\d+)E/g, function (wholeMatch, m1) {
                        var charCodeToReplace = parseInt(m1);
                        return String.fromCharCode(charCodeToReplace);
                  });
                  return text;
            }

            function _Outdent(text) {
                  //
                  // Remove one level of line-leading tabs or spaces
                  //

                  // attacklab: hack around Konqueror 3.5.4 bug:
                  // "----------bug".replace(/^-/g,"") == "bug"

                  text = text.replace(/^(\t|[ ]{1,4})/gm, "~0"); // attacklab: g_tab_width

                  // attacklab: clean up hack
                  text = text.replace(/~0/g, "");

                  return text;
            }

            function _Detab(text) {
                  if (!/\t/.test(text)) return text;

                  var spaces = ["    ", "   ", "  ", " "],
                      skew = 0,
                      v;

                  return text.replace(/[\n\t]/g, function (match, offset) {
                        if (match === "\n") {
                              skew = offset + 1;
                              return match;
                        }
                        v = (offset - skew) % 4;
                        skew = offset + 1;
                        return spaces[v];
                  });
            }

            //
            //  attacklab: Utility functions
            //

            function attributeSafeUrl(url) {
                  url = attributeEncode(url);
                  url = escapeCharacters(url, "*_:()[]");
                  return url;
            }

            function escapeCharacters(text, charsToEscape, afterBackslash) {
                  // First we have to escape the escape characters so that
                  // we can build a character class out of them
                  var regexString = "([" + charsToEscape.replace(/([\[\]\\])/g, "\\$1") + "])";

                  if (afterBackslash) {
                        regexString = "\\\\" + regexString;
                  }

                  var regex = new RegExp(regexString, "g");
                  text = text.replace(regex, escapeCharacters_callback);

                  return text;
            }

            function escapeCharacters_callback(wholeMatch, m1) {
                  var charCodeToEscape = m1.charCodeAt(0);
                  return "~E" + charCodeToEscape + "E";
            }
      }; // end of the Markdown.Converter constructor
})();

module.exports = Markdown;

},{}],395:[function(require,module,exports){
'use strict';

var Markdown = {};

(function () {
  // A quick way to make sure we're only keeping span-level tags when we need to.
  // This isn't supposed to be foolproof. It's just a quick way to make sure we
  // keep all span-level tags returned by a pagedown converter. It should allow
  // all span-level tags through, with or without attributes.
  var inlineTags = new RegExp(['^(<\\/?(a|abbr|acronym|applet|area|b|basefont|', 'bdo|big|button|cite|code|del|dfn|em|figcaption|', 'font|i|iframe|img|input|ins|kbd|label|map|', 'mark|meter|object|param|progress|q|ruby|rp|rt|s|', 'samp|script|select|small|span|strike|strong|',
  // 2017-12-27 wiz：支持 Table 内使用 有序/无序列表
  // 'sub|sup|textarea|time|tt|u|var|wbr)[^>]*>|',
  'sub|sup|textarea|time|tt|u|var|wbr|ul|ol|li)[^>]*>|', '<(br)\\s?\\/?>)$'].join(''), 'i');

  /******************************************************************
   * Utility Functions                                              *
   *****************************************************************/

  // patch for ie7
  if (!Array.indexOf) {
    Array.prototype.indexOf = function (obj) {
      for (var i = 0; i < this.length; i++) {
        if (this[i] == obj) {
          return i;
        }
      }
      return -1;
    };
  }

  function trim(str) {
    return str.replace(/^\s+|\s+$/g, '');
  }

  function rtrim(str) {
    return str.replace(/\s+$/g, '');
  }

  // Remove one level of indentation from text. Indent is 4 spaces.
  function outdent(text) {
    return text.replace(new RegExp('^(\\t|[ ]{1,4})', 'gm'), '');
  }

  function contains(str, substr) {
    return str.indexOf(substr) != -1;
  }

  // Sanitize html, removing tags that aren't in the whitelist
  function sanitizeHtml(html, whitelist) {
    return html.replace(/<[^>]*>?/gi, function (tag) {
      return tag.match(whitelist) ? tag : '';
    });
  }

  // Merge two arrays, keeping only unique elements.
  function union(x, y) {
    var obj = {};
    for (var i = 0; i < x.length; i++) {
      obj[x[i]] = x[i];
    }for (i = 0; i < y.length; i++) {
      obj[y[i]] = y[i];
    }var res = [];
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) res.push(obj[k]);
    }
    return res;
  }

  // JS regexes don't support \A or \Z, so we add sentinels, as Pagedown
  // does. In this case, we add the ascii codes for start of text (STX) and
  // end of text (ETX), an idea borrowed from:
  // https://github.com/tanakahisateru/js-markdown-extra
  function addAnchors(text) {
    if (text.charAt(0) != '\x02') text = '\x02' + text;
    if (text.charAt(text.length - 1) != '\x03') text = text + '\x03';
    return text;
  }

  // Remove STX and ETX sentinels.
  function removeAnchors(text) {
    if (text.charAt(0) == '\x02') text = text.substr(1);
    if (text.charAt(text.length - 1) == '\x03') text = text.substr(0, text.length - 1);
    return text;
  }

  // Convert markdown within an element, retaining only span-level tags
  function convertSpans(text, extra) {
    return sanitizeHtml(convertAll(text, extra), inlineTags);
  }

  // Convert internal markdown using the stock pagedown converter
  function convertAll(text, extra) {
    var result = extra.blockGamutHookCallback(text);
    // We need to perform these operations since we skip the steps in the converter
    result = unescapeSpecialChars(result);
    result = result.replace(/~D/g, "$$").replace(/~T/g, "~");
    result = extra.previousPostConversion(result);
    return result;
  }

  // Convert escaped special characters
  function processEscapesStep1(text) {
    // Markdown extra adds two escapable characters, `:` and `|`
    return text.replace(/\\\|/g, '~I').replace(/\\:/g, '~i');
  }

  function processEscapesStep2(text) {
    return text.replace(/~I/g, '|').replace(/~i/g, ':');
  }

  // Duplicated from PageDown converter
  function unescapeSpecialChars(text) {
    // Swap back in all the special characters we've hidden.
    text = text.replace(/~E(\d+)E/g, function (wholeMatch, m1) {
      var charCodeToReplace = parseInt(m1);
      return String.fromCharCode(charCodeToReplace);
    });
    return text;
  }

  function slugify(text) {
    return text.toLowerCase().replace(/\s+/g, '-') // Replace spaces with -
    .replace(/[^\w\-]+/g, '') // Remove all non-word chars
    .replace(/\-\-+/g, '-') // Replace multiple - with single -
    .replace(/^-+/, '') // Trim - from start of text
    .replace(/-+$/, ''); // Trim - from end of text
  }

  /*****************************************************************************
   * Markdown.Extra *
   ****************************************************************************/

  Markdown.Extra = function () {
    // For converting internal markdown (in tables for instance).
    // This is necessary since these methods are meant to be called as
    // preConversion hooks, and the Markdown converter passed to init()
    // won't convert any markdown contained in the html tags we return.
    this.converter = null;

    // Stores html blocks we generate in hooks so that
    // they're not destroyed if the user is using a sanitizing converter
    this.hashBlocks = [];

    // Stores footnotes
    this.footnotes = {};
    this.usedFootnotes = [];

    // Special attribute blocks for fenced code blocks and headers enabled.
    this.attributeBlocks = false;

    // Fenced code block options
    this.googleCodePrettify = false;
    this.highlightJs = false;
    this.codeMirror = false;

    // Table options
    this.tableClass = '';

    this.tabWidth = 4;
  };

  Markdown.Extra.init = function (converter, options) {
    // Each call to init creates a new instance of Markdown.Extra so it's
    // safe to have multiple converters, with different options, on a single page
    var extra = new Markdown.Extra();
    var postNormalizationTransformations = [];
    var preBlockGamutTransformations = [];
    var postSpanGamutTransformations = [];
    var postConversionTransformations = ["unHashExtraBlocks"];

    options = options || {};
    options.extensions = options.extensions || ["all"];
    if (contains(options.extensions, "all")) {
      options.extensions = ["tables", "fenced_code_gfm", "def_list", "attr_list", "footnotes", "smartypants", "todo_list", "strikethrough", "newlines"];
    }
    preBlockGamutTransformations.push("wrapHeaders");

    if (contains(options.extensions, "todo_list")) {
      preBlockGamutTransformations.push("todo_list");
    }
    if (contains(options.extensions, "attr_list")) {
      postNormalizationTransformations.push("hashFcbAttributeBlocks");
      preBlockGamutTransformations.push("hashHeaderAttributeBlocks");
      postConversionTransformations.push("applyAttributeBlocks");
      extra.attributeBlocks = true;
    }
    if (contains(options.extensions, "fenced_code_gfm")) {
      // This step will convert fcb inside list items and blockquotes
      preBlockGamutTransformations.push("fencedCodeBlocks");
      // This extra step is to prevent html blocks hashing and link definition/footnotes stripping inside fcb
      postNormalizationTransformations.push("fencedCodeBlocks");
    }
    if (contains(options.extensions, "tables")) {
      preBlockGamutTransformations.push("tables");
    }
    if (contains(options.extensions, "def_list")) {
      preBlockGamutTransformations.push("definitionLists");
    }
    if (contains(options.extensions, "footnotes")) {
      postNormalizationTransformations.push("stripFootnoteDefinitions");
      preBlockGamutTransformations.push("doFootnotes");
      postConversionTransformations.push("printFootnotes");
    }
    if (contains(options.extensions, "smartypants")) {
      postConversionTransformations.push("runSmartyPants");
    }
    if (contains(options.extensions, "strikethrough")) {
      postSpanGamutTransformations.push("strikethrough");
    }
    if (contains(options.extensions, "newlines")) {
      postSpanGamutTransformations.push("newlines");
    }

    converter.hooks.chain("postNormalization", function (text) {
      return extra.doTransform(postNormalizationTransformations, text) + '\n';
    });

    converter.hooks.chain("preBlockGamut", function (text, blockGamutHookCallback) {
      // Keep a reference to the block gamut callback to run recursively
      extra.blockGamutHookCallback = blockGamutHookCallback;
      text = processEscapesStep1(text);
      text = extra.doTransform(preBlockGamutTransformations, text) + '\n';
      text = processEscapesStep2(text);
      return text;
    });

    converter.hooks.chain("postSpanGamut", function (text) {
      return extra.doTransform(postSpanGamutTransformations, text);
    });

    // Keep a reference to the hook chain running before doPostConversion to apply on hashed extra blocks
    extra.previousPostConversion = converter.hooks.postConversion;
    converter.hooks.chain("postConversion", function (text) {
      text = extra.doTransform(postConversionTransformations, text);
      // Clear state vars that may use unnecessary memory
      extra.hashBlocks = [];
      extra.footnotes = {};
      extra.usedFootnotes = [];
      return text;
    });

    if ("highlighter" in options) {
      extra.googleCodePrettify = options.highlighter === 'prettify';
      extra.highlightJs = options.highlighter === 'highlight';
      extra.codeMirror = options.highlighter === 'codeMirror';
    }

    if ("table_class" in options) {
      extra.tableClass = options.table_class;
    }

    extra.converter = converter;

    // Caller usually won't need this, but it's handy for testing.
    return extra;
  };

  // Do transformations
  Markdown.Extra.prototype.doTransform = function (transformations, text) {
    for (var i = 0; i < transformations.length; i++) {
      text = this[transformations[i]](text);
    }return text;
  };

  // Return a placeholder containing a key, which is the block's index in the
  // hashBlocks array. We wrap our output in a <p> tag here so Pagedown won't.
  Markdown.Extra.prototype.hashExtraBlock = function (block) {
    return '\n<p>~X' + (this.hashBlocks.push(block) - 1) + 'X</p>\n';
  };
  Markdown.Extra.prototype.hashExtraInline = function (block) {
    return '~X' + (this.hashBlocks.push(block) - 1) + 'X';
  };

  // Replace placeholder blocks in `text` with their corresponding
  // html blocks in the hashBlocks array.
  Markdown.Extra.prototype.unHashExtraBlocks = function (text) {
    var self = this;

    function recursiveUnHash() {
      var hasHash = false;
      text = text.replace(/(?:<p>)?~X(\d+)X(?:<\/p>)?/g, function (wholeMatch, m1) {
        hasHash = true;
        var key = parseInt(m1, 10);
        return self.hashBlocks[key];
      });
      if (hasHash === true) {
        recursiveUnHash();
      }
    }

    recursiveUnHash();
    return text;
  };

  // Wrap headers to make sure they won't be in def lists
  Markdown.Extra.prototype.wrapHeaders = function (text) {
    function wrap(text) {
      return '\n' + text + '\n';
    }

    text = text.replace(/^.+[ \t]*\n=+[ \t]*\n+/gm, wrap);
    text = text.replace(/^.+[ \t]*\n-+[ \t]*\n+/gm, wrap);
    text = text.replace(/^\#{1,6}[ \t]*.+?[ \t]*\#*\n+/gm, wrap);
    return text;
  };

  /******************************************************************
   * Attribute Blocks                                               *
   *****************************************************************/

  // TODO: use sentinels. Should we just add/remove them in doConversion?
  // TODO: better matches for id / class attributes
  var attrBlock = "\\{[ \\t]*((?:[#.][-_:a-zA-Z0-9]+[ \\t]*)+)\\}";
  var hdrAttributesA = new RegExp("^(#{1,6}.*#{0,6})[ \\t]+" + attrBlock + "[ \\t]*(?:\\n|0x03)", "gm");
  var hdrAttributesB = new RegExp("^(.*)[ \\t]+" + attrBlock + "[ \\t]*\\n" + "(?=[\\-|=]+\\s*(?:\\n|0x03))", "gm"); // underline lookahead
  var fcbAttributes = new RegExp("^(```[ \\t]*[^{\\s]*)[ \\t]+" + attrBlock + "[ \\t]*\\n" + "(?=([\\s\\S]*?)\\n```[ \\t]*(\\n|0x03))", "gm");

  // Extract headers attribute blocks, move them above the element they will be
  // applied to, and hash them for later.
  Markdown.Extra.prototype.hashHeaderAttributeBlocks = function (text) {

    var self = this;

    function attributeCallback(wholeMatch, pre, attr) {
      return '<p>~XX' + (self.hashBlocks.push(attr) - 1) + 'XX</p>\n' + pre + "\n";
    }

    text = text.replace(hdrAttributesA, attributeCallback); // ## headers
    text = text.replace(hdrAttributesB, attributeCallback); // underline headers
    return text;
  };

  // Extract FCB attribute blocks, move them above the element they will be
  // applied to, and hash them for later.
  Markdown.Extra.prototype.hashFcbAttributeBlocks = function (text) {
    // TODO: use sentinels. Should we just add/remove them in doConversion?
    // TODO: better matches for id / class attributes

    var self = this;

    function attributeCallback(wholeMatch, pre, attr) {
      return '<p>~XX' + (self.hashBlocks.push(attr) - 1) + 'XX</p>\n' + pre + "\n";
    }

    return text.replace(fcbAttributes, attributeCallback);
  };

  Markdown.Extra.prototype.applyAttributeBlocks = function (text) {
    var self = this;
    var blockRe = new RegExp('<p>~XX(\\d+)XX</p>[\\s]*' + '(?:<(h[1-6]|pre)(?: +class="(\\S+)")?(>[\\s\\S]*?</\\2>))', "gm");
    text = text.replace(blockRe, function (wholeMatch, k, tag, cls, rest) {
      if (!tag) // no following header or fenced code block.
        return '';

      // get attributes list from hash
      var key = parseInt(k, 10);
      var attributes = self.hashBlocks[key];

      // get id
      var id = attributes.match(/#[^\s#.]+/g) || [];
      var idStr = id[0] ? ' id="' + id[0].substr(1, id[0].length - 1) + '"' : '';

      // get classes and merge with existing classes
      var classes = attributes.match(/\.[^\s#.]+/g) || [];
      for (var i = 0; i < classes.length; i++) {
        // Remove leading dot
        classes[i] = classes[i].substr(1, classes[i].length - 1);
      }var classStr = '';
      if (cls) classes = union(classes, [cls]);

      if (classes.length > 0) classStr = ' class="' + classes.join(' ') + '"';

      return "<" + tag + idStr + classStr + rest;
    });

    return text;
  };

  /******************************************************************
   * Tables                                                         *
   *****************************************************************/

  // Find and convert Markdown Extra tables into html.
  Markdown.Extra.prototype.tables = function (text) {
    var self = this;

    var leadingPipe = new RegExp(['^', '[ ]{0,3}', // Allowed whitespace
    '[|]', // Initial pipe
    '(.+)\\n', // $1: Header Row

    '[ ]{0,3}', // Allowed whitespace
    '[|]([ ]*[-:]+[-| :]*)\\n', // $2: Separator

    '(', // $3: Table Body
    '(?:[ ]*[|].*\\n?)*', // Table rows
    ')', '(?:\\n|$)' // Stop at final newline
    ].join(''), 'gm');

    var noLeadingPipe = new RegExp(['^', '[ ]{0,3}', // Allowed whitespace
    '(\\S.*[|].*)\\n', // $1: Header Row

    '[ ]{0,3}', // Allowed whitespace
    '([-:]+[ ]*[|][-| :]*)\\n', // $2: Separator

    '(', // $3: Table Body
    '(?:.*[|].*\\n?)*', // Table rows
    ')', '(?:\\n|$)' // Stop at final newline
    ].join(''), 'gm');

    text = text.replace(leadingPipe, doTable);
    text = text.replace(noLeadingPipe, doTable);

    // $1 = header, $2 = separator, $3 = body
    function doTable(match, header, separator, body, offset, string) {
      // remove any leading pipes and whitespace
      header = header.replace(/^ *[|]/m, '');
      separator = separator.replace(/^ *[|]/m, '');
      body = body.replace(/^ *[|]/gm, '');

      // remove trailing pipes and whitespace
      header = header.replace(/[|] *$/m, '');
      separator = separator.replace(/[|] *$/m, '');
      body = body.replace(/[|] *$/gm, '');

      // determine column alignments
      var alignspecs = separator.split(/ *[|] */);
      var align = [];
      for (var i = 0; i < alignspecs.length; i++) {
        var spec = alignspecs[i];
        if (spec.match(/^ *-+: *$/m)) align[i] = ' align="right"';else if (spec.match(/^ *:-+: *$/m)) align[i] = ' align="center"';else if (spec.match(/^ *:-+ *$/m)) align[i] = ' align="left"';else align[i] = '';
      }

      // TODO: parse spans in header and rows before splitting, so that pipes
      // inside of tags are not interpreted as separators
      var headers = header.split(/ *[|] */);
      var colCount = headers.length;

      // build html
      var cls = self.tableClass ? ' class="' + self.tableClass + '"' : '';
      var html = ['<table', cls, '>\n', '<thead>\n', '<tr>\n'].join('');

      // build column headers.
      for (i = 0; i < colCount; i++) {
        var headerHtml = convertSpans(trim(headers[i]), self);
        html += ["  <th", align[i], ">", headerHtml, "</th>\n"].join('');
      }
      html += "</tr>\n</thead>\n";

      // build rows
      var rows = body.split('\n');
      for (i = 0; i < rows.length; i++) {
        if (rows[i].match(/^\s*$/)) // can apply to final row
          continue;

        // ensure number of rowCells matches colCount
        var rowCells = rows[i].split(/ *[|] */);
        var lenDiff = colCount - rowCells.length;
        for (var j = 0; j < lenDiff; j++) {
          rowCells.push('');
        }html += "<tr>\n";
        for (j = 0; j < colCount; j++) {
          var colHtml = convertSpans(trim(rowCells[j]), self);
          html += ["  <td", align[j], ">", colHtml, "</td>\n"].join('');
        }
        html += "</tr>\n";
      }

      html += "</table>\n";

      // replace html with placeholder until postConversion step
      return self.hashExtraBlock(html);
    }

    return text;
  };

  /******************************************************************
   * Footnotes                                                      *
   *****************************************************************/

  // Strip footnote, store in hashes.
  Markdown.Extra.prototype.stripFootnoteDefinitions = function (text) {
    var self = this;

    text = text.replace(/\n[ ]{0,3}\[\^(.+?)\]\:[ \t]*\n?([\s\S]*?)\n{1,2}((?=\n[ ]{0,3}\S)|$)/g, function (wholeMatch, m1, m2) {
      m1 = slugify(m1);
      m2 += "\n";
      m2 = m2.replace(/^[ ]{0,3}/g, "");
      self.footnotes[m1] = m2;
      return "\n";
    });

    return text;
  };

  // Find and convert footnotes references.
  Markdown.Extra.prototype.doFootnotes = function (text) {
    var self = this;
    if (self.isConvertingFootnote === true) {
      return text;
    }

    var footnoteCounter = 0;
    text = text.replace(/\[\^(.+?)\]/g, function (wholeMatch, m1) {
      var id = slugify(m1);
      var footnote = self.footnotes[id];
      if (footnote === undefined) {
        return wholeMatch;
      }
      footnoteCounter++;
      self.usedFootnotes.push(id);
      var html = '<a href="#fn_' + id + '" id="fnref_' + id + '" title="See footnote" class="footnote">' + footnoteCounter + '</a>';
      return self.hashExtraInline(html);
    });

    return text;
  };

  // Print footnotes at the end of the document
  Markdown.Extra.prototype.printFootnotes = function (text) {
    var self = this;

    if (self.usedFootnotes.length === 0) {
      return text;
    }

    text += '\n\n<div class="footnotes">\n<hr>\n<ol>\n\n';
    for (var i = 0; i < self.usedFootnotes.length; i++) {
      var id = self.usedFootnotes[i];
      var footnote = self.footnotes[id];
      self.isConvertingFootnote = true;
      var formattedfootnote = convertSpans(footnote, self);
      delete self.isConvertingFootnote;
      text += '<li id="fn_' + id + '">' + formattedfootnote + ' <a href="#fnref_' + id + '" title="Return to article" class="reversefootnote">&#8617;</a></li>\n\n';
    }
    text += '</ol>\n</div>';
    return text;
  };

  /******************************************************************
   * Fenced Code Blocks  (gfm)                                       *
   ******************************************************************/

  // Find and convert gfm-inspired fenced code blocks into html.
  Markdown.Extra.prototype.fencedCodeBlocks = function (text) {
    function encodeCode(code) {
      code = code.replace(/&/g, "&amp;");
      code = code.replace(/</g, "&lt;");
      code = code.replace(/>/g, "&gt;");
      // These were escaped by PageDown before postNormalization
      code = code.replace(/~D/g, "$$");
      code = code.replace(/~T/g, "~");
      return code;
    }

    var self = this;
    text = text.replace(/(?:^|\n)```[ \t]*(\S*)[ \t]*\n([\s\S]*?)\n```[ \t]*(?=\n)/g, function (match, m1, m2) {
      var codeOption = m1.replace(';', ',').split(','),
          codeblock = m2,
          language = codeOption[0].trim(),
          theme;
      if (codeOption.length > 1) {
        theme = codeOption[1].trim();
      }

      var preclass, codeclass, html;
      // 流程图、序列图保持原样
      if (language === 'flow' || language === 'seq' || language === 'sequence') {
        codeclass = ' class="language-' + language + '"';
        html = ['<pre><textarea readonly style="display:none;"', codeclass, '>', encodeCode(codeblock), '</textarea></pre>'].join('');
      } else if (self.codeMirror) {
        html = ['<div class="wiz-code-container" contenteditable="false"', ' data-mode="', language, '" data-theme="', theme, '"><textarea readonly style="display:none;">', encodeCode(codeblock), '</textarea></div>'].join('');
      } else {
        // adhere to specified options
        preclass = self.googleCodePrettify ? ' class="prettyprint linenums"' : '';
        codeclass = '';
        if (language) {
          if (self.codeMirror || self.googleCodePrettify || self.highlightJs) {
            // use html5 language- class names. supported by both prettify and highlight.js
            codeclass = ' class="language-' + language + '"';
          } else {
            codeclass = ' class="' + language + '"';
          }
        }

        html = ['<pre', preclass, '><code', codeclass, '>', encodeCode(codeblock), '</code></pre>'].join('');
      }

      // replace codeblock with placeholder until postConversion step
      return self.hashExtraBlock(html);
    });

    return text;
  };

  /******************************************************************
   * SmartyPants                                                     *
   ******************************************************************/

  Markdown.Extra.prototype.educatePants = function (text) {
    var self = this;
    var result = '';
    var blockOffset = 0;
    // Here we parse HTML in a very bad manner
    text.replace(/(?:<!--[\s\S]*?-->)|(<)([a-zA-Z1-6]+)([^\n]*?>)([\s\S]*?)(<\/\2>)/g, function (wholeMatch, m1, m2, m3, m4, m5, offset) {
      var token = text.substring(blockOffset, offset);
      result += self.applyPants(token);
      self.smartyPantsLastChar = result.substring(result.length - 1);
      blockOffset = offset + wholeMatch.length;
      if (!m1) {
        // Skip commentary
        result += wholeMatch;
        return;
      }
      // Skip special tags
      if (!/code|kbd|pre|script|noscript|iframe|math|ins|del|pre/i.test(m2)) {
        m4 = self.educatePants(m4);
      } else {
        self.smartyPantsLastChar = m4.substring(m4.length - 1);
      }
      result += m1 + m2 + m3 + m4 + m5;
    });
    var lastToken = text.substring(blockOffset);
    result += self.applyPants(lastToken);
    self.smartyPantsLastChar = result.substring(result.length - 1);
    return result;
  };

  function revertPants(wholeMatch, m1) {
    var blockText = m1;
    blockText = blockText.replace(/&\#8220;/g, "\"");
    blockText = blockText.replace(/&\#8221;/g, "\"");
    blockText = blockText.replace(/&\#8216;/g, "'");
    blockText = blockText.replace(/&\#8217;/g, "'");
    blockText = blockText.replace(/&\#8212;/g, "---");
    blockText = blockText.replace(/&\#8211;/g, "--");
    blockText = blockText.replace(/&\#8230;/g, "...");
    return blockText;
  }

  Markdown.Extra.prototype.applyPants = function (text) {
    // Dashes
    // text = text.replace(/---/g, "&#8212;").replace(/--/g, "&#8211;");
    // Ellipses
    // text = text.replace(/\.\.\./g, "&#8230;").replace(/\.\s\.\s\./g, "&#8230;");
    // Backticks
    // text = text.replace(/``/g, "&#8220;").replace(/''/g, "&#8221;");

    // if (/^'$/.test(text)) {
    //   // Special case: single-character ' token
    //   if (/\S/.test(this.smartyPantsLastChar)) {
    //     return "&#8217;";
    //   }
    //   return "&#8216;";
    // }
    // if (/^"$/.test(text)) {
    //   // Special case: single-character " token
    //   if (/\S/.test(this.smartyPantsLastChar)) {
    //     return "&#8221;";
    //   }
    //   return "&#8220;";
    // }

    // Special case if the very first character is a quote
    // followed by punctuation at a non-word-break. Close the quotes by brute force:
    // text = text.replace(/^'(?=[!"#\$\%'()*+,\-.\/:;<=>?\@\[\\]\^_`{|}~]\B)/, "&#8217;");
    // text = text.replace(/^"(?=[!"#\$\%'()*+,\-.\/:;<=>?\@\[\\]\^_`{|}~]\B)/, "&#8221;");

    // Special case for double sets of quotes, e.g.:
    //   <p>He said, "'Quoted' words in a larger quote."</p>
    // text = text.replace(/"'(?=\w)/g, "&#8220;&#8216;");
    // text = text.replace(/'"(?=\w)/g, "&#8216;&#8220;");

    // Special case for decade abbreviations (the '80s):
    // text = text.replace(/'(?=\d{2}s)/g, "&#8217;");

    // Get most opening single quotes:
    // text = text.replace(/(\s|&nbsp;|--|&[mn]dash;|&\#8211;|&\#8212;|&\#x201[34];)'(?=\w)/g, "$1&#8216;");

    // Single closing quotes:
    // text = text.replace(/([^\s\[\{\(\-])'/g, "$1&#8217;");
    // text = text.replace(/'(?=\s|s\b)/g, "&#8217;");

    // Any remaining single quotes should be opening ones:
    // text = text.replace(/'/g, "&#8216;");

    // Get most opening double quotes:
    // text = text.replace(/(\s|&nbsp;|--|&[mn]dash;|&\#8211;|&\#8212;|&\#x201[34];)"(?=\w)/g, "$1&#8220;");

    // Double closing quotes:
    // text = text.replace(/([^\s\[\{\(\-])"/g, "$1&#8221;");
    // text = text.replace(/"(?=\s)/g, "&#8221;");

    // Any remaining quotes should be opening ones.
    // text = text.replace(/"/ig, "&#8220;");
    return text;
  };

  // Find and convert markdown extra definition lists into html.
  Markdown.Extra.prototype.runSmartyPants = function (text) {
    this.smartyPantsLastChar = '';
    text = this.educatePants(text);
    // Clean everything inside html tags (some of them may have been converted due to our rough html parsing)
    text = text.replace(/(<([a-zA-Z1-6]+)\b([^\n>]*?)(\/)?>)/g, revertPants);
    return text;
  };

  /******************************************************************
   * Definition Lists                                                *
   ******************************************************************/

  // Find and convert markdown extra definition lists into html.
  Markdown.Extra.prototype.definitionLists = function (text) {
    var wholeList = new RegExp(['(\\x02\\n?|\\n\\n)', '(?:', '(', // $1 = whole list
    '(', // $2
    '[ ]{0,3}', '((?:[ \\t]*\\S.*\\n)+)', // $3 = defined term
    '\\n?', '[ ]{0,3}:[ ]+', // colon starting definition
    ')', '([\\s\\S]+?)', '(', // $4
    '(?=\\0x03)', // \z
    '|', '(?=', '\\n{2,}', '(?=\\S)', '(?!', // Negative lookahead for another term
    '[ ]{0,3}', '(?:\\S.*\\n)+?', // defined term
    '\\n?', '[ ]{0,3}:[ ]+', // colon starting definition
    ')', '(?!', // Negative lookahead for another definition
    '[ ]{0,3}:[ ]+', // colon starting definition
    ')', ')', ')', ')', ')'].join(''), 'gm');

    var self = this;
    text = addAnchors(text);

    text = text.replace(wholeList, function (match, pre, list) {
      var result = trim(self.processDefListItems(list));
      result = "<dl>\n" + result + "\n</dl>";
      return pre + self.hashExtraBlock(result) + "\n\n";
    });

    return removeAnchors(text);
  };

  // Process the contents of a single definition list, splitting it
  // into individual term and definition list items.
  Markdown.Extra.prototype.processDefListItems = function (listStr) {
    var self = this;

    var dt = new RegExp(['(\\x02\\n?|\\n\\n+)', // leading line
    '(', // definition terms = $1
    '[ ]{0,3}', // leading whitespace
    '(?![:][ ]|[ ])', // negative lookahead for a definition
    //   mark (colon) or more whitespace
    '(?:\\S.*\\n)+?', // actual term (not whitespace)
    ')', '(?=\\n?[ ]{0,3}:[ ])' // lookahead for following line feed
    ].join(''), //   with a definition mark
    'gm');

    var dd = new RegExp(['\\n(\\n+)?', // leading line = $1
    '(', // marker space = $2
    '[ ]{0,3}', // whitespace before colon
    '[:][ ]+', // definition mark (colon)
    ')', '([\\s\\S]+?)', // definition text = $3
    '(?=\\n*', // stop at next definition mark,
    '(?:', // next term or end of text
    '\\n[ ]{0,3}[:][ ]|', '<dt>|\\x03', // \z
    ')', ')'].join(''), 'gm');

    listStr = addAnchors(listStr);
    // trim trailing blank lines:
    listStr = listStr.replace(/\n{2,}(?=\\x03)/, "\n");

    // Process definition terms.
    listStr = listStr.replace(dt, function (match, pre, termsStr) {
      var terms = trim(termsStr).split("\n");
      var text = '';
      for (var i = 0; i < terms.length; i++) {
        var term = terms[i];
        // process spans inside dt
        term = convertSpans(trim(term), self);
        text += "\n<dt>" + term + "</dt>";
      }
      return text + "\n";
    });

    // Process actual definitions.
    listStr = listStr.replace(dd, function (match, leadingLine, markerSpace, def) {
      if (leadingLine || def.match(/\n{2,}/)) {
        // replace marker with the appropriate whitespace indentation
        def = Array(markerSpace.length + 1).join(' ') + def;
        // process markdown inside definition
        // TODO?: currently doesn't apply extensions
        def = outdent(def) + "\n\n";
        def = "\n" + convertAll(def, self) + "\n";
      } else {
        // convert span-level markdown inside definition
        def = rtrim(def);
        def = convertSpans(outdent(def), self);
      }

      return "\n<dd>" + def + "</dd>\n";
    });

    return removeAnchors(listStr);
  };

  /***********************************************************
   * todoList                                            *
   ************************************************************/
  Markdown.Extra.prototype.todo_list = function (text) {
    return text.replace(/^([ ]*)\[ \]/g, "$1<input type='checkbox' disabled class='wiz-md-todo-checkbox'>").replace(/^([ ]*)\[x\]/g, "$1<input type='checkbox' disabled checked class='wiz-md-todo-checkbox'>");
  };

  /***********************************************************
   * Strikethrough                                            *
   ************************************************************/

  Markdown.Extra.prototype.strikethrough = function (text) {
    // Pretty much duplicated from _DoItalicsAndBold
    // return text.replace(/([\W_]|^)~T~T(?=\S)([^\r]*?\S[\*_]*)~T~T([\W_]|$)/gm,
    //     "$1<del>$2</del>$3");
    return text.replace(/~T~T(?=\S)([^\r]*?\S[\*_]*)~T~T/g, "<del>$1</del>");
  };

  /***********************************************************
   * New lines                                                *
   ************************************************************/

  Markdown.Extra.prototype.newlines = function (text) {
    // We have to ignore already converted newlines and line breaks in sub-list items
    return text.replace(/(<(?:br|\/li)>)?\n/g, function (wholeMatch, previousTag) {
      return previousTag ? wholeMatch : " <br>\n";
    });
  };
})();

module.exports = Markdown.Extra;

},{}],396:[function(require,module,exports){
/*
 * $Id: base64.js,v 2.15 2014/04/05 12:58:57 dankogai Exp dankogai $
 *  https://github.com/dankogai/js-base64
 *  Licensed under the MIT license.
 *    http://opensource.org/licenses/mit-license
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */

'use strict';

var global = {};
// existing version for noConflict()
var _Base64 = global.Base64;
var version = "2.1.8";
// if node.js, we use Buffer
var buffer;
if (typeof module !== 'undefined' && module.exports) {
    buffer = require('buffer').Buffer;
}
// constants
var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
var b64tab = function (bin) {
    var t = {};
    for (var i = 0, l = bin.length; i < l; i++) {
        t[bin.charAt(i)] = i;
    }return t;
}(b64chars);
var fromCharCode = String.fromCharCode;
// encoder stuff
var cb_utob = function cb_utob(c) {
    if (c.length < 2) {
        var cc = c.charCodeAt(0);
        return cc < 0x80 ? c : cc < 0x800 ? fromCharCode(0xc0 | cc >>> 6) + fromCharCode(0x80 | cc & 0x3f) : fromCharCode(0xe0 | cc >>> 12 & 0x0f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);
    } else {
        var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);
        return fromCharCode(0xf0 | cc >>> 18 & 0x07) + fromCharCode(0x80 | cc >>> 12 & 0x3f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);
    }
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
var utob = function utob(u) {
    return u.replace(re_utob, cb_utob);
};
var cb_encode = function cb_encode(ccc) {
    var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0),
        chars = [b64chars.charAt(ord >>> 18), b64chars.charAt(ord >>> 12 & 63), padlen >= 2 ? '=' : b64chars.charAt(ord >>> 6 & 63), padlen >= 1 ? '=' : b64chars.charAt(ord & 63)];
    return chars.join('');
};
var btoa = global.btoa ? function (b) {
    return global.btoa(b);
} : function (b) {
    return b.replace(/[\s\S]{1,3}/g, cb_encode);
};
var _encode = buffer ? function (u) {
    return (u.constructor === buffer.constructor ? u : new buffer(u)).toString('base64');
} : function (u) {
    return btoa(utob(u));
};
var encode = function encode(u, urisafe) {
    return !urisafe ? _encode(String(u)) : _encode(String(u)).replace(/[+\/]/g, function (m0) {
        return m0 == '+' ? '-' : '_';
    }).replace(/=/g, '');
};
var encodeURI = function encodeURI(u) {
    return encode(u, true);
};
// decoder stuff
var re_btou = new RegExp(['[\xC0-\xDF][\x80-\xBF]', '[\xE0-\xEF][\x80-\xBF]{2}', '[\xF0-\xF7][\x80-\xBF]{3}'].join('|'), 'g');
var cb_btou = function cb_btou(cccc) {
    switch (cccc.length) {
        case 4:
            var cp = (0x07 & cccc.charCodeAt(0)) << 18 | (0x3f & cccc.charCodeAt(1)) << 12 | (0x3f & cccc.charCodeAt(2)) << 6 | 0x3f & cccc.charCodeAt(3),
                offset = cp - 0x10000;
            return fromCharCode((offset >>> 10) + 0xD800) + fromCharCode((offset & 0x3FF) + 0xDC00);
        case 3:
            return fromCharCode((0x0f & cccc.charCodeAt(0)) << 12 | (0x3f & cccc.charCodeAt(1)) << 6 | 0x3f & cccc.charCodeAt(2));
        default:
            return fromCharCode((0x1f & cccc.charCodeAt(0)) << 6 | 0x3f & cccc.charCodeAt(1));
    }
};
var btou = function btou(b) {
    return b.replace(re_btou, cb_btou);
};
var cb_decode = function cb_decode(cccc) {
    var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) | (len > 3 ? b64tab[cccc.charAt(3)] : 0),
        chars = [fromCharCode(n >>> 16), fromCharCode(n >>> 8 & 0xff), fromCharCode(n & 0xff)];
    chars.length -= [0, 0, 2, 1][padlen];
    return chars.join('');
};
var atob = global.atob ? function (a) {
    return global.atob(a);
} : function (a) {
    return a.replace(/[\s\S]{1,4}/g, cb_decode);
};
var _decode = buffer ? function (a) {
    return (a.constructor === buffer.constructor ? a : new buffer(a, 'base64')).toString();
} : function (a) {
    return btou(atob(a));
};
var decode = function decode(a) {
    return _decode(String(a).replace(/[-_]/g, function (m0) {
        return m0 == '-' ? '+' : '/';
    }).replace(/[^A-Za-z0-9\+\/]/g, ''));
};
var noConflict = function noConflict() {
    var Base64 = global.Base64;
    global.Base64 = _Base64;
    return Base64;
};
// export Base64
global.Base64 = {
    VERSION: version,
    atob: atob,
    btoa: btoa,
    fromBase64: decode,
    toBase64: encode,
    utob: utob,
    encode: encode,
    encodeURI: encodeURI,
    btou: btou,
    decode: decode,
    noConflict: noConflict
};
// if ES5 is available, make Base64.extendString() available
if (typeof Object.defineProperty === 'function') {
    var noEnum = function noEnum(v) {
        return { value: v, enumerable: false, writable: true, configurable: true };
    };
    global.Base64.extendString = function () {
        Object.defineProperty(String.prototype, 'fromBase64', noEnum(function () {
            return decode(this);
        }));
        Object.defineProperty(String.prototype, 'toBase64', noEnum(function (urisafe) {
            return encode(this, urisafe);
        }));
        Object.defineProperty(String.prototype, 'toBase64URI', noEnum(function () {
            return encode(this, true);
        }));
    };
}

module.exports = global.Base64;

},{"buffer":4}],397:[function(require,module,exports){
'use strict';

/**
 * 依赖的 css && 非可打包的 js 文件加载控制
 */
var CONST = require('../config/const');
var scriptLoader = require('./scriptLoader');

function loadGroup(doc, group, callback) {
  scriptLoader.load(doc, group, callback);
}

function makeCallback(doc, loadFiles, callback) {
  var count = 0,
      max = loadFiles.length;

  var cb = function cb() {
    if (count < max) {
      loadGroup(doc, loadFiles[count++], cb);
    } else if (callback) {
      callback();
    }
  };

  return cb;
}

function loadSingleCss(doc, path) {
  var cssId = 'wiz_' + path;
  if (doc.getElementById(cssId)) {
    return true;
  }

  var s = doc.createElement('link');
  s.rel = 'stylesheet';
  s.setAttribute('charset', "utf-8");
  s.setAttribute('name', CONST.NAME.TMP_STYLE);
  s.href = path.replace(/\\/g, '/');
  s.id = cssId;
  //s.className = this.PcCustomTagClass;
  doc.getElementsByTagName('head')[0].insertBefore(s, null);
  return s;
}

var dependLoader = {
  getDependencyFiles: function getDependencyFiles(envDependency, type, id) {
    var i = void 0,
        j = void 0,
        g = void 0,
        ii = void 0,
        jj = void 0,
        gg = void 0,
        group = void 0;
    var fileList = [];
    for (i = 0, j = envDependency[type][id].length; i < j; i++) {
      g = envDependency[type][id][i];
      if (type === 'css') {
        fileList.push(envDependency.files[type][g]);
      } else {
        group = [];
        for (ii = 0, jj = g.length; ii < jj; ii++) {
          gg = g[ii];
          group.push(envDependency.files[type][gg]);
        }
        fileList.push(group);
      }
    }
    return fileList;
  },
  loadJs: function loadJs(doc, loadFiles, callback) {
    var cb = makeCallback(doc, loadFiles, callback);
    cb();
  },
  loadCss: function loadCss(doc, loadFiles) {
    var i = void 0,
        j = void 0;
    for (i = 0, j = loadFiles.length; i < j; i++) {
      loadSingleCss(doc, loadFiles[i]);
    }
  }
};

module.exports = dependLoader;

},{"../config/const":388,"./scriptLoader":399}],398:[function(require,module,exports){
'use strict';

/**
 * 常用基本工具包
 */
var domPatch = {
  run: function run(win) {
    // package IE 不支持 Selection.extend
    // 参考：https://gist.github.com/tyler-johnson/0a3e8818de3f115b2a2dc47468ac0099
    if (win.Selection && !win.Selection.prototype.extend) {
      win.Selection.prototype.extend = function (el, offset) {
        var sel = win.document.getSelection();
        try {
          // ie11 会出现 sel.rangeCount 报错的情况
          if (!sel || sel.rangeCount === 0) {
            return;
          }
        } catch (e) {
          return;
        }

        var curRange = sel.getRangeAt(0);
        var range = win.document.createRange();

        var anchor = win.document.createRange();
        anchor.setStart(curRange.startContainer, curRange.startOffset);

        var focus = win.document.createRange();
        focus.setStart(el, offset);

        var v = focus.compareBoundaryPoints(Range.START_TO_START, anchor);
        if (v >= 0) {
          // focus is after anchor
          range.setStart(curRange.startContainer, curRange.startOffset);
          range.setEnd(el, offset);
        } else {
          // anchor is after focus
          range.setStart(el, offset);
          range.setEnd(curRange.startContainer, curRange.startOffset);
        }

        this.removeAllRanges();
        this.addRange(range);
      };
    }

    // 避免 IE11 点击 图片出现默认的操作
    win.document.body.addEventListener('mscontrolselect', function (evt) {
      evt.preventDefault();
    });
  }
};

module.exports = domPatch;

},{}],399:[function(require,module,exports){
'use strict';

/**
 * 用于加载 js
 * options 是数组，值有
 *  字符串：js地址
 *  对象(js需保存到localStorage)：
 *      {
 *         id:"",
 *         version:"",
 *         link:""
 *      }
 */

var scriptLoader = {
  appendJsCode: function appendJsCode(doc, jsStr, type) {
    var s = doc.createElement('script');
    s.type = type;
    s.text = jsStr;
    //s.className = this.PcCustomTagClass;
    doc.getElementsByTagName('head')[0].appendChild(s);
  },
  load: function load(doc, options, callback) {
    if (!doc || !options) {
      return;
    }
    var i = void 0,
        j = void 0,
        s = void 0,
        c = void 0,
        id = new Date().valueOf(),
        allLoaded = true;
    for (i = 0, j = options.length; i < j; i++) {
      if (typeof options[i] === "string") {
        s = this.loadSingleJs(doc, options[i]);
        if (s !== true) {
          var loadHandle = makeLoadHandle(id, callback);
          s.onload = loadHandle;
          s.onerror = loadHandle;
          allLoaded = false;
        }
      } else {
        var jsUrl = options[i].link,
            jsId = createJsId(options[i].id),
            jsVersion = options[i].version;
        if (window.localStorage) {
          var jsInfo = JSON.parse(localStorage.getItem(jsId));
          if (jsInfo && jsInfo.version === jsVersion) {
            s = this.inject(doc, jsInfo.jsStr, jsId);
            if (s !== true) {
              c = makeLoadHandle(id, callback);
              setTimeout(function () {
                c();
              }, 10);
              allLoaded = false;
            }
          } else {
            allLoaded = false;
            c = makeLoadHandle(id, callback);
            $.ajax({
              url: jsUrl,
              context: { id: jsId, version: jsVersion },
              success: function success(data) {
                save({ id: this.id, version: this.version, jsStr: data });
                s = scriptLoader.inject(doc, data, this.id);
                if (s !== true) {
                  setTimeout(function () {
                    c();
                  }, 10);
                }
              },
              error: function error() {
                c();
              }
            });
          }
        } else {
          s = this.loadSingleJs(doc, options[i].link);
          if (s !== true) {
            var _loadHandle = makeLoadHandle(id, callback);
            s.onload = _loadHandle;
            s.onerror = _loadHandle;
            allLoaded = false;
          }
        }
      }
    }
    if (allLoaded) {
      callback();
    }
  },
  loadSingleJs: function loadSingleJs(doc, path) {
    var jsId = 'wiz_' + path;
    if (doc.getElementById(jsId)) {
      return true;
    }
    var s = doc.createElement('script');
    s.type = 'text/javascript';
    s.setAttribute('charset', "utf-8");
    s.src = path.replace(/\\/g, '/');
    s.id = jsId;
    //s.className = utils.PcCustomTagClass;
    doc.getElementsByTagName('head')[0].insertBefore(s, null);
    return s;
  },
  inject: function inject(doc, jsStr, jsId) {
    if (!doc || doc.getElementById(jsId)) {
      return true;
    }
    var s = doc.createElement("script");
    s.type = 'text/javascript';
    s.id = jsId;
    s.text = jsStr;
    //s.className = utils.PcCustomTagClass;
    doc.getElementsByTagName('head')[0].insertBefore(s, null);
    return s;
  }
};
var loadCount = {};

function makeLoadHandle(id, loadCallback) {
  if (!loadCount[id]) {
    loadCount[id] = 0;
  }
  loadCount[id]++;
  return function (e) {
    if (e && e.type === 'error') {
      e.target.parentNode.removeChild(e.target);
    }
    loadCount[id]--;
    if (loadCount[id] === 0) {
      loadCount[id] = null;
      if (loadCallback) {
        loadCallback();
      }
    }
  };
}

function createJsId(jsId) {
  return "wiz_js_" + jsId;
}

function save(options) {
  if (!options) {
    return;
  }
  var jsInfo = {
    version: options.version,
    jsStr: options.jsStr
  };
  localStorage.setItem(options.id, JSON.stringify(jsInfo));
}

module.exports = scriptLoader;

},{}],400:[function(require,module,exports){
'use strict';

var CONST = require('../config/const');

// 填坑：安卓版 微信浏览器（6.5.4） localeCompare 错误 'Uncaught illegal access'
// MQQBrowser/6.2 TBS/043024 Safari/537.36 MicroMessenger/6.5.4.1000
try {
  'abc'.localeCompare('abcd');
} catch (e) {
  String.prototype.localeCompare = function (str) {
    return this.toString() === str ? 0 : this.toString() > str ? 1 : -1;
  };
}

// package trim()
var rTrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
if (!"wiz".trim) {
  String.prototype.trim = function () {
    return this.replace(rTrim, "");
  };
}

// package regexp 特殊字符替换
var matchRegExpKeyWord = /[\-\[\]{}()*+?.,\\^$|#\s]/g;
try {
  'abc'.escapeRegex();
} catch (e) {
  String.prototype.escapeRegex = function () {
    return this.toString().replace(matchRegExpKeyWord, '\\$&');
  };
}
// package replace 方法目标字符串 $ 字符替换
try {
  'abc'.escapeReplace();
} catch (e) {
  String.prototype.escapeReplace = function () {
    return this.toString().replace(/\$/ig, '$$$$');
  };
}

// package indexOf()
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function (n) {
    for (var i = 0; i < this.length; i++) {
      if (this[i] === n) {
        return i;
      }
    }
    return -1;
  };
}

/**
 * 常用基本工具包
 */
var utils = {
  /**
   * 检查 是否为有效的键盘输入内容
   * @param e
   * @returns {boolean}
   */
  checkNonTxtKey: function checkNonTxtKey(e) {
    var keyCode = e.keyCode || e.which;
    if (e.ctrlKey || e.metaKey) {
      return true;
    }
    return !(keyCode >= 48 && keyCode <= 57 || //0-9
    keyCode >= 65 && keyCode <= 90 || //a-z
    keyCode >= 96 && keyCode <= 107 || //小键盘0-9 * +
    keyCode >= 109 && keyCode <= 111 || //小键盘 / * -
    keyCode >= 186 && keyCode <= 192 || //标点符号
    keyCode >= 219 && keyCode <= 222 || //标点符号
    keyCode === 229 || keyCode === 0 || //中文
    keyCode === 13 || //Enter
    keyCode === 32 //空格
    );
  },
  /**
   * 判断 obj 是否为 数组
   * @param obj
   * @returns {boolean}
   */
  isArray: function isArray(obj) {
    return Object.prototype.toString.apply(obj) === "[object Array]";
  },
  /**
   * 判断字符串是否为空， 空格 不认为空
   * @param str
   * @returns {boolean}
   */
  isEmpty: function isEmpty(str) {
    if (!str) {
      return true;
    }
    var enter = /\r?\n/ig,
        r = new RegExp('[\r\n' + CONST.FILL_CHAR + ']', 'ig'),
        hasEnter = enter.test(str),
        _str = str.replace(r, ''),
        isNone = str.replace(r, '').trim().length === 0;
    //避免 正常标签只存在 一个空格时，也被误判
    return _str.length === 0 || hasEnter && isNone;
  },
  /**
   * 判断两个 修订时间是否近似相同
   * @param time1
   * @param time2
   * @returns {boolean}
   */
  isSameAmendTime: function isSameAmendTime(time1, time2) {
    if (!time1 || !time2) {
      return false;
    }
    var t1 = utils.getDateForTimeStr(time1),
        t2 = utils.getDateForTimeStr(time2);
    return Math.abs(t1 - t2) <= CONST.AMEND_BATCH_TIME_SPACE;
  },
  checkChar: function checkChar(char, rangeList) {
    var i = void 0,
        j = void 0,
        start = void 0,
        end = void 0;
    for (i = 0, j = rangeList.length; i < j; i++) {
      start = rangeList[i][0];
      end = rangeList[i].length > 1 ? rangeList[i][1] : null;
      if (end === null && char === start) {
        return true;
      } else if (end !== null && char >= start && char <= end) {
        return true;
      }
    }
    return false;
  },
  compareVersion: function compareVersion(v1, v2) {
    v1 = v1.split('.');
    v2 = v2.split('.');

    var i = void 0,
        j = void 0,
        n1 = void 0,
        n2 = void 0;
    for (i = 0, j = v1.length; i < j; i++) {
      n1 = parseInt(v1[i], 10);
      n2 = v2[i] ? parseInt(v2[i], 10) : -1;

      if (n1 < n2) {
        return -1;
      } else if (n1 > n2) {
        return 1;
      }
    }

    if (v1.length < v2.length) {
      return -1;
    }
    return 0;
  },
  isCJK: function isCJK(char) {
    var CJKRange = [[0x3040, 0x318f], [0x3300, 0x337f], [0x3400, 0x3d2d], [0x4e00, 0x9fff], [0xf900, 0xfaff], [0xac00, 0xd7af]];
    return utils.checkChar(char, CJKRange);
  },
  isSpace: function isSpace(char) {
    var SpaceRange = [[0x0009, 0x000D], [0x0020], [0x00A0]];
    return utils.checkChar(char, SpaceRange);
  },
  isAlpha: function isAlpha(char) {
    var AlphaRange = [[0x0030, 0x0039], [0x0041, 0x005A], [0x0061, 0x007A], [0x00C0, 0x00D6], [0x00D8, 0x00F6], [0x00F8, 0x100]];
    return utils.checkChar(char, AlphaRange);
  },
  forEach: function forEach(list, callback) {
    if (!list || !callback) {
      return;
    }
    for (var i = 0; i < list.length; i++) {
      callback(list[i], i);
    }
  },
  getWordCount: function getWordCount(str) {
    var count = {
      nWords: 0,
      nChars: 0,
      nCharsWithSpace: 0,
      nNonAsianWords: 0,
      nAsianChars: 0
    };
    if (!str) {
      return count;
    }
    var i = void 0,
        j = void 0,
        ch = void 0;
    var isAlpha = false;
    var isInWords = false;
    count.nCharsWithSpace = str.length; //字符串长度
    count.nChars = count.nCharsWithSpace;
    for (i = 0, j = str.length; i < j; i++) {
      ch = str.charCodeAt(i);
      isAlpha = false;
      if (utils.isCJK(ch)) {
        // 中文
        count.nAsianChars++;
      } else if (utils.isSpace(ch)) {
        // 空格
        count.nChars--;
      } else if (utils.isAlpha(ch)) {
        //字母
        isAlpha = true;
      }
      // console.log(ch);
      // console.log('isAlpha: ' + isAlpha + ', isInWords: ' + isInWords );

      if (isAlpha && !isInWords) {
        isInWords = true;
      } else if (!isAlpha) {
        if (isInWords) {
          count.nNonAsianWords++;
        }
        isInWords = false;
      }
    }
    // 修正最后一个单词
    if (isAlpha && isInWords) {
      count.nNonAsianWords++;
    }
    count.nWords = count.nNonAsianWords + count.nAsianChars;
    return count;
  },
  getEventClientPos: function getEventClientPos(e) {
    return {
      x: e.changedTouches ? e.changedTouches[0].clientX : e.clientX,
      y: e.changedTouches ? e.changedTouches[0].clientY : e.clientY
    };
  },
  getFileNameByUrl: function getFileNameByUrl(url) {
    var fileName = '';
    var index = url.lastIndexOf('/');
    if (index < 0) {
      fileName = url;
    } else {
      fileName = url.substr(index + 1);
    }
    return fileName;
  },
  /**
   * 获取字符串 的 hash 值
   * @param str
   * @returns {number}
   */
  getHash: function getHash(str) {
    var hash = 1315423911,
        i = void 0,
        ch = void 0;
    for (i = str.length - 1; i >= 0; i--) {
      ch = str.charCodeAt(i);
      hash ^= (hash << 5) + ch + (hash >> 2);
    }
    return hash & 0x7FFFFFFF;
  },
  /**
   * 生成当前时间戳，用于 修订的时间
   * @returns {string}
   */
  getTime: function getTime() {
    var d = new Date();
    return d.getFullYear() + '-' + to2(d.getMonth() + 1) + '-' + to2(d.getDate()) + ' ' + to2(d.getHours()) + ':' + to2(d.getMinutes()) + ':' + to2(d.getSeconds());

    function to2(num) {
      var str = num.toString();
      return str.length === 1 ? '0' + str : str;
    }
  },
  /**
   * 根据 日期字符串 返回 Date 对象（用于修订编辑，所以只支持 yyyy-mm-hh HH:MM:SS 格式）
   * @param str
   * @returns {Date}
   */
  getDateForTimeStr: function getDateForTimeStr(str) {
    return new Date(Date.parse(str.replace(/-/g, "/")));
  },
  /**
   * 将 list 转换为 Map （主要用于处理 tagNames）
   * @param list
   * @returns {{}}
   */
  listToMap: function listToMap(list) {
    if (!list) {
      return {};
    }
    list = utils.isArray(list) ? list : list.split(',');
    var i = void 0,
        j = void 0,
        ci = void 0,
        obj = {};
    for (i = 0, j = list.length; i < j; i++) {
      ci = list[i];
      obj[ci.toUpperCase()] = obj[ci] = 1;
    }
    return obj;
  },
  rgb2Hex: function rgb2Hex(str) {
    if (!str) {
      return '';
    }
    if (!/^rgba?\(.*\)$/i.test(str)) {
      return str;
    }

    var rgb = str.replace(/.*\((.*)\)/ig, '$1').split(',');
    if (rgb.length < 3) {
      return '';
    }
    var r = parseInt(rgb[0], 10),
        g = parseInt(rgb[1], 10),
        b = parseInt(rgb[2], 10),
        a = rgb.length === 4 ? parseFloat(rgb[3]) : 1;
    if (a === 0) {
      return '';
    }
    return '#' + getHex(getColor(r, a)) + getHex(getColor(g, a)) + getHex(getColor(b, a));

    function getColor(color, colorA) {
      return color + Math.floor((255 - color) * (1 - colorA));
    }

    function getHex(n) {
      var h = parseInt(n).toString(16);
      return h.length === 1 ? '0' + h : h;
    }
  },
  /**
   * 删除 数组中重复的数据
   * @param arr
   * @returns {Array}
   */
  removeDup: function removeDup(arr) {
    var result = [],
        i = void 0,
        j = void 0,
        a = void 0;
    for (i = 0, j = arr.length; i < j; i++) {
      a = arr[i];
      if (result.indexOf(a) < 0) {
        result.push(a);
      }
    }
    return result;
  },
  replaceSpecialChar: function replaceSpecialChar(text) {
    // 替换 C2A0 为普通空格
    // 删除 占位符
    text = text.replace(new RegExp(String.fromCharCode(160), 'g'), ' ').replace(String.fromCharCode(65279), '');
    return text;
  },
  /**
   * 阻止默认事件
   * @param e
   */
  stopEvent: function stopEvent(e, onlyDefault) {
    if (!e) {
      return;
    }
    if (!onlyDefault) {
      e.stopPropagation();
    }

    e.preventDefault();
    //这个会阻止其他同event 的触发，过于野蛮
    //e.stopImmediatePropagation();
  },
  txt2HTML: function txt2HTML(txt, options) {
    options = options || {};
    var saveSpecialDom = !!options.wizTableSaveDom;
    var regTab = /	/g;
    var regSpace = /  /g;
    var regSpaceFirst = /^ /gm;
    // regSpace 必须处理两次，否则连续 3 个空格会导致后两个没有被处理
    // regSpaceFirst 主要用于处理 一个空格开头的情况
    txt = (txt || '').replace(regTab, '    ').replace(regSpace, '\xA0 ').replace(regSpace, '\xA0 ').replace(regSpaceFirst, '\xA0');
    var result = [];
    var lineList = txt.split(/\r?\n/);
    var lineStr = void 0,
        line = void 0;
    var tableReg = new RegExp(CONST.WIZ_TABLE_IN_MARKDOWN_SRC_REG);
    var codeReg = /^```/;
    var codeStart = false;
    for (var i = 0; i < lineList.length; i++) {
      lineStr = lineList[i];

      // 只有再 editor.on reader.on 的时候才针对 table 做特殊处理，
      // 但不能对 code 区域内的 table 进行处理
      if (saveSpecialDom && !codeStart && codeReg.test(lineStr)) {
        codeStart = true;
      } else if (saveSpecialDom && codeStart && codeReg.test(lineStr)) {
        codeStart = false;
      }
      if (saveSpecialDom && !codeStart && tableReg.test(lineStr)) {
        line = lineStr;
      } else if (lineStr) {
        if (saveSpecialDom) {
          line = '<div>' + lineStr.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</div>';
        } else {
          var tag = i === 0 ? 'span' : 'div';
          line = '<' + tag + '>' + lineStr.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</' + tag + '>';
        }
      } else {
        line = '<br/>';
      }
      result.push(line);
    }
    return result.join('');
  }
};

module.exports = utils;

},{"../config/const":388}],401:[function(require,module,exports){
'use strict';

/**
 * xss 工具包
 */
var filterXSS = require('xss');

var xssUtils = {
  xssFilter: function () {
    if (typeof filterXSS === 'undefined') {
      return null;
    }
    var fileName = decodeURIComponent(location.pathname),
        fileNameStart = fileName.lastIndexOf('/') + 1,
        fileNameEnd = fileName.lastIndexOf('.');
    fileName = fileNameEnd > 0 ? fileName.substring(fileNameStart, fileNameEnd) + '_files' : '';

    // var imgSrc = 'file://|data:image/';
    // var imgSrcReg = new RegExp('^(' + imgSrc + fileName + ')', 'i');
    // var imgSrcReg = /^javascript:/i;

    var hrefReg = /^((file|wiz(note)?):\/\/)|(index_files\/)|(data:image\/(?!svg))/;
    var hrefFileSrc = '#';
    var hrefFileReg = new RegExp('^(' + hrefFileSrc.escapeRegex() + (fileName ? '|' + fileName.escapeRegex() : '') + ')', 'i');

    var tagAttrReg = /^(id|class|name|style|data|width|height)/i;

    var xss = new filterXSS.FilterXSS({
      onIgnoreTag: function onIgnoreTag(tag, html, options) {
        //针对白名单之外的 tag 处理
        if (/script/ig.test(tag)) {
          return filterXSS.escapeAttrValue(html);
        }
        if (options.isClosing) {
          return '</' + tag + '>';
        }

        var x = filterXSS.parseAttr(html, function (name, value) {
          value = xss.options.safeAttrValue(tag, name, value, xss);
          if (/^on/i.test(name)) {
            return '';
          } else if (value) {
            return name + '="' + value + '"';
          } else {
            return name;
          }
        });

        if (/^<!/i.test(html)) {
          //<!doctype html>
          x = '<!' + x;
        } else {
          x = '<' + x;
        }

        if (html[html.length - 2] === '/') {
          x += '/';
        }
        x += '>';
        return x;
      },
      // onIgnoreTagAttr: function (tag, name, value, isWhiteAttr) {
      onIgnoreTagAttr: function onIgnoreTagAttr(tag, name, value) {
        if (!/^object$/i.test(tag) && !!value && tagAttrReg.test(name)) {
          return name + '="' + value + '"';
        }
        return '';
      },
      safeAttrValue: function safeAttrValue(tag, name, value) {
        // 避免 title 中出现 <script>
        if (name === 'title') {
          value = value.replace(/</g, "&lt;") // use HTML entity for <
          .replace(/>/g, "&gt;"); // use HTML entity for
        }
        if (/^meta$/i.test(tag)) {
          if (/^http-equiv$/i.test(name) && /refresh/i.test(value)) {
            return '';
          }
        }
        // 自定义过滤属性值函数，如果为a标签的href属性，则先判断是否以wiz://开头
        if (name === 'href' || name === 'src') {
          // 需要修正 '//' 开头的地址，否则会导致 粘贴的 img 无法正常显示
          var protocol = window.location.protocol;
          if (!/^https?:/.test(protocol)) {
            protocol = 'http:';
          }
          value = value.replace(/^\/\//, protocol + '//');
          if (hrefReg.test(value) || hrefFileReg.test(value)) {
            return filterXSS.escapeAttrValue(value);
          }
        }
        // 其他情况，使用默认的safeAttrValue处理函数
        return filterXSS.safeAttrValue(tag, name, value);
      }
    });

    // 增加白名单
    xss.options.whiteList.iframe = ['src', 'scrolling'];
    xss.options.whiteList.button = ['title', 'type', 'value'];
    xss.options.whiteList.object = [];
    xss.options.whiteList.noscript = [];

    return function (html) {
      html = xss.process(html);
      // 修正 style 中的 > 符号
      var styleReg = /(<style(\s+[^>]*)?>)(.*)(<\/style>)/ig;
      html = html.replace(styleReg, function (match, p1, p2, p3, p4) {
        return p1 + p3.replace(/&gt;/ig, '>') + p4;
      });
      return html;
    };
  }()
};

module.exports = xssUtils;

},{"xss":336}],402:[function(require,module,exports){
'use strict';

var LANG = {};

LANG['en'] = {
  version: 'en',
  Month: ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May', 'June', 'July', 'Agu.', 'Sep.', 'Oct.', 'Nov.', 'Dec.'],
  Amend: {
    Edit: 'Inserted contents',
    Delete: 'Deleted contents',
    BtnAccept: 'Accept',
    BtnRefuse: 'Reject',
    Accept: 'Accept all changes? Or partially select the changes which need to be accepted.',
    Refuse: 'Reject all changes? Or partially select the changes which need to be rejected.',
    MultiInfo: 'Multiple changes are selected',
    UserNameDefault: 'someone'
  },
  Code: {
    Wrap: 'Code wrap',
    Language: 'Language',
    Theme: 'Theme'
  },
  Toolbar: {
    LinkTopic: 'Topic'
  },
  Table: {
    Copy: 'Copy',
    Paste: 'Paste',
    ClearCell: 'Clear',
    MergeCell: 'Merge Cells',
    SplitCell: 'Unmerge Cells',
    InsertRowUp: 'Add Row Above',
    InsertRowDown: 'Add Row Below',
    InsertColLeft: 'Add Column Before',
    InsertColRight: 'Add Column After',
    DeleteRow: 'Delete Row',
    DeleteCol: 'Delete Column',
    SetCellBg: 'Color Fill',
    CellAlign: 'Arrange',
    DeleteTable: 'Delete Table',
    DistributeCols: 'Average Column Width'
  },
  Err: {
    Copy_Null: 'Copy of deleted changes not allowed',
    Cut_Null: 'Cut of deleted changes not allowed'
  }
};
LANG['zh-cn'] = {
  version: 'zh-cn',
  Date: {
    Year: '年',
    Month: '月',
    Day: '日'
  },
  Amend: {
    Edit: '插入了内容',
    Delete: '删除了内容',
    BtnAccept: '接受修订',
    BtnRefuse: '拒绝修订',
    Accept: '是否确认接受全部修订内容？ 如需接受部分内容请使用鼠标进行选择',
    Refuse: '是否确认拒绝全部修订内容？ 如需拒绝部分内容请使用鼠标进行选择',
    MultiInfo: '您选中了多处修订',
    UserNameDefault: '有人'
  },
  Code: {
    Wrap: '自动换行',
    Language: '语言',
    Theme: '配色'
  },
  Toolbar: {
    LinkTopic: '标题'
  },
  Table: {
    Copy: '复制',
    Paste: '粘贴',
    ClearCell: '清空单元格',
    MergeCell: '合并单元格',
    SplitCell: '拆分单元格',
    InsertRowUp: '上插入行',
    InsertRowDown: '下插入行',
    InsertColLeft: '左插入列',
    InsertColRight: '右插入列',
    DeleteRow: '删除当前行',
    DeleteCol: '删除当前列',
    SetCellBg: '单元格底色',
    CellAlign: '单元格对齐方式',
    DeleteTable: '删除表格',
    DistributeCols: '平均分配各列'
  },
  Err: {
    Copy_Null: '无法复制已删除的内容',
    Cut_Null: '无法剪切已删除的内容'
  }
};
LANG['zh-tw'] = {
  version: 'zh-tw',
  Date: {
    Year: '年',
    Month: '月',
    Day: '日'
  },
  Amend: {
    Edit: '插入了內容',
    Delete: '刪除了內容',
    BtnAccept: '接受修訂',
    BtnRefuse: '拒絕修訂',
    Accept: '是否確認接受全部修訂內容？ 如需接受部分內容請使用滑鼠進行選擇',
    Refuse: '是否確認拒絕全部修訂內容？ 如需拒絕部分內容請使用滑鼠進行選擇',
    MultiInfo: '您選中了多處修訂',
    UserNameDefault: '有人'
  },
  Code: {
    Wrap: '自動換行',
    Language: '語言',
    Theme: '配色'
  },
  Toolbar: {
    LinkTopic: '標題'
  },
  Table: {
    Copy: '複製',
    Paste: '粘貼',
    ClearCell: '清空儲存格',
    MergeCell: '合併儲存格',
    SplitCell: '拆分儲存格',
    InsertRowUp: '上插入行',
    InsertRowDown: '下插入行',
    InsertColLeft: '左插入列',
    InsertColRight: '右插入列',
    DeleteRow: '刪除當前行',
    DeleteCol: '刪除當前列',
    SetCellBg: '儲存格底色',
    CellAlign: '儲存格對齊方式',
    DeleteTable: '刪除表格',
    DistributeCols: '平均分配各列'
  },
  Err: {
    Copy_Null: '無法複製已刪除的內容',
    Cut_Null: '無法剪切已刪除的內容'
  }
};

var Lang = function Lang(type, env) {
  var userLangType = 'en';
  var userLang = {};

  // 默认情况根据浏览器判断语言
  if (!type) {
    var win = env.win || window;
    type = win.navigator.language.replace('_', '-').toLowerCase();
    if (/^zh-/.test(type)) {
      if (/(hant)|(tw)|(hk)/.test(type)) {
        type = 'zh-tw';
      } else {
        type = 'zh-cn';
      }
    } else if (/^zh/.test(type)) {
      type = 'zh-cn';
    } else {
      type = 'en';
    }
  }

  //同时支持 zh-cn & zh_cn
  type = type.toLowerCase().replace('_', '-');
  if (LANG[type]) {
    userLangType = type;
  } else {
    type = 'en';
  }
  for (var k in LANG[type]) {
    if (LANG[type].hasOwnProperty(k)) {
      userLang[k] = LANG[type][k];
    }
  }
  return userLang;
};

module.exports = Lang;

},{}],403:[function(require,module,exports){
'use strict';

// 执行时间测试包
(function () {
  var DebugTimer = function DebugTimer() {
    var _this = this;

    // 专门测试程序效率时使用
    this.timeList = {};

    this.add = function (id, name) {
      if (!id || !name) {
        console.error('add(id, name) : id or name can not be empty.');
        return;
      }
      var timeList = _this.timeList[id];
      if (!timeList) {
        console.error('You must run start(id) at first!');
        return;
      }
      var start = timeList[timeList.length - 1];
      var end = {
        time: new Date().valueOf(),
        name: name
      };
      timeList.push(end);
      console.log('[' + id + '] - ' + end.name + ' : ' + (end.time - start.time));
    };

    this.end = function (id) {
      if (!id) {
        console.error('end(id) : id can not be empty.');
        return;
      }
      var timeList = _this.timeList[id];
      if (!timeList) {
        console.error('You must run start(id) at first!');
        return;
      }
      console.log('[' + id + '] - total : ' + (timeList[timeList.length - 1].time - timeList[0].time));
    };

    this.start = function (id) {
      if (!id) {
        console.error('start(id) : id can not be empty.');
        return;
      }
      _this.timeList[id] = [{
        time: new Date().valueOf(),
        name: ''
      }];
    };
  };

  window.wizDebugTimer = new DebugTimer();
})();

},{}]},{},[392]);
